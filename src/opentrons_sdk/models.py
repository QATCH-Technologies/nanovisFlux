# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2026-01-30T19:06:28+00:00



from __future__ import annotations

from datetime import datetime
from enum import Enum, IntEnum
from typing import Any, List, Literal, Union

from pydantic import BaseModel, Extra, Field, SecretStr


class AbsorbanceReaderLidStatus(Enum):
    """
    Absorbance reader lid status.
    """

    unknown = 'unknown'
    on = 'on'
    off = 'off'


class ModuleType(Enum):
    absorbanceReaderType = 'absorbanceReaderType'


class ModuleModel(Enum):
    absorbanceReaderV1 = 'absorbanceReaderV1'


class AbsorbanceReaderPlatePresence(Enum):
    """
    Absorbance reader plate presence.
    """

    unknown = 'unknown'
    present = 'present'
    absent = 'absent'


class AbsorbanceReaderStatus(Enum):
    idle = 'idle'
    measuring = 'measuring'
    error = 'error'


class AddWifiKeyFileResponse(BaseModel):
    """
    Response to add wifi key file
    """

    uri: str = Field(
        ...,
        description='A URI for the key (mostly for use with DELETE /wifi/keys/{key_id})',
        title='Uri',
    )
    id: str = Field(
        ...,
        description='A contents hash of the key used to specify the key in POST /wifi/configure (and also to determine the key URI)',
        title='Id',
    )
    name: str = Field(..., description='The original filename of the key', title='Name')
    message: str | None = Field(None, title='Message')


class AddressableAreaLocation(BaseModel):
    """
    The location of something place in an addressable area. This is a superset of deck slots.
    """

    addressableAreaName: str = Field(
        ...,
        description='The name of the addressable area that you want to use. Valid values are the `id`s of `addressableArea`s in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck).',
        title='Addressableareaname',
    )


class AddressableOffsetVector(BaseModel):
    """
    Offset, in deck coordinates, from nominal to actual position of an addressable area.
    """

    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')
    z: float = Field(..., title='Z')


class AdvancedSetting(BaseModel):
    """
    An advanced setting (Feature Flag)
    """

    id: str = Field(..., description='The machine-readable property ID', title='Id')
    old_id: str | None = Field(
        ...,
        deprecated=True,
        description='The ID by which the property used to be known; not useful now and may contain spaces or hyphens',
        title='Old Id',
    )
    title: str = Field(
        ...,
        description='A human-readable short string suitable for display as the title of the setting',
        title='Title',
    )
    description: str = Field(
        ...,
        description='A human-readable long string suitable for display as a paragraph or two explaining the setting',
        title='Description',
    )
    restart_required: bool = Field(
        ...,
        description='Whether a robot restart is required to make this change take effect',
        title='Restart Required',
    )
    value: bool | None = Field(
        ...,
        description='Whether the setting is off by previous user choice (false), true by user choice (true), or off and has never been altered (null)',
        title='Value',
    )


class AdvancedSettingRequest(BaseModel):
    """
    Configure the setting to change and the new value
    """

    id: str = Field(
        ...,
        description='The ID of the setting to change (something returned by GET /settings)',
        title='Id',
    )
    value: bool | None = Field(
        None,
        description='The new value to set. If null, reset to default',
        title='Value',
    )


class CommandType(Enum):
    airGapInPlace = 'airGapInPlace'


class AirGapInPlaceParams(BaseModel):
    """
    Payload required to air gap in place.
    """

    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description="The amount of liquid to aspirate, in µL. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors.",
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class AirGapInPlaceResult(BaseModel):
    """
    Result data from the execution of a AirGapInPlace command.
    """

    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class Style(Enum):
    ALL = 'ALL'


class AllNozzleLayoutConfiguration(BaseModel):
    """
    All basemodel to represent a reset to the nozzle configuration. Sending no parameters resets to default.
    """

    style: Style = Field('ALL', const=True, title='Style')


class Id(Enum):
    AnalysisNotFound = 'AnalysisNotFound'


class AnalysisRequest(BaseModel):
    """
    Model for analysis request body.
    """

    runTimeParameterValues: dict[str, int | float | bool | str] | None = Field(
        {},
        description='Key-value pairs of primitive run-time parameters defined in a protocol.',
        title='Runtimeparametervalues',
    )
    runTimeParameterFiles: dict[str, str] | None = Field(
        {},
        description='Key-fileId pairs of CSV run-time parameters defined in a protocol.',
        title='Runtimeparameterfiles',
    )
    forceReAnalyze: bool | None = Field(
        False,
        description='Whether to force start a new analysis.',
        title='Forcereanalyze',
    )


class AnalysisResult(Enum):
    """
    Result of a completed protocol analysis.

    The result indicates whether the protocol is expected to run successfully.

    Properties:
        OK: No problems were found during protocol analysis.
        NOT_OK: Problems were found during protocol analysis. Inspect
            `analysis.errors` for error occurrences.
        PARAMETER_VALUE_REQUIRED: A value is required to be set for a parameter
            in order for the protocol to be analyzed/run. The absence of this does not
            inherently mean there are no parameters, as there may be defaults for all
            or unset parameters are not referenced or handled via try/except clauses.
    """

    ok = 'ok'
    not_ok = 'not-ok'
    parameter_value_required = 'parameter-value-required'


class AnalysisStatus(Enum):
    """
    Status of a protocol analysis.
    """

    pending = 'pending'
    completed = 'completed'


class CommandType2(Enum):
    aspirate = 'aspirate'


class CommandType4(Enum):
    aspirateInPlace = 'aspirateInPlace'


class AspirateInPlaceParams(BaseModel):
    """
    Payload required to aspirate in place.
    """

    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description="The amount of liquid to aspirate, in µL. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors.",
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class AspirateInPlaceResult(BaseModel):
    """
    Result data from the execution of a AspirateInPlace command.
    """

    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class FlowRateByVolumeItem1(BaseModel):
    __root__: int = Field(..., ge=0)


class FlowRateByVolumeItem2(BaseModel):
    __root__: float = Field(..., ge=0.0)


class FlowRateByVolumeItem3(BaseModel):
    __root__: int = Field(..., ge=0)


class FlowRateByVolumeItem4(BaseModel):
    __root__: float = Field(..., ge=0.0)


class FlowRateByVolumeItem(BaseModel):
    __root__: tuple[
        FlowRateByVolumeItem1 | FlowRateByVolumeItem2,
        FlowRateByVolumeItem3 | FlowRateByVolumeItem4,
    ] = Field(...)  # Removed min_items=2, max_items=2


class CorrectionByVolumeItem1(BaseModel):
    __root__: int = Field(..., ge=0)


class CorrectionByVolumeItem2(BaseModel):
    __root__: float = Field(..., ge=0.0)


class CorrectionByVolumeItem(BaseModel):
    __root__: tuple[CorrectionByVolumeItem1 | CorrectionByVolumeItem2, int | float] = (
        Field(...)  # Removed min_items=2, max_items=2
    )


class CommandType6(Enum):
    aspirateWhileTracking = 'aspirateWhileTracking'


class Ok(Enum):
    """
    If the instrument is not OK, a previous update was interrupted. It must be updated again.
    """

    boolean_False = False


class InstrumentType(Enum):
    gripper = 'gripper'


class InstrumentType1(Enum):
    pipette = 'pipette'


class Ok2(Enum):
    boolean_False = False


class CommandType8(Enum):
    blowout = 'blowout'


class CommandType10(Enum):
    blowOutInPlace = 'blowOutInPlace'


class BlowOutInPlaceParams(BaseModel):
    """
    Payload required to blow-out in place.
    """

    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class BlowOutInPlaceResult(BaseModel):
    """
    Result data from the execution of a BlowOutInPlace command.
    """


class BlowoutLocation(Enum):
    """
    Location for blowout during a transfer function.
    """

    source = 'source'
    destination = 'destination'
    trash = 'trash'


class FlowRate(BaseModel):
    __root__: int = Field(
        ...,
        description='Flow rate for blow out, in microliters per second.',
        gt=0,
        title='Flow Rate',
    )


class FlowRate1(BaseModel):
    __root__: float = Field(
        ...,
        description='Flow rate for blow out, in microliters per second.',
        gt=0.0,
        title='Flow Rate',
    )


class BlowoutParams(BaseModel):
    """
    Parameters for blowout.
    """

    class Config:
        extra = Extra.forbid

    location: BlowoutLocation = Field(
        ..., description='Location well or trash entity for blow out.'
    )
    flow_rate: FlowRate | FlowRate1 = Field(
        ...,
        description='Flow rate for blow out, in microliters per second.',
        title='Flow Rate',
    )


class BlowoutProperties(BaseModel):
    """
    Blowout properties.
    """

    class Config:
        extra = Extra.forbid

    enable: bool = Field(
        ..., description='Whether blow-out is enabled.', title='Enable'
    )
    params: BlowoutParams | None = Field(
        None, description='Parameters for the blowout function.', title='Params'
    )


class BodyPostWifiKeyWifiKeysPost(BaseModel):
    key: bytes = Field(..., title='Key')


class BodyUploadDataFileDataFilesPost(BaseModel):
    file: bytes | None = Field(None, description='Data file to upload', title='File')
    file_path: str | None = Field(
        None, description='Absolute path to a file on the robot.', title='File Path'
    )


class Type(Enum):
    """
    String specifying the type of this parameter
    """

    bool = 'bool'


class BooleanParameter(BaseModel):
    """
    A boolean parameter defined in a protocol.
    """

    displayName: str = Field(
        ..., description='Display string for the parameter.', title='Displayname'
    )
    variableName: str = Field(
        ..., description='Python variable name of the parameter.', title='Variablename'
    )
    description: str | None = Field(
        None, description='Detailed description of the parameter.', title='Description'
    )
    suffix: str | None = Field(
        None,
        description='Units (like mL, mm/sec, etc) or a custom suffix for the parameter.',
        title='Suffix',
    )
    type: Type = Field(
        'bool',
        const=True,
        description='String specifying the type of this parameter',
        title='Type',
    )
    value: bool = Field(
        ...,
        description='The value assigned to the parameter; if not supplied by the client, will be assigned the default value.',
        title='Value',
    )
    default: bool = Field(
        ...,
        description='Default value of the parameter, to be used when there is no client-specified value.',
        title='Default',
    )


class BrandData(BaseModel):
    brand: str = Field(..., title='Brand')
    brandId: list[str] | None = Field(None, title='Brandid')
    links: list[str] | None = Field(None, title='Links')


class Type1(Enum):
    """
    String specifying the type of this parameter
    """

    csv_file = 'csv_file'


class CommandType12(Enum):
    calibration_calibrateGripper = 'calibration/calibrateGripper'


class CalibrateGripperParamsJaw(Enum):
    front = 'front'
    rear = 'rear'


class CommandType14(Enum):
    calibration_calibrateModule = 'calibration/calibrateModule'


class CommandType16(Enum):
    calibration_calibratePipette = 'calibration/calibratePipette'


class SessionType(Enum):
    calibrationCheck = 'calibrationCheck'


class Rank(Enum):
    """
    The order of a given pipette
    """

    first = 'first'
    second = 'second'


class CheckAttachedPipette(BaseModel):
    model: str | None = Field(
        None,
        description='The model of the attached pipette. These are snake case as in the Protocol API. This includes the full version string',
        title='Model',
    )
    name: str | None = Field(
        None,
        description='Short name of pipette model withoutgeneration version',
        title='Name',
    )
    tipLength: float | None = Field(
        None, description='The default tip length for this pipette', title='Tiplength'
    )
    mount: str | None = Field(
        None, description='The mount this pipette attached to', title='Mount'
    )
    serial: str | None = Field(
        None, description='The serial number of the attached pipette', title='Serial'
    )
    defaultTipracks: list[dict[str, Any]] | None = Field(
        None,
        description='A list of default tipracks for this pipette',
        title='Defaulttipracks',
    )
    rank: Rank = Field(..., description='The order of a given pipette', title='Rank')
    tipRackLoadName: str = Field(
        ..., description='The load name of the tiprack', title='Tiprackloadname'
    )
    tipRackDisplay: str = Field(
        ..., description='The display name of the tiprack', title='Tiprackdisplay'
    )
    tipRackUri: str = Field(
        ..., description='The uri of the tiprack', title='Tiprackuri'
    )


class Shape(Enum):
    circular = 'circular'


class Diameter(BaseModel):
    __root__: int = Field(..., ge=0, title='Diameter')


class Diameter1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Diameter')


class Depth(BaseModel):
    __root__: int = Field(..., ge=0, title='Depth')


class Depth1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Depth')


class TotalLiquidVolume(BaseModel):
    __root__: int = Field(..., ge=0, title='Totalliquidvolume')


class TotalLiquidVolume1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Totalliquidvolume')


class X(BaseModel):
    __root__: int = Field(..., ge=0, title='X')


class X1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='X')


class Z(BaseModel):
    __root__: int = Field(..., ge=0, title='Z')


class Z1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Z')


class Y(BaseModel):
    __root__: int = Field(..., ge=0, title='Y')


class Y1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Y')


class CircularWellDefinition2(BaseModel):
    class Config:
        extra = Extra.allow

    shape: Shape = Field('circular', const=True, title='Shape')
    diameter: Diameter | Diameter1 = Field(..., title='Diameter')
    depth: Depth | Depth1 = Field(..., title='Depth')
    totalLiquidVolume: TotalLiquidVolume | TotalLiquidVolume1 = Field(
        ..., title='Totalliquidvolume'
    )
    x: X | X1 = Field(..., title='X')
    z: Z | Z1 = Field(..., title='Z')
    geometryDefinitionId: str | None = Field(None, title='Geometrydefinitionid')
    y: Y | Y1 = Field(..., title='Y')


class Diameter2(BaseModel):
    __root__: int = Field(..., ge=0, title='Diameter')


class Diameter3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Diameter')


class Depth2(BaseModel):
    __root__: int = Field(..., ge=0, title='Depth')


class Depth3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Depth')


class TotalLiquidVolume2(BaseModel):
    __root__: int = Field(..., ge=0, title='Totalliquidvolume')


class TotalLiquidVolume3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Totalliquidvolume')


class X2(BaseModel):
    __root__: int = Field(..., ge=0, title='X')


class X3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='X')


class Z2(BaseModel):
    __root__: int = Field(..., ge=0, title='Z')


class Z3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Z')


class Y2(BaseModel):
    __root__: int = Field(..., le=0, title='Y')


class Y3(BaseModel):
    __root__: float = Field(..., le=0.0, title='Y')


class CircularWellDefinition3(BaseModel):
    class Config:
        extra = Extra.allow

    shape: Shape = Field('circular', const=True, title='Shape')
    diameter: Diameter2 | Diameter3 = Field(..., title='Diameter')
    depth: Depth2 | Depth3 = Field(..., title='Depth')
    totalLiquidVolume: TotalLiquidVolume2 | TotalLiquidVolume3 = Field(
        ..., title='Totalliquidvolume'
    )
    x: X2 | X3 = Field(..., title='X')
    z: Z2 | Z3 = Field(..., title='Z')
    geometryDefinitionId: str | None = Field(None, title='Geometrydefinitionid')
    y: Y2 | Y3 = Field(..., title='Y')


class Id1(Enum):
    ClientDataKeyDoesNotExist = 'ClientDataKeyDoesNotExist'


class CommandType18(Enum):
    robot_closeGripperJaw = 'robot/closeGripperJaw'


class CloseGripperJawParams(BaseModel):
    """
    Payload required to close a gripper.
    """

    force: float | None = Field(
        None,
        description='The force the gripper should use to hold the jaws, falls to default if none is provided.',
        title='Force',
    )


class CloseGripperJawResult(BaseModel):
    """
    Result data from the execution of a CloseGripperJaw command.
    """


class CommandType20(Enum):
    heaterShaker_closeLabwareLatch = 'heaterShaker/closeLabwareLatch'


class CloseLabwareLatchParams(BaseModel):
    """
    Input parameters to close a Heater-Shaker Module's labware latch.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )


class CloseLabwareLatchResult(BaseModel):
    """
    Result data from closing a Heater-Shaker's labware latch.
    """


class Style1(Enum):
    COLUMN = 'COLUMN'


class PrimaryNozzle(Enum):
    """
    The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle.
    """

    A1 = 'A1'
    H1 = 'H1'
    A12 = 'A12'
    H12 = 'H12'


class ColumnNozzleLayoutConfiguration(BaseModel):
    """
    Information required for nozzle configurations of type ROW and COLUMN.
    """

    style: Style1 = Field('COLUMN', const=True, title='Style')
    primaryNozzle: PrimaryNozzle = Field(
        ...,
        description='The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle.',
        title='Primarynozzle',
    )


class CommandIntent(Enum):
    """
    Run intent for a given command.

    Props:
        PROTOCOL: the command is part of the protocol run itself.
        SETUP: the command is part of the setup phase of a run.
    """

    protocol = 'protocol'
    setup = 'setup'
    fixit = 'fixit'


class CommandLinkMeta(BaseModel):
    """
    Metadata about a command resource referenced in `links`.
    """

    runId: str = Field(..., description="The ID of the command's run.", title='Runid')
    commandId: str = Field(..., description='The ID of the command.', title='Commandid')
    index: int = Field(
        ...,
        description="The index of the command in the run's overall command list.",
        title='Index',
    )
    key: str = Field(
        ..., description="The value of the command's `key` field.", title='Key'
    )
    createdAt: datetime = Field(
        ..., description='When the command was created.', title='Createdat'
    )


class CommandLinkNoMeta(BaseModel):
    """
    A link to a command resource without a meta field.
    """

    id: str = Field(..., description='The ID of the command.', title='Id')
    href: str = Field(
        ..., description='The HTTP API path to the command.', title='Href'
    )


class NoteKind(Enum):
    """
    The kind of note this is. Only the literal possibilities should be relied upon programmatically.
    """

    warning = 'warning'
    information = 'information'


class CommandNote(BaseModel):
    """
    A note about a command's execution or dispatch.
    """

    noteKind: NoteKind | str = Field(
        ...,
        description='The kind of note this is. Only the literal possibilities should be relied upon programmatically.',
        title='Notekind',
    )
    shortMessage: str = Field(
        ...,
        description='The accompanying human-readable short message (suitable for display in a single line)',
        title='Shortmessage',
    )
    longMessage: str = Field(
        ...,
        description='A longer message that may contain newlines and formatting characters describing the note.',
        title='Longmessage',
    )
    source: str = Field(
        ...,
        description='An identifier for the party that created the note',
        title='Source',
    )


class CommandType22(Enum):
    comment = 'comment'


class CommentParams(BaseModel):
    """
    Payload required to annotate execution with a comment.
    """

    message: str = Field(..., description='A user-facing message', title='Message')


class CommentResult(BaseModel):
    """
    Result data from the execution of a Comment command.
    """


class ComparisonStatus(BaseModel):
    """
    A model describing the comparison of a checked point to calibrated value
    """

    differenceVector: list[float] = Field(
        ...,
        description='An offset vector in deck coordinates (x, y, z)',
        max_items=3,
        min_items=3,
        title='Differencevector',
    )
    thresholdVector: list[float] = Field(
        ...,
        description='An offset vector in deck coordinates (x, y, z)',
        max_items=3,
        min_items=3,
        title='Thresholdvector',
    )
    exceedsThreshold: bool = Field(..., title='Exceedsthreshold')


class Status(Enum):
    """
    Status marking the analysis as completed
    """

    completed = 'completed'


class RobotType(Enum):
    """
    The type of robot that this protocol can run on. This field was added in v7.1.0. It will be `null` or omitted in analyses that were originally created on older versions.
    """

    OT_2_Standard = 'OT-2 Standard'
    OT_3_Standard = 'OT-3 Standard'


class CommandType24(Enum):
    configureForVolume = 'configureForVolume'


class ConfigureForVolumeParams(BaseModel):
    """
    Parameters required to configure volume for a specific pipette.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    volume: float = Field(
        ...,
        description='Amount of liquid in uL. Must be at least 0 and no greater than a pipette-specific maximum volume.',
        ge=0.0,
        title='Volume',
    )
    tipOverlapNotAfterVersion: str | None = Field(
        None,
        description='A version of tip overlap data to not exceed. The highest-versioned tip overlap data that does not exceed this version will be used. Versions are expressed as vN where N is an integer, counting up from v0. If None, the current highest version will be used.',
        title='Tipoverlapnotafterversion',
    )


class ConfigureForVolumeResult(BaseModel):
    """
    Result data from execution of an ConfigureForVolume command.
    """


class CommandType26(Enum):
    configureNozzleLayout = 'configureNozzleLayout'


class ConfigureNozzleLayoutResult(BaseModel):
    """
    Result data from execution of an configureNozzleLayout command.
    """


class Shape2(Enum):
    conical = 'conical'


class BottomDiameter(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomdiameter')


class BottomDiameter1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomdiameter')


class TopDiameter(BaseModel):
    __root__: int = Field(..., ge=0, title='Topdiameter')


class TopDiameter1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topdiameter')


class TopHeight(BaseModel):
    __root__: int = Field(..., ge=0, title='Topheight')


class TopHeight1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topheight')


class BottomHeight(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomheight')


class BottomHeight1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomheight')


class ConicalFrustum(BaseModel):
    shape: Literal['conical'] = Field(..., const=True, title='Shape')
    bottomDiameter: BottomDiameter | BottomDiameter1 = Field(
        ..., title='Bottomdiameter'
    )
    topDiameter: TopDiameter | TopDiameter1 = Field(..., title='Topdiameter')
    topHeight: TopHeight | TopHeight1 = Field(..., title='Topheight')
    bottomHeight: BottomHeight | BottomHeight1 = Field(..., title='Bottomheight')
    xCount: int | None = Field(1, ge=0, title='Xcount')
    yCount: int | None = Field(1, ge=0, title='Ycount')


class ConnectionType(Enum):
    wifi = 'wifi'
    ethernet = 'ethernet'


class ConnectivityStatus(Enum):
    full = 'full'
    limited = 'limited'
    none = 'none'
    portal = 'portal'
    unknown = 'unknown'


class Coordinate(BaseModel):
    """
    Three-dimensional coordinates.
    """

    x: int | float = Field(..., title='X')
    y: int | float = Field(..., title='Y')
    z: int | float = Field(..., title='Z')


class Shape3(Enum):
    cuboidal = 'cuboidal'


class BottomXDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomxdimension')


class BottomXDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomxdimension')


class BottomYDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomydimension')


class BottomYDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomydimension')


class TopXDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Topxdimension')


class TopXDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topxdimension')


class TopYDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Topydimension')


class TopYDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topydimension')


class TopHeight2(BaseModel):
    __root__: int = Field(..., ge=0, title='Topheight')


class TopHeight3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topheight')


class BottomHeight2(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomheight')


class BottomHeight3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomheight')


class CuboidalFrustum(BaseModel):
    shape: Literal['cuboidal'] = Field(..., const=True, title='Shape')
    bottomXDimension: BottomXDimension | BottomXDimension1 = Field(
        ..., title='Bottomxdimension'
    )
    bottomYDimension: BottomYDimension | BottomYDimension1 = Field(
        ..., title='Bottomydimension'
    )
    topXDimension: TopXDimension | TopXDimension1 = Field(..., title='Topxdimension')
    topYDimension: TopYDimension | TopYDimension1 = Field(..., title='Topydimension')
    topHeight: TopHeight2 | TopHeight3 = Field(..., title='Topheight')
    bottomHeight: BottomHeight2 | BottomHeight3 = Field(..., title='Bottomheight')
    xCount: int | None = Field(1, ge=0, title='Xcount')
    yCount: int | None = Field(1, ge=0, title='Ycount')


class CurrentStateLinks(BaseModel):
    """
    Links returned with the current state of a run.
    """

    lastCompleted: CommandLinkNoMeta | None = Field(
        None,
        description='Path to the last completed command when current state was reported, if any.',
    )


class CommandType28(Enum):
    custom = 'custom'


class AnnotationType(Enum):
    custom = 'custom'


class CustomCommandAnnotation(BaseModel):
    """
    Annotates a group of atomic commands in some manner that Opentrons software does not anticipate or originate.
    """

    class Config:
        extra = Extra.allow

    commandKeys: list[str] = Field(
        ...,
        description='Command keys to which this annotation applies',
        title='Commandkeys',
    )
    annotationType: AnnotationType = Field('custom', const=True, title='Annotationtype')


class CustomParams(BaseModel):
    """
    Payload used by a custom command.
    """

    class Config:
        extra = Extra.allow


class CustomResult(BaseModel):
    """
    Result data from a custom command.
    """

    class Config:
        extra = Extra.allow


class CutoutFixture(BaseModel):
    """
    A single element of the robot's deck configuration.
    """

    cutoutFixtureId: str = Field(
        ...,
        description='What kind of cutout fixture is mounted onto the deck. Valid values are the `id`s of `cutoutFixtures` in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck).',
        title='Cutoutfixtureid',
    )
    cutoutId: str = Field(
        ...,
        description='Where on the deck this cutout fixture is mounted. Valid values are the `id`s of `cutouts` in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck).',
        title='Cutoutid',
    )
    opentronsModuleSerialNumber: str | None = Field(
        None,
        description='The serial number of a module loaded as a fixture. [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck).',
        title='Opentronsmoduleserialnumber',
    )


class Id2(Enum):
    DataFileInUse = 'DataFileInUse'


class DataFileSource(Enum):
    """
    The source this data file is from.
    """

    uploaded = 'uploaded'
    generated = 'generated'


class CommandType30(Enum):
    thermocycler_deactivateBlock = 'thermocycler/deactivateBlock'


class DeactivateBlockParams(BaseModel):
    """
    Input parameters to unset a Thermocycler's target block temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler.', title='Moduleid'
    )


class DeactivateBlockResult(BaseModel):
    """
    Result data from unsetting a Thermocycler's target block temperature.
    """


class CommandType32(Enum):
    heaterShaker_deactivateHeater = 'heaterShaker/deactivateHeater'


class DeactivateHeaterParams(BaseModel):
    """
    Input parameters to unset a Heater-Shaker's target temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )


class DeactivateHeaterResult(BaseModel):
    """
    Result data from unsetting a Heater-Shaker's target temperature.
    """


class CommandType34(Enum):
    thermocycler_deactivateLid = 'thermocycler/deactivateLid'


class DeactivateLidParams(BaseModel):
    """
    Input parameters to unset a Thermocycler's target lid temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler.', title='Moduleid'
    )


class DeactivateLidResult(BaseModel):
    """
    Result data from unsetting a Thermocycler's target lid temperature.
    """


class CommandType36(Enum):
    heaterShaker_deactivateShaker = 'heaterShaker/deactivateShaker'


class DeactivateShakerParams(BaseModel):
    """
    Input parameters to deactivate shaker for a Heater-Shaker Module.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )


class DeactivateShakerResult(BaseModel):
    """
    Result data from deactivating shaker for a Heater-Shaker.
    """


class CommandType38(Enum):
    temperatureModule_deactivate = 'temperatureModule/deactivate'


class DeactivateTemperatureParams(BaseModel):
    """
    Input parameters to deactivate a Temperature Module.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Temperature Module.', title='Moduleid'
    )


class DeactivateTemperatureResult(BaseModel):
    """
    Result data from deactivating a Temperature Module.
    """


class SessionType2(Enum):
    deckCalibration = 'deckCalibration'


class Status1(Enum):
    """
    The status of this calibration type,dependent on the calibration beinginside or outside of the threshold
    """

    IN_THRESHOLD = 'IN_THRESHOLD'
    OUTSIDE_THRESHOLD = 'OUTSIDE_THRESHOLD'


class DeckComparisonMap(BaseModel):
    status: Status1 = Field(
        ...,
        description='The status of this calibration type,dependent on the calibration beinginside or outside of the threshold',
        title='Status',
    )
    comparingPointOne: ComparisonStatus | None = Field(
        None, description='point 1 validation step'
    )
    comparingPointTwo: ComparisonStatus | None = Field(
        None, description='point 2 validation step'
    )
    comparingPointThree: ComparisonStatus | None = Field(
        None, description='point 3 validation step'
    )


class DeckConfigurationRequest(BaseModel):
    """
    A request to set the robot's deck configuration.
    """

    cutoutFixtures: list[CutoutFixture] = Field(
        ...,
        description='A full list of all the cutout fixtures that are mounted onto the deck. The order is arbitrary.',
        title='Cutoutfixtures',
    )


class DeckConfigurationResponse(BaseModel):
    """
    A response for the robot's current deck configuration.
    """

    cutoutFixtures: list[CutoutFixture] = Field(
        ...,
        description='A full list of all the cutout fixtures that are mounted onto the deck. The order is arbitrary.',
        title='Cutoutfixtures',
    )
    lastModifiedAt: datetime | None = Field(
        ...,
        description='When the deck configuration was last set over HTTP. If that has never happened, this will be `null` or omitted.',
        title='Lastmodifiedat',
    )


class DeckPoint(BaseModel):
    """
    Coordinates of a point in deck space.
    """

    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')
    z: float = Field(..., title='Z')


class DeckSlotName(Enum):
    """
    Deck slot identifiers.
    """

    field_1 = '1'
    field_2 = '2'
    field_3 = '3'
    field_4 = '4'
    field_5 = '5'
    field_6 = '6'
    field_7 = '7'
    field_8 = '8'
    field_9 = '9'
    field_10 = '10'
    field_11 = '11'
    field_12 = '12'
    A1 = 'A1'
    A2 = 'A2'
    A3 = 'A3'
    B1 = 'B1'
    B2 = 'B2'
    B3 = 'B3'
    C1 = 'C1'
    C2 = 'C2'
    C3 = 'C3'
    D1 = 'D1'
    D2 = 'D2'
    D3 = 'D3'


class DeckTransformState(Enum):
    OK = 'OK'
    IDENTITY = 'IDENTITY'
    BAD_CALIBRATION = 'BAD_CALIBRATION'
    SINGULARITY = 'SINGULARITY'


class Duration(BaseModel):
    __root__: int = Field(
        ..., description='Duration of delay, in seconds.', ge=0, title='Duration'
    )


class Duration1(BaseModel):
    __root__: float = Field(
        ..., description='Duration of delay, in seconds.', ge=0.0, title='Duration'
    )


class DelayParams(BaseModel):
    """
    Parameters for delay.
    """

    class Config:
        extra = Extra.forbid

    duration: Duration | Duration1 = Field(
        ..., description='Duration of delay, in seconds.', title='Duration'
    )


class DelayProperties(BaseModel):
    """
    Shared properties for delay.
    """

    class Config:
        extra = Extra.forbid

    enable: bool = Field(..., description='Whether delay is enabled.', title='Enable')
    params: DelayParams | None = Field(
        None, description='Parameters for the delay function.', title='Params'
    )


class YDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Ydimension')


class YDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Ydimension')


class ZDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Zdimension')


class ZDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Zdimension')


class XDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Xdimension')


class XDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Xdimension')


class Dimensions(BaseModel):
    yDimension: YDimension | YDimension1 = Field(..., title='Ydimension')
    zDimension: ZDimension | ZDimension1 = Field(..., title='Zdimension')
    xDimension: XDimension | XDimension1 = Field(..., title='Xdimension')


class CommandType40(Enum):
    magneticModule_disengage = 'magneticModule/disengage'


class DisengageParams(BaseModel):
    """
    Input data to disengage a Magnetic Module's magnets.
    """

    moduleId: str = Field(
        ...,
        description='The ID of the Magnetic Module whose magnets you want to disengage, from a prior `loadModule` command.',
        title='Moduleid',
    )


class DisengageResult(BaseModel):
    """
    The result of a Magnetic Module disengage command.
    """


class CommandType42(Enum):
    dispense = 'dispense'


class CommandType44(Enum):
    dispenseInPlace = 'dispenseInPlace'


class DispenseInPlaceParams(BaseModel):
    """
    Payload required to dispense in place.
    """

    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description='The amount of liquid to dispense, in µL. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors.',
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    pushOut: float | None = Field(
        None,
        description='push the plunger a small amount farther than necessary for accurate low-volume dispensing',
        title='Pushout',
    )


class DispenseInPlaceResult(BaseModel):
    """
    Result data from the execution of a DispenseInPlace command.
    """

    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class DispenseResult(BaseModel):
    """
    Result data from the execution of a Dispense command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class CommandType46(Enum):
    dispenseWhileTracking = 'dispenseWhileTracking'


class DispenseWhileTrackingResult(BaseModel):
    """
    Result data from the execution of a Dispense command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class DisplayCategory(Enum):
    tipRack = 'tipRack'
    tubeRack = 'tubeRack'
    reservoir = 'reservoir'
    trash = 'trash'
    wellPlate = 'wellPlate'
    aluminumBlock = 'aluminumBlock'
    adapter = 'adapter'
    other = 'other'
    lid = 'lid'
    system = 'system'


class DoorState(Enum):
    open = 'open'
    closed = 'closed'


class DoorStatusModel(BaseModel):
    """
    Model for the current door status.
    """

    status: DoorState = Field(..., description='Whether the door is open or closed.')
    doorRequiredClosedForProtocol: bool = Field(
        ...,
        description='Whether the door must be closed to run a protcol.',
        title='Doorrequiredclosedforprotocol',
    )
    moduleSerial: str | None = Field(
        None,
        description='The module serial number for the module door that is opened.',
        title='Moduleserial',
    )


class CommandType48(Enum):
    dropTip = 'dropTip'


class CommandType50(Enum):
    dropTipInPlace = 'dropTipInPlace'


class DropTipInPlaceParams(BaseModel):
    """
    Payload required to drop a tip in place.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    homeAfter: bool | None = Field(
        None,
        description="Whether to home this pipette's plunger after dropping the tip. You should normally leave this unspecified to let the robot choose a safe default depending on its hardware.",
        title='Homeafter',
    )


class DropTipInPlaceResult(BaseModel):
    """
    Result data from the execution of a DropTipInPlace command.
    """


class DropTipResult(BaseModel):
    """
    Result data from the execution of a DropTip command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class DropTipWellOrigin(Enum):
    """
    The origin of a DropTipWellLocation offset.

    Props:
        TOP: the top-center of the well
        BOTTOM: the bottom-center of the well
        CENTER: the middle-center of the well
        DEFAULT: the default drop-tip location of the well,
            based on pipette configuration and length of the tip.
    """

    top = 'top'
    bottom = 'bottom'
    center_ = 'center'
    default = 'default'


class EapConfigOptionType(Enum):
    string = 'string'
    password = 'password'
    file = 'file'


class CommandType52(Enum):
    flexStacker_empty = 'flexStacker/empty'


class EmptyModel(BaseModel):
    pass


class Count(BaseModel):
    __root__: int = Field(
        ...,
        description='The new count of labware in the pool. If None, default to an empty pool. If this number is larger than the amount of labware currently in the pool, default to the smaller amount. Do not use the value in the parameters as an outside observer; instead, use the count value from the results.',
        ge=0,
        title='Count',
    )


class CommandType54(Enum):
    magneticModule_engage = 'magneticModule/engage'


class EngageParams(BaseModel):
    """
    Input data to engage a Magnetic Module.
    """

    moduleId: str = Field(
        ...,
        description='The ID of the Magnetic Module whose magnets you want to raise, from a prior `loadModule` command.',
        title='Moduleid',
    )
    height: float = Field(
        ...,
        description="How high, in millimeters, to raise the magnets.\n\nZero means the tops of the magnets are level with the ledge that the labware rests on. This will be slightly above the magnets' minimum height, the hardware home position. Negative values are allowed, to put the magnets below the ledge.\n\nUnits are always true millimeters. This is unlike certain labware definitions, engage commands in the Python Protocol API, and engage commands in older versions of the JSON protocol schema. Take care to convert properly.",
        title='Height',
    )


class EngageResult(BaseModel):
    """
    The result of a Magnetic Module engage command.
    """


class EngagedMotor(BaseModel):
    """
    Engaged motor
    """

    enabled: bool = Field(..., description='Is engine enabled', title='Enabled')


class EngagedMotors(BaseModel):
    """
    Which motors are engaged.
    """

    x: EngagedMotor
    y: EngagedMotor
    z_l: EngagedMotor
    z_r: EngagedMotor
    p_l: EngagedMotor
    p_r: EngagedMotor
    q: EngagedMotor | None = None
    g: EngagedMotor | None = None


class EngineStatus(Enum):
    """
    Current execution status of a ProtocolEngine.

    This is a high-level summary of what the robot is doing and what interactions are
    appropriate.
    """

    idle = 'idle'
    running = 'running'
    paused = 'paused'
    blocked_by_open_door = 'blocked-by-open-door'
    stop_requested = 'stop-requested'
    finishing = 'finishing'
    awaiting_recovery = 'awaiting-recovery'
    awaiting_recovery_paused = 'awaiting-recovery-paused'
    awaiting_recovery_blocked_by_open_door = 'awaiting-recovery-blocked-by-open-door'
    stopped = 'stopped'
    failed = 'failed'
    succeeded = 'succeeded'


class EnumChoice(BaseModel):
    """
    Components of choices used in RTP Enum Parameters.
    """

    displayName: str = Field(
        ..., description="Display string for the param's choice.", title='Displayname'
    )
    value: int | float | str = Field(
        ..., description="Enum value of the param's choice.", title='Value'
    )


class Type2(Enum):
    """
    String specifying whether the parameter is an int or float or string type.
    """

    int = 'int'
    float = 'float'
    str = 'str'


class EnumParameter(BaseModel):
    """
    A string enum defined in a protocol.
    """

    displayName: str = Field(
        ..., description='Display string for the parameter.', title='Displayname'
    )
    variableName: str = Field(
        ..., description='Python variable name of the parameter.', title='Variablename'
    )
    description: str | None = Field(
        None, description='Detailed description of the parameter.', title='Description'
    )
    suffix: str | None = Field(
        None,
        description='Units (like mL, mm/sec, etc) or a custom suffix for the parameter.',
        title='Suffix',
    )
    type: Type2 = Field(
        ...,
        description='String specifying whether the parameter is an int or float or string type.',
        title='Type',
    )
    choices: list[EnumChoice] = Field(
        ..., description='List of valid choices for this parameter.', title='Choices'
    )
    value: int | float | str = Field(
        ...,
        description='The value assigned to the parameter; if not supplied by the client, will be assigned the default value.',
        title='Value',
    )
    default: int | float | str = Field(
        ...,
        description='Default value of the parameter, to be used when there is no client-specified value.',
        title='Default',
    )


class ErrorLocationInfo(BaseModel):
    """
    Holds a retry location for in-place error recovery.

    This is appropriate to pass to a `moveToCoordinates` command,
    assuming the pipette has not been configured with a different nozzle layout
    in the meantime.
    """

    retryLocation: tuple[float, float, float] = Field(..., title='Retrylocation')


class ErrorMatcher(BaseModel):
    """
    The error type that this rule applies to.
    """

    errorType: str = Field(
        ..., description='The error type that this rule applies to.', title='Errortype'
    )


class ErrorOccurrence(BaseModel):
    """
    An occurrence of a specific error during protocol execution.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(
        False,
        description="Whether this error is *defined.*\n\n*Defined* errors have a strictly defined cause and effect, and we generally\ndesign them to be recoverable. For example, a `pickUpTip` command might\nreturn a `tipPhysicallyMissing` error, which is defined, and which you can\nrecover from by doing a new `pickUpTip` in a different location.\n\nThe `errorType` and `errorInfo` fields are useful for reacting to defined\nerrors.\n\n*Undefined* errors are everything else. They could represent more obscure\nhardware failures that we aren't handling yet, or just bugs in our software.\nYou can continue issuing commands to a run after it encounters an undefined\nerror, but the robot may not behave well. For example, if a movement command\nfails with an undefined error, it could leave the robot in a messed-up\nstate, and the next movement command could have bad path planning that\ncollides the pipettes with stuff on the deck. We allow you to take this risk\nbecause it's sometimes better than safely stopping the run, which can\nwaste time and reagents.\n",
        title='Isdefined',
    )
    errorType: str = Field(
        ...,
        description='This field has two meanings.\n\nWhen `isDefined` is `true`, this is a machine- and developer-readable\nidentifier for what kind of error this is. You can use this to implement\ninteractive error recovery flows, like watching for `"overpressure"` errors\nso you can tell the operator to unclog the tip.\n\nWhen `isDefined` is `false`, this is deprecated. For historical reasons,\nit will be the Python class name of some internal exception,\nlike `"KeyError"` or `"UnexpectedProtocolError"`. The string values are not\nstable across software versions. If you\'re looking for something to show to\nrobot operators, use `errorCode` and `detail` instead.\n',
        title='Errortype',
    )
    errorCode: str = Field(
        ...,
        description='An enumerated error code for the error type.\nThis is intended to be shown to the robot operator to direct them to the\ncorrect rough area for troubleshooting.\n',
        title='Errorcode',
    )
    detail: str = Field(
        ...,
        description="A short human-readable message about the error.\n\nThis is intended to provide the robot operator with more specific details than\n`errorCode` alone. It should be no longer than a couple of sentences,\nand it should not contain internal newlines or indentation.\n\nIt should not internally repeat `errorCode`, but it may internally repeat `errorType`\nif it helps the message make sense when it's displayed in its own separate block.\n",
        title='Detail',
    )
    errorInfo: dict[str, Any] = Field(
        ...,
        description='Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n',
        title='Errorinfo',
    )
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class ErrorSource(BaseModel):
    """
    An object containing references to the source of the error.
    """

    pointer: str | None = Field(
        None,
        description='A JSON Pointer [RFC6901] to the associated entity in the request document.',
        title='Pointer',
    )
    parameter: str | None = Field(
        None,
        description='a string indicating which URI query parameter caused the error.',
        title='Parameter',
    )
    header: str | None = Field(
        None,
        description='A string indicating which header caused the error.',
        title='Header',
    )


class EstopPhysicalStatus(Enum):
    """
    Physical status of a specific estop.
    """

    engaged = 'engaged'
    disengaged = 'disengaged'
    notPresent = 'notPresent'


class EstopState(Enum):
    """
    Current status of the estop on this robot.
    """

    notPresent = 'notPresent'
    physicallyEngaged = 'physicallyEngaged'
    logicallyEngaged = 'logicallyEngaged'
    disengaged = 'disengaged'


class EstopStatusModel(BaseModel):
    """
    Model for the current estop status.
    """

    status: EstopState = Field(
        ..., description='The current status of the estop on this robot.'
    )
    leftEstopPhysicalStatus: EstopPhysicalStatus = Field(
        ..., description='Physical status of the left estop mount.'
    )
    rightEstopPhysicalStatus: EstopPhysicalStatus = Field(
        ..., description='Physical status of the right estop mount.'
    )


class Id3(Enum):
    FileIdNotFound = 'FileIdNotFound'


class FileIdNotFound(BaseModel):
    """
    An error returned when specified file id was not found on the robot.
    """

    id: Id3 = Field('FileIdNotFound', const=True, title='Id')
    title: str | None = Field('Specified file id not found on the robot', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class FileInfo(BaseModel):
    """
    A file UUID descriptor.
    """

    id: str = Field(
        ...,
        description='The UUID identifier of the file stored on the robot.',
        title='Id',
    )
    name: str = Field(
        ..., description='Name of the file, including the extension.', title='Name'
    )


class Id4(Enum):
    FileNotFound = 'FileNotFound'


class FileNotFound(BaseModel):
    """
    An error returned when specified file path was not found on the robot.
    """

    id: Id4 = Field('FileNotFound', const=True, title='Id')
    title: str | None = Field(
        'Specified file path not found on the robot', title='Title'
    )
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class CommandType56(Enum):
    flexStacker_fill = 'flexStacker/fill'


class Count1(BaseModel):
    __root__: int = Field(
        ...,
        description='How full the labware pool should now be. If None, default to the maximum amount of the currently-configured labware the pool can hold. If this number is larger than the maximum the pool can hold, it will be clamped to the maximum. If this number is smaller than the current amount of labware the pool holds, it will be clamped to that minimum. Do not use the value in the parameters as an outside observer; instead, use the count value from the results.',
        ge=1,
        title='Count',
    )


class Id5(Enum):
    FirmwareUpdateFailed = 'FirmwareUpdateFailed'


class FirmwareUpdateFailed(BaseModel):
    """
    An error if a firmware update failed for some reason.
    """

    id: Id5 = Field('FirmwareUpdateFailed', const=True, title='Id')
    title: str | None = Field('Firmware Update Failed', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class ModuleType1(Enum):
    flexStackerModuleType = 'flexStackerModuleType'


class ModuleModel1(Enum):
    flexStackerModuleV1 = 'flexStackerModuleV1'


class FlexStackerState(BaseModel):
    """
    Provides the current state of a Flex Stacker.
    """

    primaryLabwareURI: str | None = Field(
        None, description='The URI of the primary labware.', title='Primarylabwareuri'
    )
    adapterLabwareURI: str | None = Field(
        None, description='The URI of the adapter labware.', title='Adapterlabwareuri'
    )
    lidLabwareURI: str | None = Field(
        None, description='The URI of the lid labware.', title='Lidlabwareuri'
    )
    count: int | None = Field(
        0, description='The number of labware current in the hopper.', title='Count'
    )
    maxCount: int | None = Field(
        0,
        description='The maximum number of labware allowed in the hopper.',
        title='Maxcount',
    )


class CommandType58(Enum):
    getNextTip = 'getNextTip'


class GetNextTipParams(BaseModel):
    """
    Payload needed to resolve the next available tip.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    labwareIds: list[str] = Field(
        ...,
        description='Labware ID(s) of tip racks to resolve next available tip(s) from Labware IDs will be resolved sequentially',
        title='Labwareids',
    )
    startingTipWell: str | None = Field(
        None,
        description="Name of starting tip rack 'well'. This only applies to the first tip rack in the list provided in labwareIDs",
        title='Startingtipwell',
    )


class CommandType60(Enum):
    getTipPresence = 'getTipPresence'


class GetTipPresenceParams(BaseModel):
    """
    Payload required for a GetTipPresence command.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class InstrumentType2(Enum):
    gripper = 'gripper'


class Ok3(Enum):
    """
    Whether this instrument is OK and ready to go
    """

    boolean_True = True


class ErrorType(Enum):
    gripperMovement = 'gripperMovement'


class WellBottomShape(Enum):
    flat = 'flat'
    u = 'u'
    v = 'v'


class GroupMetadata(BaseModel):
    displayName: str | None = Field(None, title='Displayname')
    displayCategory: DisplayCategory | None = None
    wellBottomShape: WellBottomShape | None = Field(None, title='Wellbottomshape')


class RobotModel(Enum):
    """
    Which model of Opentrons robot this is
    """

    OT_2_Standard = 'OT-2 Standard'
    OT_3_Standard = 'OT-3 Standard'


class HealthLinks(BaseModel):
    """
    Useful server links.
    """

    apiLog: str = Field(
        ...,
        deprecated=True,
        description='The path to the API logs endpoint. Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.',
        examples=['/logs/api.log'],
        title='Apilog',
    )
    serialLog: str = Field(
        ...,
        deprecated=True,
        description='The path to the motor control serial communication logs endpoint. Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.',
        examples=['/logs/serial.log'],
        title='Seriallog',
    )
    serverLog: str = Field(
        ...,
        deprecated=True,
        description='The path to the HTTP server logs endpoint. Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.',
        examples=['/logs/server.log'],
        title='Serverlog',
    )
    oddLog: str | None = Field(
        None,
        deprecated=True,
        description='The path to the on-device display app logs endpoint (only present on the Opentrons Flex). Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.',
        examples=['/logs/touchscreen.log'],
        title='Oddlog',
    )
    apiSpec: str = Field(
        ...,
        description='The path to the OpenAPI specification of the server',
        examples=['/openapi.json'],
        title='Apispec',
    )
    systemTime: str = Field(
        ...,
        description='The path to the system time endpoints',
        examples=['/system/time'],
        title='Systemtime',
    )


class HeaterShakerLabwareLatchStatus(Enum):
    """
    Heater-shaker labware latch status
    """

    opening = 'opening'
    idle_open = 'idle_open'
    closing = 'closing'
    idle_closed = 'idle_closed'
    idle_unknown = 'idle_unknown'
    unknown = 'unknown'


class ModuleType2(Enum):
    heaterShakerModuleType = 'heaterShakerModuleType'


class ModuleModel2(Enum):
    heaterShakerModuleV1 = 'heaterShakerModuleV1'


class HeaterShakerStatus(Enum):
    idle = 'idle'
    running = 'running'
    error = 'error'


class HeightVolumePair(BaseModel):
    height: float = Field(..., title='Height')
    volume: float = Field(..., title='Volume')


class HexColor(BaseModel):
    __root__: str = Field(
        ...,
        description='Hex color representation.',
        regex='^#(?:[0-9a-fA-F]{3,4}){1,2}$',
        title='HexColor',
    )


class CommandType62(Enum):
    home = 'home'


class HomeResult(BaseModel):
    """
    Result data from the execution of a Home command.
    """


class HomeTarget(Enum):
    pipette = 'pipette'
    robot = 'robot'


class HopperDoorState(Enum):
    closed = 'closed'
    opened = 'opened'


class CommandType64(Enum):
    identifyModule = 'identifyModule'


class IdentifyModuleResult(BaseModel):
    """
    Result data from an IdentifyModule command.
    """


class Kind(Enum):
    inStackerHopper = 'inStackerHopper'


class InStackerHopperLocation(BaseModel):
    """
    The location of a labware in a stacker hopper.
    """

    kind: Kind = Field('inStackerHopper', const=True, title='Kind')
    moduleId: str = Field(
        ...,
        description='The ID of the stacker in which this labware is.',
        title='Moduleid',
    )


class Kind1(Enum):
    inconsistent_pipette_offset = 'inconsistent-pipette-offset'


class CommandType66(Enum):
    absorbanceReader_initialize = 'absorbanceReader/initialize'


class MeasureMode(Enum):
    """
    Initialize single or multi measurement mode.
    """

    single = 'single'
    multi = 'multi'


class InitializeParams(BaseModel):
    """
    Input parameters to initialize an absorbance reading.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the absorbance reader.', title='Moduleid'
    )
    measureMode: MeasureMode = Field(
        ...,
        description='Initialize single or multi measurement mode.',
        title='Measuremode',
    )
    sampleWavelengths: list[int] = Field(
        ..., description='Sample wavelengths in nm.', title='Samplewavelengths'
    )
    referenceWavelength: int | None = Field(
        None,
        description='Optional reference wavelength in nm.',
        title='Referencewavelength',
    )


class InitializeResult(BaseModel):
    """
    Result data from initializing an aborbance reading.
    """


class InstrumentOffset(BaseModel):
    single: list[float] = Field(
        ...,
        deprecated=True,
        description='This will always be `[0, 0, 0]`. Use the `GET /calibration/pipette_offset` endpoint instead.',
        title='Single',
    )
    multi: list[float] = Field(
        ...,
        deprecated=True,
        description='This will always be `[0, 0, 0]`. Use the `GET /calibration/pipette_offset` endpoint instead.',
        title='Multi',
    )


class InstrumentOffsetVector(BaseModel):
    """
    Instrument Offset from home position to robot deck.
    """

    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')
    z: float = Field(..., title='Z')


class InstrumentSensorId(Enum):
    """
    Primary and secondary sensor ids.
    """

    primary = 'primary'
    secondary = 'secondary'
    both = 'both'


class InterfaceStatus(BaseModel):
    """
    Status for an interface
    """

    ipAddress: str | None = Field(
        None,
        description='The interface IP address with CIDR subnet appended (e.g. 10.0.0.1/24)',
        title='Ipaddress',
    )
    macAddress: str | None = Field(
        None,
        description="The MAC address of this interface (at least when connected to this network - it may change due to NetworkManager's privacy functionality when disconnected or connected to a different network)",
        title='Macaddress',
    )
    gatewayAddress: str | None = Field(
        None,
        description='The address of the configured gateway',
        title='Gatewayaddress',
    )
    state: str = Field(
        ...,
        description='The state of the connection. (i.e. connected, disconnected, connection failed)',
        title='State',
    )
    type: ConnectionType = Field(..., description='What kind of interface this is')


class Id6(Enum):
    InvalidDeckConfiguration = 'InvalidDeckConfiguration'


class InvalidDeckConfiguration(BaseModel):
    """
    Error details for when a client supplies an invalid deck configuration.
    """

    id: Id6 = Field('InvalidDeckConfiguration', const=True, title='Id')
    title: str | None = Field('Invalid Deck Configuration', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class JogPosition(BaseModel):
    vector: list[float] = Field(..., max_items=3, min_items=3, title='Vector')


class Id7(Enum):
    LabwareCalibrationEndpointsRemoved = 'LabwareCalibrationEndpointsRemoved'


class LabwareCalibrationEndpointsRemoved(BaseModel):
    """
    An error if you try to use the deprecated Labware Calibration endpoints.
    """

    id: Id7 = Field('LabwareCalibrationEndpointsRemoved', const=True, title='Id')
    title: str | None = Field('Labware Calibration Endpoints Removed', title='Title')
    detail: str | None = Field(
        'Use the `/runs` endpoints to manage labware offsets.', title='Detail'
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4002', title='Errorcode')


class SchemaVersion(IntEnum):
    integer_2 = 2


class FieldOtSharedSchema(Enum):
    field_labware_schemas_3 = '#/labware/schemas/3'


class SchemaVersion1(IntEnum):
    integer_3 = 3


class LabwareDefinitionSummary(BaseModel):
    """
    Summary of data about a created labware definition.
    """

    definitionUri: str = Field(
        ...,
        description="The definition's unique resource identifier in the run.",
        title='Definitionuri',
    )


class LabwareMovementStrategy(Enum):
    """
    Strategy to use for labware movement.
    """

    usingGripper = 'usingGripper'
    manualMoveWithPause = 'manualMoveWithPause'
    manualMoveWithoutPause = 'manualMoveWithoutPause'


class LabwareOffsetVector(BaseModel):
    """
    Offset, in deck coordinates from nominal to actual position.
    """

    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')
    z: float = Field(..., title='Z')


class LabwareRole(Enum):
    labware = 'labware'
    fixture = 'fixture'
    adapter = 'adapter'
    maintenance = 'maintenance'
    lid = 'lid'
    system = 'system'


class Id8(Enum):
    LastAnalysisPending = 'LastAnalysisPending'


class LastAnalysisPending(BaseModel):
    """
    An error returned when the most recent analysis of a protocol is still pending.
    """

    id: Id8 = Field('LastAnalysisPending', const=True, title='Id')
    title: str | None = Field('Last Analysis Still Pending.', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class LatchState(Enum):
    closed = 'closed'
    opened = 'opened'


class LegacyErrorResponse(BaseModel):
    """
    An error response with a human readable message.
    """

    message: str = Field(
        ...,
        description='A human-readable message describing the error.',
        title='Message',
    )
    errorCode: str = Field(
        ...,
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Links(BaseModel):
    restart: str | None = Field(
        None,
        description='A URI to POST to restart the robot. If this is present, it must be requested for any settings changes to take effect',
        title='Restart',
    )


class Liquid(BaseModel):
    """
    Payload required to create a liquid.
    """

    id: str = Field(..., title='Id')
    displayName: str = Field(..., title='Displayname')
    description: str = Field(..., title='Description')
    displayColor: HexColor | None = None


class Speed(BaseModel):
    __root__: int = Field(
        ...,
        description='Touch-tip speed, in millimeters per second.',
        gt=0,
        title='Speed',
    )


class Speed1(BaseModel):
    __root__: float = Field(
        ...,
        description='Touch-tip speed, in millimeters per second.',
        gt=0.0,
        title='Speed',
    )


class LiquidClassTouchTipParams(BaseModel):
    """
    Parameters for touch-tip.
    """

    class Config:
        extra = Extra.forbid

    z_offset: int | float = Field(
        ...,
        description='Offset from the top of the well for touch-tip, in millimeters.',
        title='Z Offset',
    )
    mm_from_edge: int | float = Field(
        ...,
        description='Offset away from the the well edge, in millimeters.',
        title='Mm From Edge',
    )
    speed: Speed | Speed1 = Field(
        ..., description='Touch-tip speed, in millimeters per second.', title='Speed'
    )


class VolumeOffset(Enum):
    """
    A volume of liquid, in µL, to offset the z-axis offset. When "operationVolume" is specified, this volume is pulled from the command volume parameter.
    """

    operationVolume = 'operationVolume'


class ErrorType1(Enum):
    liquidNotFound = 'liquidNotFound'


class LiquidNotFoundError(BaseModel):
    """
    Returned when no liquid is detected during the liquid probe process/move.

    After a failed probing, the pipette returns to the process start position.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(True, title='Isdefined')
    errorType: ErrorType1 = Field('liquidNotFound', const=True, title='Errortype')
    errorCode: str = Field(..., title='Errorcode')
    detail: str | None = Field('Liquid Not Found', title='Detail')
    errorInfo: dict[str, Any] = Field(
        ...,
        description='Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n',
        title='Errorinfo',
    )
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class CommandType68(Enum):
    liquidProbe = 'liquidProbe'


class CommandType70(Enum):
    loadLabware = 'loadLabware'


class LoadLabwareByDefinitionRequestData(BaseModel):
    tiprackDefinition: dict[str, Any] | None = Field(
        None,
        description='The tiprack definition to load into a user flow',
        title='Tiprackdefinition',
    )


class Location(Enum):
    """
    Location the labware should be loaded into.
    """

    offDeck = 'offDeck'


class Location1(Enum):
    """
    Location the labware should be loaded into.
    """

    systemLocation = 'systemLocation'


class CommandType72(Enum):
    loadLid = 'loadLid'


class Location2(Enum):
    """
    Labware the lid should be loaded onto.
    """

    offDeck = 'offDeck'


class Location3(Enum):
    """
    Labware the lid should be loaded onto.
    """

    systemLocation = 'systemLocation'


class CommandType74(Enum):
    loadLidStack = 'loadLidStack'


class Location4(Enum):
    """
    Location the lid stack should be loaded into.
    """

    offDeck = 'offDeck'


class Location5(Enum):
    """
    Location the lid stack should be loaded into.
    """

    systemLocation = 'systemLocation'


class Location6(Enum):
    """
    The Location that the stack of lid labware has been loaded.
    """

    offDeck = 'offDeck'


class Location7(Enum):
    """
    The Location that the stack of lid labware has been loaded.
    """

    systemLocation = 'systemLocation'


class CommandType76(Enum):
    loadLiquid = 'loadLiquid'


class CommandType77(Enum):
    loadLiquidClass = 'loadLiquidClass'


class LoadLiquidClassResult(BaseModel):
    """
    Result from execution of LoadLiquidClass command.
    """

    liquidClassId: str = Field(
        ...,
        description='The ID for the liquid class that was loaded, either the one you supplied or the one we generated.',
        title='Liquidclassid',
    )


class CommandType79(Enum):
    loadLiquid = 'loadLiquid'


class LiquidId(Enum):
    """
    Unique identifier of the liquid to load. If this is the sentinel value EMPTY, all values of volumeByWell must be 0.
    """

    EMPTY = 'EMPTY'


class LoadLiquidParams(BaseModel):
    """
    Payload required to load a liquid into a well.
    """

    liquidId: str | LiquidId = Field(
        ...,
        description='Unique identifier of the liquid to load. If this is the sentinel value EMPTY, all values of volumeByWell must be 0.',
        title='Liquidid',
    )
    labwareId: str = Field(
        ...,
        description='Unique identifier of labware to load liquid into.',
        title='Labwareid',
    )
    volumeByWell: dict[str, float] = Field(
        ...,
        description='Volume of liquid, in µL, loaded into each well by name, in this labware. If the liquid id is the sentinel value EMPTY, all volumes must be 0.',
        title='Volumebywell',
    )


class LoadLiquidResult(BaseModel):
    """
    Result data from the execution of a LoadLiquid command.
    """


class CommandType80(Enum):
    loadModule = 'loadModule'


class CommandType82(Enum):
    loadPipette = 'loadPipette'


class LoadPipetteResult(BaseModel):
    """
    Result data for executing a LoadPipette.
    """

    pipetteId: str = Field(
        ...,
        description='An ID to reference this pipette in subsequent commands.',
        title='Pipetteid',
    )


class Location8(Enum):
    """
    The labware's current location.
    """

    offDeck = 'offDeck'


class Location9(Enum):
    """
    The labware's current location.
    """

    systemLocation = 'systemLocation'


class SpringDirectionalForceAsParent(Enum):
    backLeftBottom = 'backLeftBottom'


class LogFormat(Enum):
    """
    Format to use for log records
    """

    text = 'text'
    json = 'json'


class LogIdentifier(Enum):
    """
    Identifier of the log
    """

    api_log = 'api.log'
    serial_log = 'serial.log'
    can_bus_log = 'can_bus.log'
    server_log = 'server.log'
    combined_api_server_log = 'combined_api_server.log'
    update_server_log = 'update_server.log'
    touchscreen_log = 'touchscreen.log'


class LogLevels(Enum):
    debug = 'debug'
    info = 'info'
    warning = 'warning'
    error = 'error'


class ModuleType3(Enum):
    magneticModuleType = 'magneticModuleType'


class ModuleModel3(Enum):
    magneticModuleV1 = 'magneticModuleV1'
    magneticModuleV2 = 'magneticModuleV2'


class MagneticStatus(Enum):
    engaged = 'engaged'
    disengaged = 'disengaged'


class MaintenancePosition(Enum):
    """
    Maintenance position options.
    """

    attachPlate = 'attachPlate'
    attachInstrument = 'attachInstrument'


class MatrixType(Enum):
    """
    The deck calibration matrix type
    """

    affine = 'affine'
    attitude = 'attitude'


class Volume(BaseModel):
    __root__: int = Field(
        ..., description='Volume used for mixing, in microliters.', gt=0, title='Volume'
    )


class Volume1(BaseModel):
    __root__: float = Field(
        ...,
        description='Volume used for mixing, in microliters.',
        gt=0.0,
        title='Volume',
    )


class MixParams(BaseModel):
    """
    Parameters for mix.
    """

    class Config:
        extra = Extra.forbid

    repetitions: int = Field(
        ...,
        description='Number of mixing repetitions. 0 is valid, but no mixing will occur.',
        ge=0,
        title='Repetitions',
    )
    volume: Volume | Volume1 = Field(
        ..., description='Volume used for mixing, in microliters.', title='Volume'
    )


class MixProperties(BaseModel):
    """
    Mixing properties.
    """

    class Config:
        extra = Extra.forbid

    enable: bool = Field(..., description='Whether mix is enabled.', title='Enable')
    params: MixParams | None = Field(
        None, description='Parameters for the mix function.', title='Params'
    )


class ModuleLocation(BaseModel):
    """
    The location of something placed atop a hardware module.
    """

    moduleId: str = Field(
        ...,
        description='The ID of a loaded module from a prior `loadModule` command.',
        title='Moduleid',
    )


class ModuleModelModel(Enum):
    """
    All available modules' models.
    """

    temperatureModuleV1 = 'temperatureModuleV1'
    temperatureModuleV2 = 'temperatureModuleV2'
    magneticModuleV1 = 'magneticModuleV1'
    magneticModuleV2 = 'magneticModuleV2'
    thermocyclerModuleV1 = 'thermocyclerModuleV1'
    thermocyclerModuleV2 = 'thermocyclerModuleV2'
    heaterShakerModuleV1 = 'heaterShakerModuleV1'
    magneticBlockV1 = 'magneticBlockV1'
    absorbanceReaderV1 = 'absorbanceReaderV1'
    flexStackerModuleV1 = 'flexStackerModuleV1'


class ModuleOffsetVector(BaseModel):
    """
    Offset, in deck coordinates, from nominal to actual position of labware on a module.
    """

    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')
    z: float = Field(..., title='Z')


class MotionTarget(Enum):
    """
    What should be moved. If mount, move the nominal position of the mount;
    if pipette, move the nozzle of the pipette
    """

    pipette = 'pipette'
    mount = 'mount'


class MotorAxis(Enum):
    """
    Motor axis on which to issue a home command.
    """

    x = 'x'
    y = 'y'
    leftZ = 'leftZ'
    rightZ = 'rightZ'
    leftPlunger = 'leftPlunger'
    rightPlunger = 'rightPlunger'
    extensionZ = 'extensionZ'
    extensionJaw = 'extensionJaw'
    axis96ChannelCam = 'axis96ChannelCam'


class MotorName(Enum):
    x = 'x'
    y = 'y'
    z_l = 'z_l'
    z_r = 'z_r'
    z_g = 'z_g'
    p_l = 'p_l'
    p_r = 'p_r'
    q = 'q'
    g = 'g'
    z = 'z'
    a = 'a'
    b = 'b'
    c = 'c'


class Mount(Enum):
    right = 'right'
    left = 'left'


class CommandType84(Enum):
    robot_moveAxesRelative = 'robot/moveAxesRelative'


class MoveAxesRelativeParams(BaseModel):
    """
    Payload required to move axes relative to position.
    """

    axis_map: dict[str, float] = Field(
        ...,
        description='A dictionary mapping axes to relative movements in mm.',
        title='Axis Map',
    )
    speed: float | None = Field(
        None,
        description='The max velocity to move the axes at. Will fall to hardware defaults if none provided.',
        title='Speed',
    )


class MoveAxesRelativeResult(BaseModel):
    """
    Result data from the execution of a MoveAxesRelative command.
    """

    position: dict[str, float] | None = Field(
        {
            'x': 0,
            'y': 0,
            'leftZ': 0,
            'rightZ': 0,
            'leftPlunger': 0,
            'rightPlunger': 0,
            'extensionZ': 0,
            'extensionJaw': 0,
            'axis96ChannelCam': 0,
        },
        description='The position of all axes on the robot. If no mount was provided, the last moved mount is used to determine the location.',
        title='Position',
    )


class CommandType86(Enum):
    robot_moveAxesTo = 'robot/moveAxesTo'


class MoveAxesToParams(BaseModel):
    """
    Payload required to move axes to absolute position.
    """

    axis_map: dict[str, float] = Field(
        ...,
        description='The specified axes to move to an absolute deck position with.',
        title='Axis Map',
    )
    critical_point: dict[str, float] | None = Field(
        None,
        description='The critical point to move the mount with.',
        title='Critical Point',
    )
    speed: float | None = Field(
        None,
        description='The max velocity to move the axes at. Will fall to hardware defaults if none provided.',
        title='Speed',
    )


class MoveAxesToResult(BaseModel):
    """
    Result data from the execution of a MoveAxesTo command.
    """

    position: dict[str, float] | None = Field(
        {
            'x': 0,
            'y': 0,
            'leftZ': 0,
            'rightZ': 0,
            'leftPlunger': 0,
            'rightPlunger': 0,
            'extensionZ': 0,
            'extensionJaw': 0,
            'axis96ChannelCam': 0,
        },
        description='The position of all axes on the robot. If no mount was provided, the last moved mount is used to determine the location.',
        title='Position',
    )


class CommandType88(Enum):
    moveLabware = 'moveLabware'


class NewLocation(Enum):
    """
    Where to move the labware.
    """

    offDeck = 'offDeck'


class NewLocation1(Enum):
    """
    Where to move the labware.
    """

    systemLocation = 'systemLocation'


class CommandType90(Enum):
    moveRelative = 'moveRelative'


class MoveRelativeResult(BaseModel):
    """
    Result data from the execution of a MoveRelative command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class CommandType92(Enum):
    robot_moveTo = 'robot/moveTo'


class CommandType93(Enum):
    moveToAddressableArea = 'moveToAddressableArea'


class CommandType95(Enum):
    moveToAddressableAreaForDropTip = 'moveToAddressableAreaForDropTip'


class MoveToAddressableAreaForDropTipParams(BaseModel):
    """
    Payload required to move a pipette to a specific addressable area.

    An *addressable area* is a space in the robot that may or may not be usable depending on how
    the robot's deck is configured. For example, if a Flex is configured with a waste chute, it will
    have additional addressable areas representing the opening of the waste chute, where tips and
    labware can be dropped.

    This moves the pipette so all of its nozzles are centered over the addressable area.
    If the pipette is currently configured with a partial tip layout, this centering is over all
    the pipette's physical nozzles, not just the nozzles that are active.

    The z-position will be chosen to put the bottom of the tips---or the bottom of the nozzles,
    if there are no tips---level with the top of the addressable area.

    When this command is executed, Protocol Engine will make sure the robot's deck is configured
    such that the requested addressable area actually exists. For example, if you request
    the addressable area B4, it will make sure the robot is set up with a B3/B4 staging area slot.
    If that's not the case, the command will fail.
    """

    minimumZHeight: float | None = Field(
        None,
        description="Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect.",
        title='Minimumzheight',
    )
    forceDirect: bool | None = Field(
        False,
        description="If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
        title='Forcedirect',
    )
    speed: float | None = Field(
        None,
        description='Override the travel speed in mm/s. This controls the straight linear speed of motion.',
        title='Speed',
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    addressableAreaName: str = Field(
        ...,
        description='The name of the addressable area that you want to use. Valid values are the `id`s of `addressableArea`s in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck).',
        title='Addressableareaname',
    )
    offset: AddressableOffsetVector | None = Field(
        default_factory=lambda: AddressableOffsetVector.parse_obj(
            {'x': 0, 'y': 0, 'z': 0}
        ),
        description="Relative offset of addressable area to move pipette's critical point.",
    )
    alternateDropLocation: bool | None = Field(
        None,
        description='Whether to alternate location where tip is dropped within the addressable area. If True, this command will ignore the offset provided and alternate between dropping tips at two predetermined locations inside the specified labware well. If False, the tip will be dropped at the top center of the area.',
        title='Alternatedroplocation',
    )
    ignoreTipConfiguration: bool | None = Field(
        None,
        description='Whether to utilize the critical point of the tip configuraiton when moving to an addressable area. If True, this command will ignore the tip configuration and use the center of the entire instrument as the critical point for movement. If False, this command will use the critical point provided by the current tip configuration.',
        title='Ignoretipconfiguration',
    )


class MoveToAddressableAreaForDropTipResult(BaseModel):
    """
    Result data from the execution of a MoveToAddressableAreaForDropTip command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class MoveToAddressableAreaParams(BaseModel):
    """
    Payload required to move a pipette to a specific addressable area.

    An *addressable area* is a space in the robot that may or may not be usable depending on how
    the robot's deck is configured. For example, if a Flex is configured with a waste chute, it will
    have additional addressable areas representing the opening of the waste chute, where tips and
    labware can be dropped.

    This moves the pipette so all of its nozzles are centered over the addressable area.
    If the pipette is currently configured with a partial tip layout, this centering is over all
    the pipette's physical nozzles, not just the nozzles that are active.

    The z-position will be chosen to put the bottom of the tips---or the bottom of the nozzles,
    if there are no tips---level with the top of the addressable area.

    When this command is executed, Protocol Engine will make sure the robot's deck is configured
    such that the requested addressable area actually exists. For example, if you request
    the addressable area B4, it will make sure the robot is set up with a B3/B4 staging area slot.
    If that's not the case, the command will fail.
    """

    minimumZHeight: float | None = Field(
        None,
        description="Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect.",
        title='Minimumzheight',
    )
    forceDirect: bool | None = Field(
        False,
        description="If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
        title='Forcedirect',
    )
    speed: float | None = Field(
        None,
        description='Override the travel speed in mm/s. This controls the straight linear speed of motion.',
        title='Speed',
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    addressableAreaName: str = Field(
        ...,
        description='The name of the addressable area that you want to use. Valid values are the `id`s of `addressableArea`s in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck).',
        title='Addressableareaname',
    )
    offset: AddressableOffsetVector | None = Field(
        default_factory=lambda: AddressableOffsetVector.parse_obj(
            {'x': 0, 'y': 0, 'z': 0}
        ),
        description="Relative offset of addressable area to move pipette's critical point.",
    )
    stayAtHighestPossibleZ: bool | None = Field(
        False,
        description='If `true`, the pipette will retract to its highest possible height and stay there instead of descending to the destination. `minimumZHeight` will be ignored.',
        title='Stayathighestpossiblez',
    )


class MoveToAddressableAreaResult(BaseModel):
    """
    Result data from the execution of a MoveToAddressableArea command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class CommandType97(Enum):
    moveToCoordinates = 'moveToCoordinates'


class MoveToCoordinatesParams(BaseModel):
    """
    Payload required to move a pipette to coordinates.
    """

    minimumZHeight: float | None = Field(
        None,
        description="Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect.",
        title='Minimumzheight',
    )
    forceDirect: bool | None = Field(
        False,
        description="If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
        title='Forcedirect',
    )
    speed: float | None = Field(
        None,
        description='Override the travel speed in mm/s. This controls the straight linear speed of motion.',
        title='Speed',
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    coordinates: DeckPoint = Field(
        ...,
        description="X, Y and Z coordinates in mm from deck's origin location (left-front-bottom corner of work space)",
    )


class MoveToCoordinatesResult(BaseModel):
    """
    Result data from the execution of a MoveToCoordinates command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class CommandType99(Enum):
    robot_moveTo = 'robot/moveTo'


class CommandType100(Enum):
    calibration_moveToMaintenancePosition = 'calibration/moveToMaintenancePosition'


class MoveToMaintenancePositionResult(BaseModel):
    """
    Result data from the execution of a MoveToMaintenancePosition command.
    """


class MoveToResult(BaseModel):
    """
    Result data from the execution of a MoveTo command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class CommandType102(Enum):
    moveToWell = 'moveToWell'


class MoveToWellResult(BaseModel):
    """
    Result data from the execution of a MoveToWell command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class MovementAxis(Enum):
    """
    Axis on which to issue a relative movement.
    """

    x = 'x'
    y = 'y'
    z = 'z'


class MultiBodyMeta(BaseModel):
    cursor: int = Field(
        ...,
        description="The index of the response's cursor in the overall collection the response represents.",
        title='Cursor',
    )
    totalLength: int = Field(
        ...,
        description='Total number of items in the overall collection.',
        title='Totallength',
    )


class FlowRateByVolumeItem51(BaseModel):
    __root__: int = Field(..., ge=0)


class FlowRateByVolumeItem52(BaseModel):
    __root__: float = Field(..., ge=0.0)


class FlowRateByVolumeItem53(BaseModel):
    __root__: int = Field(..., ge=0)


class FlowRateByVolumeItem54(BaseModel):
    __root__: float = Field(..., ge=0.0)


class FlowRateByVolumeItem5(BaseModel):
    __root__: tuple[
        FlowRateByVolumeItem51 | FlowRateByVolumeItem52,
        FlowRateByVolumeItem53 | FlowRateByVolumeItem54,
    ] = Field(...)  # Removed min_items=2, max_items=2


class CorrectionByVolumeItem31(BaseModel):
    __root__: int = Field(..., ge=0)


class CorrectionByVolumeItem32(BaseModel):
    __root__: float = Field(..., ge=0.0)


class CorrectionByVolumeItem3(BaseModel):
    __root__: tuple[
        CorrectionByVolumeItem31 | CorrectionByVolumeItem32, int | float
    ] = Field(...)  # Removed min_items=2, max_items=2


class ConditioningByVolumeItem1(BaseModel):
    __root__: int = Field(..., ge=0)


class ConditioningByVolumeItem2(BaseModel):
    __root__: float = Field(..., ge=0.0)


class ConditioningByVolumeItem3(BaseModel):
    __root__: int = Field(..., ge=0)


class ConditioningByVolumeItem4(BaseModel):
    __root__: float = Field(..., ge=0.0)


class ConditioningByVolumeItem(BaseModel):
    __root__: tuple[
        ConditioningByVolumeItem1 | ConditioningByVolumeItem2,
        ConditioningByVolumeItem3 | ConditioningByVolumeItem4,
    ] = Field(...)  # Removed min_items=2, max_items=2


class DisposalByVolumeItem1(BaseModel):
    __root__: int = Field(..., ge=0)


class DisposalByVolumeItem2(BaseModel):
    __root__: float = Field(..., ge=0.0)


class DisposalByVolumeItem3(BaseModel):
    __root__: int = Field(..., ge=0)


class DisposalByVolumeItem4(BaseModel):
    __root__: float = Field(..., ge=0.0)


class DisposalByVolumeItem(BaseModel):
    __root__: tuple[
        DisposalByVolumeItem1 | DisposalByVolumeItem2,
        DisposalByVolumeItem3 | DisposalByVolumeItem4,
    ] = Field(...)  # Removed min_items=2, max_items=2


class Id9(Enum):
    MultipleDataFileSources = 'MultipleDataFileSources'


class MultipleDataFileSources(BaseModel):
    """
    An error returned when multiple data file sources are specified in one request.
    """

    id: Id9 = Field('MultipleDataFileSources', const=True, title='Id')
    title: str | None = Field('Multiple sources found for data files', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class NetworkingSecurityType(Enum):
    """
    Top-level type of network security
    """

    wpa_eap = 'wpa-eap'
    wpa_psk = 'wpa-psk'
    none = 'none'
    unsupported = 'unsupported'


# class NetworkingStatus(BaseModel):
#     status: ConnectivityStatus | None = Field(
#         'none', description='Overall connectivity of the robot'
#     )
#     interfaces: dict[str, InterfaceStatus] | None = Field(
#         default_factory=lambda: InterfaceStatus.parse_obj({}),
#         description='Per-interface networking status. Properties are named for network interfaces',
#         title='Interfaces',
#     )

class NetworkingStatus(BaseModel):
    status: ConnectivityStatus | None = Field(
        default=ConnectivityStatus.none,
        description='Overall connectivity of the robot'
    )
    interfaces: dict[str, InterfaceStatus] | None = Field(
        default_factory=dict, 
        description='Per-interface networking status. Properties are named for network interfaces',
        title='Interfaces',
    )

class NextStepLink(BaseModel):
    url: str = Field(..., title='Url')
    params: dict[str, Any] = Field(..., title='Params')


class NextSteps(BaseModel):
    links: dict[str, NextStepLink] = Field(..., title='Links')


class NextTipInfo(BaseModel):
    """
    Next available tip labware and well name data.
    """

    labwareId: str = Field(
        ...,
        description='The labware ID of the tip rack where the next available tip(s) are located.',
        title='Labwareid',
    )
    tipStartingWell: str = Field(
        ...,
        description='The (starting) well name of the next available tip(s).',
        title='Tipstartingwell',
    )


class Id10(Enum):
    NoCurrentRunFound = 'NoCurrentRunFound'


class NoCurrentRunFound(BaseModel):
    """
    An error if there is no current run to fetch.
    """

    id: Id10 = Field('NoCurrentRunFound', const=True, title='Id')
    title: str | None = Field('No current run found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id11(Enum):
    NoDataFileSourceProvided = 'NoDataFileSourceProvided'


class NoDataFileSourceProvided(BaseModel):
    """
    An error returned when no data file sources are specified in the request.
    """

    id: Id11 = Field('NoDataFileSourceProvided', const=True, title='Id')
    title: str | None = Field('No data file source provided', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id12(Enum):
    NoOngoingUpdate = 'NoOngoingUpdate'


class NoOngoingUpdate(BaseModel):
    """
    An error if there is no ongoing update for a subsystem.
    """

    id: Id12 = Field('NoOngoingUpdate', const=True, title='Id')
    title: str | None = Field('No Ongoing Update', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class NoTipReason(Enum):
    """
    The cause of no tip being available for a pipette and tip rack(s).
    """

    noAvailableTips = 'noAvailableTips'
    startingTipWithPartial = 'startingTipWithPartial'
    incompatibleConfiguration = 'incompatibleConfiguration'


class Id13(Enum):
    NoUpdateAvailable = 'NoUpdateAvailable'


class NoUpdateAvailable(BaseModel):
    """
    An error if no update is available for the specified mount.
    """

    id: Id13 = Field('NoUpdateAvailable', const=True, title='Id')
    title: str | None = Field('No Update Available', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Kind2(Enum):
    notOnDeck = 'notOnDeck'


class LogicalLocationName(Enum):
    offDeck = 'offDeck'
    systemLocation = 'systemLocation'


class NotOnDeckLocationSequenceComponent(BaseModel):
    """
    Labware on a system location.
    """

    kind: Kind2 = Field('notOnDeck', const=True, title='Kind')
    logicalLocationName: LogicalLocationName = Field(..., title='Logicallocationname')


class Id14(Enum):
    NotSupportedOnOT2 = 'NotSupportedOnOT2'


class NotSupportedOnOT2(BaseModel):
    """
    An error returned when an operation is not supported on an OT2.
    """

    id: Id14 = Field('NotSupportedOnOT2', const=True, title='Id')
    title: str | None = Field('Not Supported On OT-2', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class NozzleLayoutConfig(Enum):
    """
    Possible valid nozzle configurations.
    """

    column = 'column'
    row = 'row'
    single = 'single'
    full = 'full'
    subrect = 'subrect'


class Type3(Enum):
    """
    String specifying whether the number is an int or float type.
    """

    int = 'int'
    float = 'float'


class NumberParameter(BaseModel):
    """
    An integer parameter defined in a protocol.
    """

    displayName: str = Field(
        ..., description='Display string for the parameter.', title='Displayname'
    )
    variableName: str = Field(
        ..., description='Python variable name of the parameter.', title='Variablename'
    )
    description: str | None = Field(
        None, description='Detailed description of the parameter.', title='Description'
    )
    suffix: str | None = Field(
        None,
        description='Units (like mL, mm/sec, etc) or a custom suffix for the parameter.',
        title='Suffix',
    )
    type: Type3 = Field(
        ...,
        description='String specifying whether the number is an int or float type.',
        title='Type',
    )
    min: int | float = Field(
        ...,
        description='Minimum value that the number param is allowed to have.',
        title='Min',
    )
    max: int | float = Field(
        ...,
        description='Maximum value that the number param is allowed to have.',
        title='Max',
    )
    value: int | float = Field(
        ...,
        description='The value assigned to the parameter; if not supplied by the client, will be assigned the default value.',
        title='Value',
    )
    default: int | float = Field(
        ...,
        description='Default value of the parameter, to be used when there is no client-specified value.',
        title='Default',
    )


class OffsetData(BaseModel):
    value: list[float] = Field(
        ...,
        description='A labware offset vector in deck coordinates (x, y, z)',
        title='Value',
    )
    lastModified: datetime = Field(
        ..., description='When this calibration was last modified', title='Lastmodified'
    )


class Kind3(Enum):
    onAddressableArea = 'onAddressableArea'


class OnAddressableAreaLocationSequenceComponent(BaseModel):
    """
    Labware on an addressable area.
    """

    kind: Kind3 = Field('onAddressableArea', const=True, title='Kind')
    addressableAreaName: str = Field(..., title='Addressableareaname')


class OnAddressableAreaOffsetLocationSequenceComponent(BaseModel):
    """
    Offset location sequence component for a labware on an addressable area.
    """

    kind: Literal['onAddressableArea'] = Field(..., const=True, title='Kind')
    addressableAreaName: str = Field(
        ...,
        description='The ID of an addressable area that a labware or module can be loaded onto, such as (on the OT-2) "2" or (on the Flex) "C1". \n\nOn the Flex, this field must be correct for the kind of entity it hosts. For instance, if the prior entity in the location sequence is an `OnModuleOffsetLocationSequenceComponent(moduleModel=temperatureModuleV2)`, this entity must be temperatureModuleV2NN where NN is the slot name in which the module resides. ',
        title='Addressableareaname',
    )


class Kind5(Enum):
    onCutoutFixture = 'onCutoutFixture'


class OnCutoutFixtureLocationSequenceComponent(BaseModel):
    """
    Something on a deck cutout fixture.
    """

    kind: Kind5 = Field('onCutoutFixture', const=True, title='Kind')
    possibleCutoutFixtureIds: list[str] = Field(..., title='Possiblecutoutfixtureids')
    cutoutId: str = Field(..., title='Cutoutid')


class OnLabwareLocation(BaseModel):
    """
    The location of something placed atop another labware.
    """

    labwareId: str = Field(
        ...,
        description='The ID of a loaded Labware from a prior `loadLabware` command.',
        title='Labwareid',
    )


class Kind6(Enum):
    onLabware = 'onLabware'


class OnLabwareLocationSequenceComponent(BaseModel):
    """
    Labware on another labware.
    """

    kind: Kind6 = Field('onLabware', const=True, title='Kind')
    labwareId: str = Field(..., title='Labwareid')
    lidId: str | None = Field(None, title='Lidid')


class OnLabwareOffsetLocationSequenceComponent(BaseModel):
    """
    Offset location sequence component for a labware on another labware.
    """

    kind: Literal['onLabware'] = Field(..., const=True, title='Kind')
    labwareUri: str = Field(
        ...,
        description='The definition URI of another labware, probably an adapter, that the labware will be loaded onto.',
        title='Labwareuri',
    )


class Kind8(Enum):
    onModule = 'onModule'


class OnModuleLocationSequenceComponent(BaseModel):
    """
    Labware on a module.
    """

    kind: Kind8 = Field('onModule', const=True, title='Kind')
    moduleId: str = Field(..., title='Moduleid')


class OnModuleOffsetLocationSequenceComponent(BaseModel):
    """
    Offset location sequence component for a labware on a module.
    """

    kind: Literal['onModule'] = Field(..., const=True, title='Kind')
    moduleModel: ModuleModelModel = Field(
        ..., description='The model of a module that a labware can be loaded on to.'
    )


class CommandType104(Enum):
    robot_openGripperJaw = 'robot/openGripperJaw'


class OpenGripperJawParams(BaseModel):
    """
    Payload required to release a gripper.
    """


class OpenGripperJawResult(BaseModel):
    """
    Result data from the execution of a openGripperJaw command.
    """


class CommandType106(Enum):
    heaterShaker_openLabwareLatch = 'heaterShaker/openLabwareLatch'


class OpenLabwareLatchParams(BaseModel):
    """
    Input parameters to open a Heater-Shaker Module's labware latch.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )


class OpenLabwareLatchResult(BaseModel):
    """
    Result data from opening a Heater-Shaker's labware latch.
    """

    pipetteRetracted: bool = Field(
        ...,
        description='Whether this command automatically retracted the pipettes before opening the latch, to avoid a potential collision.',
        title='Pipetteretracted',
    )


class OpentronsFlexTipRackLidAsChildFeature(BaseModel):
    matingZ: float = Field(..., title='Matingz')


class OpentronsFlexTipRackLidAsParentFeature(BaseModel):
    matingZ: float = Field(..., title='Matingz')


class ErrorType2(Enum):
    overpressure = 'overpressure'


class OverpressureError(BaseModel):
    """
    Returned when sensors detect an overpressure error while moving liquid.

    The pipette plunger motion is stopped at the point of the error.

    The next thing to move the plunger must account for the robot not having a valid
    estimate of its position. It should be a `home`, `unsafe/updatePositionEstimators`,
    `unsafe/dropTipInPlace`, or `unsafe/blowOutInPlace`.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(True, title='Isdefined')
    errorType: ErrorType2 = Field('overpressure', const=True, title='Errortype')
    errorCode: str = Field(..., title='Errorcode')
    detail: str | None = Field('Pipette Overpressure', title='Detail')
    errorInfo: ErrorLocationInfo
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class Format(Enum):
    field_96Standard = '96Standard'
    field_384Standard = '384Standard'
    trough = 'trough'
    irregular = 'irregular'
    trash = 'trash'


class TipLength(BaseModel):
    __root__: int = Field(..., ge=0, title='Tiplength')


class TipLength1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Tiplength')


class TipOverlap(BaseModel):
    __root__: int = Field(..., ge=0, title='Tipoverlap')


class TipOverlap1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Tipoverlap')


class MagneticModuleEngageHeight(BaseModel):
    __root__: int = Field(..., ge=0, title='Magneticmoduleengageheight')


class MagneticModuleEngageHeight1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Magneticmoduleengageheight')


class Parameters2(BaseModel):
    format: Format = Field(..., title='Format')
    quirks: list[str] | None = Field(None, title='Quirks')
    isTiprack: bool = Field(..., title='Istiprack')
    tipLength: TipLength | TipLength1 | None = Field(None, title='Tiplength')
    tipOverlap: TipOverlap | TipOverlap1 | None = Field(None, title='Tipoverlap')
    loadName: str = Field(..., regex='^[a-z0-9._]+$', title='Loadname')
    isMagneticModuleCompatible: bool = Field(..., title='Ismagneticmodulecompatible')
    isDeckSlotCompatible: bool | None = Field(None, title='Isdeckslotcompatible')
    magneticModuleEngageHeight: (
        MagneticModuleEngageHeight | MagneticModuleEngageHeight1 | None
    ) = Field(None, title='Magneticmoduleengageheight')


class TipLength2(BaseModel):
    __root__: int = Field(..., ge=0, title='Tiplength')


class TipLength3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Tiplength')


class TipOverlap2(BaseModel):
    __root__: int = Field(..., ge=0, title='Tipoverlap')


class TipOverlap3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Tipoverlap')


class MagneticModuleEngageHeight2(BaseModel):
    __root__: int = Field(..., ge=0, title='Magneticmoduleengageheight')


class MagneticModuleEngageHeight3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Magneticmoduleengageheight')


class Parameters3(BaseModel):
    format: Format = Field(..., title='Format')
    quirks: list[str] | None = Field(None, title='Quirks')
    isTiprack: bool = Field(..., title='Istiprack')
    tipLength: TipLength2 | TipLength3 | None = Field(None, title='Tiplength')
    tipOverlap: TipOverlap2 | TipOverlap3 | None = Field(None, title='Tipoverlap')
    loadName: str = Field(..., regex='^[a-z0-9._]+$', title='Loadname')
    isMagneticModuleCompatible: bool = Field(..., title='Ismagneticmodulecompatible')
    isDeckSlotCompatible: bool | None = Field(None, title='Isdeckslotcompatible')
    magneticModuleEngageHeight: (
        MagneticModuleEngageHeight2 | MagneticModuleEngageHeight3 | None
    ) = Field(None, title='Magneticmoduleengageheight')


class Status2(Enum):
    """
    Status marking the analysis as pending
    """

    pending = 'pending'


class CommandType108(Enum):
    pickUpTip = 'pickUpTip'


class PickUpTipResult(BaseModel):
    """
    Result data from the execution of a PickUpTip.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    tipVolume: float | None = Field(
        0,
        description='Maximum volume of liquid that the picked up tip can hold, in µL.',
        ge=0.0,
        title='Tipvolume',
    )
    tipLength: float | None = Field(
        0, description='The length of the tip in mm.', ge=0.0, title='Tiplength'
    )
    tipDiameter: float | None = Field(
        0, description='The diameter of the tip in mm.', ge=0.0, title='Tipdiameter'
    )


class PickUpTipWellOrigin(Enum):
    """
    The origin of a PickUpTipWellLocation offset.

    Props:
        TOP: the top-center of the well
        BOTTOM: the bottom-center of the well
        CENTER: the middle-center of the well
    """

    top = 'top'
    bottom = 'bottom'
    center_ = 'center'


class InstrumentType3(Enum):
    pipette = 'pipette'


class InstrumentName(Enum):
    p10_single = 'p10_single'
    p10_multi = 'p10_multi'
    p20_single_gen2 = 'p20_single_gen2'
    p20_multi_gen2 = 'p20_multi_gen2'
    p50_single = 'p50_single'
    p50_multi = 'p50_multi'
    p50_single_flex = 'p50_single_flex'
    p50_multi_flex = 'p50_multi_flex'
    p300_single = 'p300_single'
    p300_multi = 'p300_multi'
    p300_single_gen2 = 'p300_single_gen2'
    p300_multi_gen2 = 'p300_multi_gen2'
    p1000_single = 'p1000_single'
    p1000_single_gen2 = 'p1000_single_gen2'
    p1000_single_flex = 'p1000_single_flex'
    p1000_multi_flex = 'p1000_multi_flex'
    p1000_multi_em_flex = 'p1000_multi_em_flex'
    p1000_96 = 'p1000_96'
    p200_96 = 'p200_96'


class Channels(IntEnum):
    """
    Number of pipette channels.
    """

    integer_1 = 1
    integer_8 = 8
    integer_96 = 96


class PipetteNameType(Enum):
    """
    Pipette load name values.
    """

    p10_single = 'p10_single'
    p10_multi = 'p10_multi'
    p20_single_gen2 = 'p20_single_gen2'
    p20_multi_gen2 = 'p20_multi_gen2'
    p50_single = 'p50_single'
    p50_multi = 'p50_multi'
    p50_single_flex = 'p50_single_flex'
    p50_multi_flex = 'p50_multi_flex'
    p300_single = 'p300_single'
    p300_multi = 'p300_multi'
    p300_single_gen2 = 'p300_single_gen2'
    p300_multi_gen2 = 'p300_multi_gen2'
    p1000_single = 'p1000_single'
    p1000_single_gen2 = 'p1000_single_gen2'
    p1000_single_flex = 'p1000_single_flex'
    p1000_multi_flex = 'p1000_multi_flex'
    p1000_multi_em_flex = 'p1000_multi_em_flex'
    p1000_96 = 'p1000_96'
    p200_96 = 'p200_96'


class SessionType4(Enum):
    pipetteOffsetCalibration = 'pipetteOffsetCalibration'


class Status3(Enum):
    """
    The status of this calibration type,dependent on the calibration beinginside or outside of the threshold
    """

    IN_THRESHOLD = 'IN_THRESHOLD'
    OUTSIDE_THRESHOLD = 'OUTSIDE_THRESHOLD'


class PipetteOffsetComparisonMap(BaseModel):
    status: Status3 = Field(
        ...,
        description='The status of this calibration type,dependent on the calibration beinginside or outside of the threshold',
        title='Status',
    )
    comparingHeight: ComparisonStatus | None = Field(
        None, description='height validation step'
    )
    comparingPointOne: ComparisonStatus | None = Field(
        None, description='point 1 validation step'
    )


class PipetteSettingsFieldType(Enum):
    """
    The type of the property
    """

    float = 'float'
    int = 'int'


class PipetteSettingsInfo(BaseModel):
    """
    Metadata about this pipette
    """

    name: str = Field(
        ..., description='A pipette name (e.g. "p300_single")', title='Name'
    )
    model: str = Field(
        ...,
        description='The exact pipette model (e.g. "p300_single_v1.5")',
        title='Model',
    )


class PipetteState(BaseModel):
    """
    State from an attached pipette.
    """

    tip_detected: bool | None = Field(
        None,
        description='Physical state of the tip photointerrupter on the Flex. Null for OT-2',
        title='Tip Detected',
    )


class PipetteUpdateField(BaseModel):
    value: bool | float | None = Field(
        ...,
        description='Must be a boolean if this is a quirk. The format if this is not a quirk. Must be between max and min for this property. Null means reset.',
        title='Value',
    )


class PlatformState(Enum):
    unknown = 'unknown'
    extended = 'extended'
    retracted = 'retracted'
    missing = 'missing'


class Point(BaseModel):
    __root__: list[Any] = Field(..., max_items=3)


class PositionReference(Enum):
    """
    Positional reference for liquid handling operations.
    """

    well_bottom = 'well-bottom'
    well_top = 'well-top'
    well_center = 'well-center'
    liquid_meniscus = 'liquid-meniscus'


class Id15(Enum):
    PreSerializedCommandsNotAvailable = 'PreSerializedCommandsNotAvailable'


class PreSerializedCommandsNotAvailable(BaseModel):
    """
    An error if one tries to fetch pre-serialized commands before they are written to the database.
    """

    id: Id15 = Field('PreSerializedCommandsNotAvailable', const=True, title='Id')
    title: str | None = Field('Pre-Serialized commands not available.', title='Title')
    detail: str | None = Field(
        'Pre-serialized commands are only available once a run has finished running.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class CommandType110(Enum):
    prepareToAspirate = 'prepareToAspirate'


class PrepareToAspirateParams(BaseModel):
    """
    Parameters required to prepare a specific pipette for aspiration.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class PrepareToAspirateResult(BaseModel):
    """
    Result data from execution of an PrepareToAspirate command.
    """


class CommandType112(Enum):
    pressureDispense = 'pressureDispense'


class PressureDispenseResult(BaseModel):
    """
    Result data from the execution of a PressureDispense command.
    """

    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class ProfileStep(BaseModel):
    """
    An individual step in a Thermocycler extended profile.
    """

    celsius: float = Field(
        ..., description='Target temperature in °C.', title='Celsius'
    )
    holdSeconds: float = Field(
        ...,
        description='Time to hold target temperature in seconds.',
        title='Holdseconds',
    )


class RobotType1(Enum):
    """
    The type of robot that this protocol can run on.
    """

    OT_2_Standard = 'OT-2 Standard'
    OT_3_Standard = 'OT-3 Standard'


class ProtocolFileRole(Enum):
    """
    The purpose of a given file in a protocol.

    Args:
        MAIN: The protocol's main file. In a JSON protocol, this is will
            be the JSON file. In a Python protocol, this is the file
            that exports the main `run` method.
        LABWARE: A labware definition file, loadable by a
            Python file in the same protocol.
        DATA: An arbitrary text or csv file for usage in `bundled_data`
            for a Python protool
    """

    main = 'main'
    labware = 'labware'
    data = 'data'


class Id16(Enum):
    ProtocolFilesInvalid = 'ProtocolFilesInvalid'


class ProtocolFilesInvalid(BaseModel):
    """
    An error returned when an uploaded protocol files are invalid.
    """

    id: Id16 = Field('ProtocolFilesInvalid', const=True, title='Id')
    title: str | None = Field('Protocol File(s) Invalid', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class ProtocolKind(Enum):
    """
    Kind of protocol, standard or quick-transfer.
    """

    standard = 'standard'
    quick_transfer = 'quick-transfer'


class Id17(Enum):
    ProtocolNotFound = 'ProtocolNotFound'


class ProtocolNotFound(BaseModel):
    """
    An error returned when a given protocol cannot be found.
    """

    id: Id17 = Field('ProtocolNotFound', const=True, title='Id')
    title: str | None = Field('Protocol Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id18(Enum):
    ProtocolRobotTypeMismatch = 'ProtocolRobotTypeMismatch'


class ProtocolRobotTypeMismatch(BaseModel):
    """
    An error returned when an uploaded protocol is for a different type of robot.

    For example, if the protocol is for an OT-3, but this server is running on an OT-2.
    """

    id: Id18 = Field('ProtocolRobotTypeMismatch', const=True, title='Id')
    title: str | None = Field('Protocol For Different Robot Type', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id19(Enum):
    ProtocolRunIsActive = 'ProtocolRunIsActive'


class ProtocolRunIsActive(BaseModel):
    """
    An error if one tries to create a maintenance run while a protocol run is active.
    """

    id: Id19 = Field('ProtocolRunIsActive', const=True, title='Id')
    title: str | None = Field('Protocol Run Is Active', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class ProtocolType(Enum):
    """
    Type of protocol, JSON or Python.
    """

    json = 'json'
    python = 'python'


class Id20(Enum):
    ProtocolUsedByRun = 'ProtocolUsedByRun'


class ProtocolUsedByRun(BaseModel):
    """
    An error returned when a protocol is used by a run and cannot be deleted.
    """

    id: Id20 = Field('ProtocolUsedByRun', const=True, title='Id')
    title: str | None = Field('Protocol Used by Run', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Style2(Enum):
    QUADRANT = 'QUADRANT'


class QuadrantNozzleLayoutConfiguration(BaseModel):
    """
    Information required for nozzle configurations of type QUADRANT.
    """

    style: Style2 = Field('QUADRANT', const=True, title='Style')
    primaryNozzle: PrimaryNozzle = Field(
        ...,
        description='The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle.',
        title='Primarynozzle',
    )
    frontRightNozzle: str = Field(
        ...,
        description='The front right nozzle in your configuration.',
        regex='[A-Z]\\d{1,2}',
        title='Frontrightnozzle',
    )
    backLeftNozzle: str = Field(
        ...,
        description='The back left nozzle in your configuration.',
        regex='[A-Z]\\d{1,2}',
        title='Backleftnozzle',
    )


class ReactionIfMatch(Enum):
    """
    How to handle a matching error.

    * `"failRun"`: Fail the run.

    * `"waitForRecovery"`: Enter interactive error recovery mode. You can then
      perform error recovery with `POST /runs/{id}/commands` and exit error
      recovery mode with `POST /runs/{id}/actions`.

    * `"assumeFalsePositiveAndContinue"`: Continue the run without interruption, acting
      as if the error was a false positive.

      This is equivalent to doing `"waitForRecovery"`
      and then sending `actionType: "resume-from-recovery-assuming-false-positive"`
      to `POST /runs/{id}/actions`, except this requires no ongoing intervention from
      the client.

    * `"ignoreAndContinue"`: Continue the run without interruption, accepting whatever
      state the error left the robot in.

      This is equivalent to doing `"waitForRecovery"`
      and then sending `actionType: "resume-from-recovery"` to `POST /runs/{id}/actions`,
      except this requires no ongoing intervention from the client.

      This is probably not useful very often because it's likely to cause downstream
      errors—imagine trying an `aspirate` command after a failed `pickUpTip` command.
      This is provided for symmetry.
    """

    failRun = 'failRun'
    waitForRecovery = 'waitForRecovery'
    assumeFalsePositiveAndContinue = 'assumeFalsePositiveAndContinue'
    ignoreAndContinue = 'ignoreAndContinue'


class CommandType114(Enum):
    absorbanceReader_read = 'absorbanceReader/read'


class ReadAbsorbanceParams(BaseModel):
    """
    Input parameters for an absorbance reading.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Absorbance Reader.', title='Moduleid'
    )
    fileName: str | None = Field(
        None,
        description='Optional file name to use when storing the results of a measurement.',
        title='Filename',
    )


class ReadAbsorbanceResult(BaseModel):
    """
    Result data from running an aborbance reading, returned as a dictionary map of wavelengths containing a map of values by well name (eg. {450: {"A1": 0.0, ...}}).
    """

    data: dict[str, dict[str, float]] | None = Field(
        ..., description='Absorbance data points per wavelength.', title='Data'
    )
    fileIds: list[str] | None = Field(
        ...,
        description='List of file IDs for files output as a result of a Read action.',
        title='Fileids',
    )


class Shape4(Enum):
    rectangular = 'rectangular'


class XDimension2(BaseModel):
    __root__: int = Field(..., ge=0, title='Xdimension')


class XDimension3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Xdimension')


class YDimension2(BaseModel):
    __root__: int = Field(..., ge=0, title='Ydimension')


class YDimension3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Ydimension')


class Depth4(BaseModel):
    __root__: int = Field(..., ge=0, title='Depth')


class Depth5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Depth')


class TotalLiquidVolume4(BaseModel):
    __root__: int = Field(..., ge=0, title='Totalliquidvolume')


class TotalLiquidVolume5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Totalliquidvolume')


class X4(BaseModel):
    __root__: int = Field(..., ge=0, title='X')


class X5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='X')


class Z4(BaseModel):
    __root__: int = Field(..., ge=0, title='Z')


class Z5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Z')


class Y4(BaseModel):
    __root__: int = Field(..., ge=0, title='Y')


class Y5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Y')


class RectangularWellDefinition2(BaseModel):
    class Config:
        extra = Extra.allow

    shape: Shape4 = Field('rectangular', const=True, title='Shape')
    xDimension: XDimension2 | XDimension3 = Field(..., title='Xdimension')
    yDimension: YDimension2 | YDimension3 = Field(..., title='Ydimension')
    depth: Depth4 | Depth5 = Field(..., title='Depth')
    totalLiquidVolume: TotalLiquidVolume4 | TotalLiquidVolume5 = Field(
        ..., title='Totalliquidvolume'
    )
    x: X4 | X5 = Field(..., title='X')
    z: Z4 | Z5 = Field(..., title='Z')
    geometryDefinitionId: str | None = Field(None, title='Geometrydefinitionid')
    y: Y4 | Y5 = Field(..., title='Y')


class XDimension4(BaseModel):
    __root__: int = Field(..., ge=0, title='Xdimension')


class XDimension5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Xdimension')


class YDimension4(BaseModel):
    __root__: int = Field(..., ge=0, title='Ydimension')


class YDimension5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Ydimension')


class Depth6(BaseModel):
    __root__: int = Field(..., ge=0, title='Depth')


class Depth7(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Depth')


class TotalLiquidVolume6(BaseModel):
    __root__: int = Field(..., ge=0, title='Totalliquidvolume')


class TotalLiquidVolume7(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Totalliquidvolume')


class X6(BaseModel):
    __root__: int = Field(..., ge=0, title='X')


class X7(BaseModel):
    __root__: float = Field(..., ge=0.0, title='X')


class Z6(BaseModel):
    __root__: int = Field(..., ge=0, title='Z')


class Z7(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Z')


class Y6(BaseModel):
    __root__: int = Field(..., le=0, title='Y')


class Y7(BaseModel):
    __root__: float = Field(..., le=0.0, title='Y')


class RectangularWellDefinition3(BaseModel):
    class Config:
        extra = Extra.allow

    shape: Shape4 = Field('rectangular', const=True, title='Shape')
    xDimension: XDimension4 | XDimension5 = Field(..., title='Xdimension')
    yDimension: YDimension4 | YDimension5 = Field(..., title='Ydimension')
    depth: Depth6 | Depth7 = Field(..., title='Depth')
    totalLiquidVolume: TotalLiquidVolume6 | TotalLiquidVolume7 = Field(
        ..., title='Totalliquidvolume'
    )
    x: X6 | X7 = Field(..., title='X')
    z: Z6 | Z7 = Field(..., title='Z')
    geometryDefinitionId: str | None = Field(None, title='Geometrydefinitionid')
    y: Y6 | Y7 = Field(..., title='Y')


class CommandType116(Enum):
    reloadLabware = 'reloadLabware'


class ReloadLabwareParams(BaseModel):
    """
    Payload required to load a labware into a slot.
    """

    labwareId: str = Field(
        ...,
        description='The already-loaded labware instance to update.',
        title='Labwareid',
    )


class ReloadLabwareResult(BaseModel):
    """
    Result data from the execution of a LoadLabware command.
    """

    labwareId: str = Field(..., description='The id of the labware.', title='Labwareid')
    locationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location down to the deck on which this labware exists. The reason this can be `null` or omitted is just backwards compatibility, for older runs and analyses. This should always be present for new runs and analyses, even for labware whose location is off-deck.',
        title='Locationsequence',
    )
    offsetId: str | None = Field(
        None,
        description='An ID referencing the labware offset that will apply to this labware in this location.',
        title='Offsetid',
    )


class RequestData(BaseModel):
    """
    Request body data for `PATCH /errorRecovery/settings`.
    """

    enabled: bool | None = Field(
        None,
        description='If provided, globally enables or disables error recovery mode.\n\nIf this is `true`, a run (see the `/runs` endpoints) will *potentially*\nenter recovery mode when an error happens, depending on the details of\nthe error and depending on `/runs/{runId}/errorRecoveryPolicy`.\n\nIf this is `false`, a run will just fail if it encounters an error.\n\nThe default is `true`. This currently only has an effect on Flex robots.\nOn OT-2s, error recovery is not supported.\n',
        title='Enabled',
    )


class RequestModelAnalysisRequest(BaseModel):
    data: AnalysisRequest = Field(..., description="the document’s 'primary data'")


class RequestModelDeckConfigurationRequest(BaseModel):
    data: DeckConfigurationRequest = Field(
        ..., description="the document’s 'primary data'"
    )


class RequestModelRequestData(BaseModel):
    data: RequestData = Field(..., description="the document’s 'primary data'")


class RequestModelDictStrObject(BaseModel):
    data: dict[str, Any] = Field(
        ..., description="the document’s 'primary data'", title='Data'
    )


class RequiredLabware(BaseModel):
    """
    A model that describes a single labware required for performing a
    calibration action.
    """

    slot: int | str = Field(..., title='Slot')
    loadName: str = Field(..., title='Loadname')
    namespace: str = Field(..., title='Namespace')
    version: str = Field(..., title='Version')
    isTiprack: bool = Field(..., title='Istiprack')
    definition: dict[str, Any] = Field(..., title='Definition')


class ResetOptionId(Enum):
    """
    The available reset options
    """

    bootScripts = 'bootScripts'
    deckCalibration = 'deckCalibration'
    deckConfiguration = 'deckConfiguration'
    pipetteOffsetCalibrations = 'pipetteOffsetCalibrations'
    gripperOffsetCalibrations = 'gripperOffsetCalibrations'
    tipLengthCalibrations = 'tipLengthCalibrations'
    runsHistory = 'runsHistory'
    onDeviceDisplay = 'onDeviceDisplay'
    moduleCalibration = 'moduleCalibration'
    authorizedKeys = 'authorizedKeys'


class ResourceLink(BaseModel):
    """
    https://jsonapi.org/format/#document-links
    """

    href: str = Field(..., description='The link’s URL', title='Href')
    meta: dict[str, Any] | None = Field(
        None, description='Metadata about the link', title='Meta'
    )


class ResponseData(BaseModel):
    """
    Response body data from the `/errorRecovery/settings` endpoints.
    """

    enabled: bool = Field(
        ...,
        description='Whether error recovery mode is globally enabled.\nSee `PATCH /errorRecovery/settings`.\n',
        title='Enabled',
    )


class Speed2(BaseModel):
    __root__: int = Field(
        ...,
        description='Speed of retraction, in millimeters per second.',
        ge=0,
        title='Speed',
    )


class Speed3(BaseModel):
    __root__: float = Field(
        ...,
        description='Speed of retraction, in millimeters per second.',
        ge=0.0,
        title='Speed',
    )


class AirGapByVolumeItem1(BaseModel):
    __root__: int = Field(..., ge=0)


class AirGapByVolumeItem2(BaseModel):
    __root__: float = Field(..., ge=0.0)


class AirGapByVolumeItem3(BaseModel):
    __root__: int = Field(..., ge=0)


class AirGapByVolumeItem4(BaseModel):
    __root__: float = Field(..., ge=0.0)


class AirGapByVolumeItem(BaseModel):
    __root__: tuple[
        AirGapByVolumeItem1 | AirGapByVolumeItem2,
        AirGapByVolumeItem3 | AirGapByVolumeItem4,
    ] = Field(...)  # Removed min_items=2, max_items=2


class CommandType118(Enum):
    retractAxis = 'retractAxis'


class RetractAxisParams(BaseModel):
    """
    Payload required for a Retract Axis command.
    """

    axis: MotorAxis = Field(
        ...,
        description='Axis to retract to its home position as quickly as safely possible. The difference between retracting an axis and homing an axis using the home command is that a home will always probe the limit switch and will work as the first motion command a robot will need to execute; On the other hand, retraction will rely on this previously determined  home position to move to it as fast as safely possible. So on the Flex, it will move (fast) the axis to the previously recorded home position and on the OT2, it will move (fast) the axis a safe distance from the previously recorded home position, and then slowly approach the limit switch.',
    )


class RetractAxisResult(BaseModel):
    """
    Result data from the execution of a Rectract Axis command.
    """


class Speed4(BaseModel):
    __root__: int = Field(
        ...,
        description='Speed of retraction, in millimeters per second.',
        ge=0,
        title='Speed',
    )


class Speed5(BaseModel):
    __root__: float = Field(
        ...,
        description='Speed of retraction, in millimeters per second.',
        ge=0.0,
        title='Speed',
    )


class AirGapByVolumeItem51(BaseModel):
    __root__: int = Field(..., ge=0)


class AirGapByVolumeItem52(BaseModel):
    __root__: float = Field(..., ge=0.0)


class AirGapByVolumeItem53(BaseModel):
    __root__: int = Field(..., ge=0)


class AirGapByVolumeItem54(BaseModel):
    __root__: float = Field(..., ge=0.0)


class AirGapByVolumeItem5(BaseModel):
    __root__: tuple[
        AirGapByVolumeItem51 | AirGapByVolumeItem52,
        AirGapByVolumeItem53 | AirGapByVolumeItem54,
    ] = Field(...)  # Removed min_items=2, max_items=2


class CommandType120(Enum):
    flexStacker_retrieve = 'flexStacker/retrieve'


class RetrieveParams(BaseModel):
    """
    Input parameters for a labware retrieval command.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker.', title='Moduleid'
    )
    labwareId: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Labwareid',
    )
    displayName: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Displayname',
    )
    adapterId: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Adapterid',
    )
    lidId: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Lidid',
    )


class RetrieveResult(BaseModel):
    """
    Result data from a labware retrieval command.
    """

    labwareId: str = Field(
        ...,
        description='The labware ID of the primary retrieved labware.',
        title='Labwareid',
    )
    adapterId: str | None = Field(
        None,
        description='The optional Adapter Labware ID of the adapter under a primary labware.',
        title='Adapterid',
    )
    lidId: str | None = Field(
        None,
        description='The optional Lid Labware ID of the lid on a primary labware.',
        title='Lidid',
    )
    primaryLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(
        ...,
        description='The new location of the just-retrieved.',
        title='Primarylocationsequence',
    )
    lidLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The new location of the just-retrieved adapter labware under a primary labware.',
        title='Lidlocationsequence',
    )
    adapterLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The new location of the just-retrieved lid labware on a primary labware.',
        title='Adapterlocationsequence',
    )
    originalPrimaryLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(
        ...,
        description='The original location of the just-retrieved primary labware',
        title='Originalprimarylocationsequence',
    )
    originalAdapterLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The original location of an adapter labware if any',
        title='Originaladapterlocationsequence',
    )
    originalLidLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The original location of a lid labware if any',
        title='Originallidlocationsequence',
    )
    primaryLabwareURI: str = Field(
        ...,
        description='The labware definition URI of the primary labware.',
        title='Primarylabwareuri',
    )
    adapterLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the adapter labware.',
        title='Adapterlabwareuri',
    )
    lidLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the lid labware.',
        title='Lidlabwareuri',
    )


class RobotHomeTarget(BaseModel):
    """
    Parameters for the home
    """

    target: HomeTarget = Field(
        ...,
        description="What to home. Robot means to home all axes; pipette, only that pipette's carriage and pipette axes",
    )
    mount: Mount | None = Field(
        None,
        description='Which mount to home, if target is pipette (required in that case)',
    )


class RobotLightState(BaseModel):
    """
    Whether a light is (or should be turned) on or off
    """

    on: bool = Field(..., description='The light state', title='On')


class RobotMoveTarget(BaseModel):
    target: MotionTarget
    point: list[float] = Field(
        ...,
        description='A point in deck coordinates (x, y, z)',
        max_items=3,
        min_items=3,
        title='Point',
    )
    mount: Mount = Field(..., description='Which mount to move')
    model: str | None = Field(
        None,
        description='A pipette model that matches the pipette attached to the specified mount. Required if target is pipette',
        title='Model',
    )


class Shape6(Enum):
    roundedcuboid = 'roundedcuboid'


class BottomCrossSection(Enum):
    circular = 'circular'
    rectangular = 'rectangular'


class CircleDiameter(BaseModel):
    __root__: int = Field(..., ge=0, title='Circlediameter')


class CircleDiameter1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Circlediameter')


class RectangleXDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Rectanglexdimension')


class RectangleXDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Rectanglexdimension')


class RectangleYDimension(BaseModel):
    __root__: int = Field(..., ge=0, title='Rectangleydimension')


class RectangleYDimension1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Rectangleydimension')


class TopHeight4(BaseModel):
    __root__: int = Field(..., ge=0, title='Topheight')


class TopHeight5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topheight')


class BottomHeight4(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomheight')


class BottomHeight5(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomheight')


class RoundedCuboidSegment(BaseModel):
    shape: Literal['roundedcuboid'] = Field(..., const=True, title='Shape')
    bottomCrossSection: BottomCrossSection = Field(..., title='Bottomcrosssection')
    circleDiameter: CircleDiameter | CircleDiameter1 = Field(
        ..., title='Circlediameter'
    )
    rectangleXDimension: RectangleXDimension | RectangleXDimension1 = Field(
        ..., title='Rectanglexdimension'
    )
    rectangleYDimension: RectangleYDimension | RectangleYDimension1 = Field(
        ..., title='Rectangleydimension'
    )
    topHeight: TopHeight4 | TopHeight5 = Field(..., title='Topheight')
    bottomHeight: BottomHeight4 | BottomHeight5 = Field(..., title='Bottomheight')
    xCount: int | None = Field(1, ge=0, title='Xcount')
    yCount: int | None = Field(1, ge=0, title='Ycount')


class Style3(Enum):
    ROW = 'ROW'


class RowNozzleLayoutConfiguration(BaseModel):
    """
    Minimum information required for a new nozzle configuration.
    """

    style: Style3 = Field('ROW', const=True, title='Style')
    primaryNozzle: PrimaryNozzle = Field(
        ...,
        description='The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle.',
        title='Primarynozzle',
    )


class Ok5(Enum):
    boolean_True = True


class Id21(Enum):
    RunActionNotAllowed = 'RunActionNotAllowed'


class RunActionNotAllowed(BaseModel):
    """
    An error if one tries to issue an unsupported run action.
    """

    id: Id21 = Field('RunActionNotAllowed', const=True, title='Id')
    title: str | None = Field('Run Action Not Allowed', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class RunActionType(Enum):
    """
    The type of the run control action, which determines behavior.

    * `"play"`: Start the run, or resume it after it's been paused.

    * `"pause"`: Pause the run.

    * `"stop"`: Stop (cancel) the run.

    * `"resume-from-recovery"`: Resume normal protocol execution after the run was in
      error recovery mode. Continue from however the last command left the robot.

    * `"resume-from-recovery-assuming-false-positive"`: Resume normal protocol execution
      after the run was in error recovery mode. Act as if the underlying error was a
      false positive.

    To see the difference between `"resume-from-recovery"` and
    `"resume-from-recovery-assuming-false-positive"`, suppose we've just entered error
    recovery mode after a `commandType: "pickUpTip"` command failed with an
    `errorType: "tipPhysicallyMissing"` error. That normally leaves the robot thinking
    it has no tip attached. If you use `"resume-from-recovery"`, the robot will run
    the next protocol command from that state, acting as if there's no tip attached.
    (This may cause another error, if the next command needs a tip.)
    Whereas if you use `"resume-from-recovery-assuming-false-positive"`,
    the robot will try to nullify the error, thereby acting as if it *does* have a tip
    attached.

    Generally:

    * If you've tried to recover from the error by sending your own `intent: "fixit"`
      commands to `POST /runs/{id}/commands`, use `"resume-from-recovery"`. It's your
      responsibility to ensure your `POST`ed commands leave the robot in a good-enough
      state to continue with the protocol.

    * Otherwise, use `"resume-from-recovery-assuming-false-positive"`.

    Do not combine `intent: "fixit"` commands with
    `"resume-from-recovery-assuming-false-positive"`—the robot's built-in
    false-positive recovery may compete with your own.
    """

    play = 'play'
    pause = 'pause'
    stop = 'stop'
    resume_from_recovery = 'resume-from-recovery'
    resume_from_recovery_assuming_false_positive = (
        'resume-from-recovery-assuming-false-positive'
    )


class Id22(Enum):
    RunActive = 'RunActive'


class RunActive(BaseModel):
    """
    An error returned if there is a run active.

    If there is a run active, you cannot issue stateless commands.
    """

    id: Id22 = Field('RunActive', const=True, title='Id')
    title: str | None = Field('Run Active', title='Title')
    detail: str | None = Field(
        'There is an active run. Close the current run to issue commands via POST /commands.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4001', title='Errorcode')


class Id23(Enum):
    RunAlreadyActive = 'RunAlreadyActive'


class RunAlreadyActive(BaseModel):
    """
    An error if one tries to create a new run while one is already active.
    """

    id: Id23 = Field('RunAlreadyActive', const=True, title='Id')
    title: str | None = Field('Run Already Active', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4001', title='Errorcode')


class CommandType122(Enum):
    """
    Specific type of command.
    """

    airGapInPlace = 'airGapInPlace'


class CommandType123(Enum):
    """
    Specific type of command.
    """

    aspirate = 'aspirate'


class CommandType124(Enum):
    """
    Specific type of command.
    """

    aspirateWhileTracking = 'aspirateWhileTracking'


class CommandType125(Enum):
    """
    Specific type of command.
    """

    aspirateInPlace = 'aspirateInPlace'


class CommandType126(Enum):
    """
    Specific type of command.
    """

    comment = 'comment'


class CommandType127(Enum):
    """
    Specific type of command.
    """

    configureForVolume = 'configureForVolume'


class CommandType128(Enum):
    """
    Specific type of command.
    """

    configureNozzleLayout = 'configureNozzleLayout'


class CommandType129(Enum):
    """
    Specific type of command.
    """

    custom = 'custom'


class CommandType130(Enum):
    """
    Specific type of command.
    """

    dispense = 'dispense'


class CommandType131(Enum):
    """
    Specific type of command.
    """

    dispenseInPlace = 'dispenseInPlace'


class CommandType132(Enum):
    """
    Specific type of command.
    """

    dispenseWhileTracking = 'dispenseWhileTracking'


class CommandType133(Enum):
    """
    Specific type of command.
    """

    blowout = 'blowout'


class CommandType134(Enum):
    """
    Specific type of command.
    """

    blowOutInPlace = 'blowOutInPlace'


class CommandType135(Enum):
    """
    Specific type of command.
    """

    dropTip = 'dropTip'


class CommandType136(Enum):
    """
    Specific type of command.
    """

    dropTipInPlace = 'dropTipInPlace'


class CommandType137(Enum):
    """
    Specific type of command.
    """

    home = 'home'


class CommandType138(Enum):
    """
    Specific type of command.
    """

    retractAxis = 'retractAxis'


class CommandType139(Enum):
    """
    Specific type of command.
    """

    loadLabware = 'loadLabware'


class CommandType140(Enum):
    """
    Specific type of command.
    """

    reloadLabware = 'reloadLabware'


class CommandType141(Enum):
    """
    Specific type of command.
    """

    loadLiquid = 'loadLiquid'


class CommandType142(Enum):
    """
    Specific type of command.
    """

    loadLiquidClass = 'loadLiquidClass'


class CommandType143(Enum):
    """
    Specific type of command.
    """

    loadModule = 'loadModule'


class CommandType144(Enum):
    """
    Specific type of command.
    """

    identifyModule = 'identifyModule'


class CommandType145(Enum):
    """
    Specific type of command.
    """

    loadPipette = 'loadPipette'


class CommandType146(Enum):
    """
    Specific type of command.
    """

    loadLidStack = 'loadLidStack'


class CommandType147(Enum):
    """
    Specific type of command.
    """

    loadLid = 'loadLid'


class CommandType148(Enum):
    """
    Specific type of command.
    """

    moveLabware = 'moveLabware'


class CommandType149(Enum):
    """
    Specific type of command.
    """

    moveRelative = 'moveRelative'


class CommandType150(Enum):
    """
    Specific type of command.
    """

    moveToCoordinates = 'moveToCoordinates'


class CommandType151(Enum):
    """
    Specific type of command.
    """

    moveToWell = 'moveToWell'


class CommandType152(Enum):
    """
    Specific type of command.
    """

    moveToAddressableArea = 'moveToAddressableArea'


class CommandType153(Enum):
    """
    Specific type of command.
    """

    moveToAddressableAreaForDropTip = 'moveToAddressableAreaForDropTip'


class CommandType154(Enum):
    """
    Specific type of command.
    """

    prepareToAspirate = 'prepareToAspirate'


class CommandType155(Enum):
    """
    Specific type of command.
    """

    waitForResume = 'waitForResume'
    pause = 'pause'


class CommandType156(Enum):
    """
    Specific type of command.
    """

    waitForDuration = 'waitForDuration'


class CommandType157(Enum):
    """
    Specific type of command.
    """

    pickUpTip = 'pickUpTip'


class CommandType158(Enum):
    """
    Specific type of command.
    """

    savePosition = 'savePosition'


class CommandType159(Enum):
    """
    Specific type of command.
    """

    setRailLights = 'setRailLights'


class CommandType160(Enum):
    """
    Specific type of command.
    """

    touchTip = 'touchTip'


class CommandType161(Enum):
    """
    Specific type of command.
    """

    setStatusBar = 'setStatusBar'


class CommandType162(Enum):
    """
    Specific type of command.
    """

    verifyTipPresence = 'verifyTipPresence'


class CommandType163(Enum):
    """
    Specific type of command.
    """

    getTipPresence = 'getTipPresence'


class CommandType164(Enum):
    """
    Specific type of command.
    """

    getNextTip = 'getNextTip'


class CommandType165(Enum):
    """
    Specific type of command.
    """

    liquidProbe = 'liquidProbe'


class CommandType166(Enum):
    """
    Specific type of command.
    """

    tryLiquidProbe = 'tryLiquidProbe'


class CommandType167(Enum):
    """
    Specific type of command.
    """

    sealPipetteToTip = 'sealPipetteToTip'


class CommandType168(Enum):
    """
    Specific type of command.
    """

    pressureDispense = 'pressureDispense'


class CommandType169(Enum):
    """
    Specific type of command.
    """

    unsealPipetteFromTip = 'unsealPipetteFromTip'


class CommandType170(Enum):
    """
    Specific type of command.
    """

    heaterShaker_waitForTemperature = 'heaterShaker/waitForTemperature'


class CommandType171(Enum):
    """
    Specific type of command.
    """

    heaterShaker_setTargetTemperature = 'heaterShaker/setTargetTemperature'


class CommandType172(Enum):
    """
    Specific type of command.
    """

    heaterShaker_deactivateHeater = 'heaterShaker/deactivateHeater'


class CommandType173(Enum):
    """
    Specific type of command.
    """

    heaterShaker_setAndWaitForShakeSpeed = 'heaterShaker/setAndWaitForShakeSpeed'


class CommandType174(Enum):
    """
    Specific type of command.
    """

    heaterShaker_deactivateShaker = 'heaterShaker/deactivateShaker'


class CommandType175(Enum):
    """
    Specific type of command.
    """

    heaterShaker_openLabwareLatch = 'heaterShaker/openLabwareLatch'


class CommandType176(Enum):
    """
    Specific type of command.
    """

    heaterShaker_closeLabwareLatch = 'heaterShaker/closeLabwareLatch'


class CommandType177(Enum):
    """
    Specific type of command.
    """

    magneticModule_disengage = 'magneticModule/disengage'


class CommandType178(Enum):
    """
    Specific type of command.
    """

    magneticModule_engage = 'magneticModule/engage'


class CommandType179(Enum):
    """
    Specific type of command.
    """

    temperatureModule_setTargetTemperature = 'temperatureModule/setTargetTemperature'


class CommandType180(Enum):
    """
    Specific type of command.
    """

    temperatureModule_waitForTemperature = 'temperatureModule/waitForTemperature'


class CommandType181(Enum):
    """
    Specific type of command.
    """

    temperatureModule_deactivate = 'temperatureModule/deactivate'


class CommandType182(Enum):
    """
    Specific type of command.
    """

    thermocycler_setTargetBlockTemperature = 'thermocycler/setTargetBlockTemperature'


class CommandType183(Enum):
    """
    Specific type of command.
    """

    thermocycler_waitForBlockTemperature = 'thermocycler/waitForBlockTemperature'


class CommandType184(Enum):
    """
    Specific type of command.
    """

    thermocycler_setTargetLidTemperature = 'thermocycler/setTargetLidTemperature'


class CommandType185(Enum):
    """
    Specific type of command.
    """

    thermocycler_waitForLidTemperature = 'thermocycler/waitForLidTemperature'


class CommandType186(Enum):
    """
    Specific type of command.
    """

    thermocycler_deactivateBlock = 'thermocycler/deactivateBlock'


class CommandType187(Enum):
    """
    Specific type of command.
    """

    thermocycler_deactivateLid = 'thermocycler/deactivateLid'


class CommandType188(Enum):
    """
    Specific type of command.
    """

    thermocycler_openLid = 'thermocycler/openLid'


class CommandType189(Enum):
    """
    Specific type of command.
    """

    thermocycler_closeLid = 'thermocycler/closeLid'


class CommandType190(Enum):
    """
    Specific type of command.
    """

    thermocycler_runProfile = 'thermocycler/runProfile'


class CommandType191(Enum):
    """
    Specific type of command.
    """

    thermocycler_runExtendedProfile = 'thermocycler/runExtendedProfile'


class CommandType192(Enum):
    """
    Specific type of command.
    """

    absorbanceReader_closeLid = 'absorbanceReader/closeLid'


class CommandType193(Enum):
    """
    Specific type of command.
    """

    absorbanceReader_openLid = 'absorbanceReader/openLid'


class CommandType194(Enum):
    """
    Specific type of command.
    """

    absorbanceReader_initialize = 'absorbanceReader/initialize'


class CommandType195(Enum):
    """
    Specific type of command.
    """

    absorbanceReader_read = 'absorbanceReader/read'


class CommandType196(Enum):
    """
    Specific type of command.
    """

    flexStacker_retrieve = 'flexStacker/retrieve'


class CommandType197(Enum):
    """
    Specific type of command.
    """

    flexStacker_store = 'flexStacker/store'


class CommandType198(Enum):
    """
    Specific type of command.
    """

    flexStacker_setStoredLabware = 'flexStacker/setStoredLabware'


class CommandType199(Enum):
    """
    Specific type of command.
    """

    flexStacker_fill = 'flexStacker/fill'


class CommandType200(Enum):
    """
    Specific type of command.
    """

    flexStacker_empty = 'flexStacker/empty'


class CommandType201(Enum):
    """
    Specific type of command.
    """

    calibration_calibrateGripper = 'calibration/calibrateGripper'


class CommandType202(Enum):
    """
    Specific type of command.
    """

    calibration_calibratePipette = 'calibration/calibratePipette'


class CommandType203(Enum):
    """
    Specific type of command.
    """

    calibration_calibrateModule = 'calibration/calibrateModule'


class CommandType204(Enum):
    """
    Specific type of command.
    """

    calibration_moveToMaintenancePosition = 'calibration/moveToMaintenancePosition'


class CommandType205(Enum):
    """
    Specific type of command.
    """

    unsafe_blowOutInPlace = 'unsafe/blowOutInPlace'


class CommandType206(Enum):
    """
    Specific type of command.
    """

    unsafe_dropTipInPlace = 'unsafe/dropTipInPlace'


class CommandType207(Enum):
    """
    Specific type of command.
    """

    unsafe_updatePositionEstimators = 'unsafe/updatePositionEstimators'


class CommandType208(Enum):
    """
    Specific type of command.
    """

    unsafe_engageAxes = 'unsafe/engageAxes'


class CommandType209(Enum):
    """
    Specific type of command.
    """

    unsafe_ungripLabware = 'unsafe/ungripLabware'


class CommandType210(Enum):
    """
    Specific type of command.
    """

    unsafe_placeLabware = 'unsafe/placeLabware'


class CommandType211(Enum):
    """
    Specific type of command.
    """

    unsafe_flexStacker_manualRetrieve = 'unsafe/flexStacker/manualRetrieve'


class CommandType212(Enum):
    """
    Specific type of command.
    """

    unsafe_flexStacker_closeLatch = 'unsafe/flexStacker/closeLatch'


class CommandType213(Enum):
    """
    Specific type of command.
    """

    unsafe_flexStacker_openLatch = 'unsafe/flexStacker/openLatch'


class CommandType214(Enum):
    """
    Specific type of command.
    """

    unsafe_flexStacker_prepareShuttle = 'unsafe/flexStacker/prepareShuttle'


class CommandType215(Enum):
    """
    Specific type of command.
    """

    robot_moveAxesRelative = 'robot/moveAxesRelative'


class CommandType216(Enum):
    """
    Specific type of command.
    """

    robot_moveAxesTo = 'robot/moveAxesTo'


class CommandType217(Enum):
    """
    Specific type of command.
    """

    robot_moveTo = 'robot/moveTo'


class CommandType218(Enum):
    """
    Specific type of command.
    """

    robot_openGripperJaw = 'robot/openGripperJaw'


class CommandType219(Enum):
    """
    Specific type of command.
    """

    robot_closeGripperJaw = 'robot/closeGripperJaw'


class Id24(Enum):
    RunDataError = 'RunDataError'


class RunDataError(BaseModel):
    """
    A model for an error loading a run.
    """

    id: Id24 = Field('RunDataError', const=True, title='Id')
    title: str | None = Field(
        'Run Data Error',
        description='A short, human readable name for this type of error',
        title='Title',
    )
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class CommandType220(Enum):
    thermocycler_runExtendedProfile = 'thermocycler/runExtendedProfile'


class RunExtendedProfileResult(BaseModel):
    """
    Result data from running a Thermocycler profile.
    """


class RunLink(BaseModel):
    """
    Link to a run resource.
    """

    id: str = Field(..., description="The run's id", title='Id')
    href: str = Field(..., description="The run's URL", title='Href')


class CommandType222(Enum):
    thermocycler_runProfile = 'thermocycler/runProfile'


class RunProfileResult(BaseModel):
    """
    Result data from running a Thermocycler profile.
    """


class RunProfileStepParams(BaseModel):
    """
    Input parameters for an individual Thermocycler profile step.
    """

    celsius: float = Field(
        ..., description='Target temperature in °C.', title='Celsius'
    )
    holdSeconds: float = Field(
        ...,
        description='Time to hold target temperature at in seconds.',
        title='Holdseconds',
    )


class Id25(Enum):
    RunStopped = 'RunStopped'


class RunStopped(BaseModel):
    """
    An error if one tries to modify a stopped run.
    """

    id: Id25 = Field('RunStopped', const=True, title='Id')
    title: str | None = Field('Run Stopped', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4000', title='Errorcode')


class RunUpdate(BaseModel):
    """
    Update request data for an existing run.
    """

    current: bool | None = Field(
        None,
        description='Whether this run is currently controlling the robot. Setting `current` to `false` will deactivate the run.',
        title='Current',
    )


class CommandType224(Enum):
    savePosition = 'savePosition'


class SavePositionParams(BaseModel):
    """
    Payload needed to save a pipette's current position.
    """

    pipetteId: str = Field(
        ...,
        description='Unique identifier of the pipette in question.',
        title='Pipetteid',
    )
    positionId: str | None = Field(
        None,
        description='An optional ID to assign to this command instance. Auto-assigned if not defined.',
        title='Positionid',
    )
    failOnNotHomed: bool | None = Field(
        None,
        description='Require all axes to be homed before saving position.',
        title='Failonnothomed',
    )


class SavePositionResult(BaseModel):
    """
    Result data from executing a savePosition.
    """

    positionId: str = Field(
        ...,
        description='An ID to reference this position in subsequent requests.',
        title='Positionid',
    )
    position: DeckPoint = Field(
        ...,
        description="The (x,y,z) coordinates of the pipette's critical point in deck space.",
    )


class CommandType226(Enum):
    sealPipetteToTip = 'sealPipetteToTip'


class SealPipetteToTipResult(BaseModel):
    """
    Result data from the execution of a SealPipetteToTip.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    tipVolume: float | None = Field(
        0,
        description='Maximum volume of liquid that the picked up tip can hold, in µL.',
        ge=0.0,
        title='Tipvolume',
    )
    tipLength: float | None = Field(
        0, description='The length of the tip in mm.', ge=0.0, title='Tiplength'
    )
    tipDiameter: float | None = Field(
        0, description='The diameter of the tip in mm.', ge=0.0, title='Tipdiameter'
    )


class LocationSequence21(BaseModel):
    __root__: (
        OnLabwareOffsetLocationSequenceComponent
        | OnModuleOffsetLocationSequenceComponent
        | OnAddressableAreaOffsetLocationSequenceComponent
    ) = Field(..., discriminator='kind')


class LocationSequence2(BaseModel):
    __root__: list[LocationSequence21] = Field(
        1,
        description='Return only results having this exact `locationSequence`. Omit to accept any `locationSequence`.',
        min_items=1,
        title='Locationsequence',
    )


class LocationSequence3(Enum):
    """
    Return only results having this exact `locationSequence`. Omit to accept any `locationSequence`.
    """

    anyLocation = 'anyLocation'


class SearchFilter(BaseModel):
    id: str | None = Field(
        1,
        description='Return only results having this exact `id`. Omit to accept any `id`.',
        title='Id',
    )
    definitionUri: str | None = Field(
        1,
        description='Return only results having this exact `definitionUri`. Omit to accept any `definitionUri`.',
        title='Definitionuri',
    )
    locationSequence: LocationSequence2 | LocationSequence3 | None = Field(
        1,
        description='Return only results having this exact `locationSequence`. Omit to accept any `locationSequence`.',
        title='Locationsequence',
    )
    mostRecentOnly: bool | None = Field(
        False,
        description='If `true`, this filter returns only the most recently-added result of all that matched it. Otherwise, it returns all of them.',
        title='Mostrecentonly',
    )


class AnnotationType1(Enum):
    secondOrderCommand = 'secondOrderCommand'


class SecondOrderCommandAnnotation(BaseModel):
    """
    Annotates a group of atomic commands which were the direct result of a second order command.

    Examples of second order commands would be transfer, consolidate, mix, etc.
    """

    commandKeys: list[str] = Field(
        ...,
        description='Command keys to which this annotation applies',
        title='Commandkeys',
    )
    annotationType: AnnotationType1 = Field(
        'secondOrderCommand', const=True, title='Annotationtype'
    )
    params: dict[str, Any] = Field(
        ...,
        description='Key value pairs of the parameters passed to the second order command that this annotates.',
        title='Params',
    )
    machineReadableName: str = Field(
        ...,
        description='The name of the second order command in the form that the generating software refers to it',
        title='Machinereadablename',
    )
    userSpecifiedName: str | None = Field(
        None,
        description='The optional user-specified name of the second order command',
        title='Userspecifiedname',
    )
    userSpecifiedDescription: str | None = Field(
        None,
        description='The optional user-specified description of the second order command',
        title='Userspecifieddescription',
    )


class SerialCommand(BaseModel):
    """
    The serialized module call
    """

    command_type: str = Field(
        ..., description='The name of the module function to call', title='Command Type'
    )
    args: list[Any] | None = Field(
        None, description='The ordered args list for the call', title='Args'
    )


class SerialCommandResponse(BaseModel):
    """
    "The result of a successful call
    """

    message: str = Field(..., description='A human readable string', title='Message')
    returnValue: str | None = Field(
        None, description='The return value from the call', title='Returnvalue'
    )


class Command(Enum):
    """
    The command description
    """

    pipette_aspirate = 'pipette.aspirate'


class Command1(Enum):
    """
    The command description
    """

    pipette_dispense = 'pipette.dispense'


class Command2(Enum):
    """
    The command description
    """

    pipette_dropTip = 'pipette.dropTip'


class Command3(Enum):
    """
    The command description
    """

    calibration_jog = 'calibration.jog'


class SessionCommandRequestLiteralJogJogPositionEmptyModel(BaseModel):
    command: Command3 = Field(
        'calibration.jog',
        const=True,
        description='The command description',
        title='Command',
    )
    data: JogPosition = Field(..., description='The command data')


class Command4(Enum):
    """
    The command description
    """

    calibration_loadLabware = 'calibration.loadLabware'


class SessionCommandRequestLiteralLoadLabwareLoadLabwareByDefinitionRequestDataEmptyModel(
    BaseModel
):
    command: Command4 = Field(
        'calibration.loadLabware',
        const=True,
        description='The command description',
        title='Command',
    )
    data: LoadLabwareByDefinitionRequestData = Field(
        ..., description='The command data'
    )


class Command5(Enum):
    """
    The command description
    """

    equipment_loadLabware = 'equipment.loadLabware'


class Command6(Enum):
    """
    The command description
    """

    equipment_loadPipette = 'equipment.loadPipette'


class Command7(Enum):
    """
    The command description
    """

    pipette_pickUpTip = 'pipette.pickUpTip'


class Command8(Enum):
    """
    The command description
    """

    calibration_setHasCalibrationBlock = 'calibration.setHasCalibrationBlock'


class Command9(Enum):
    """
    The command description
    """

    protocol_startRun = 'protocol.startRun'
    protocol_startSimulate = 'protocol.startSimulate'
    protocol_cancel = 'protocol.cancel'
    protocol_pause = 'protocol.pause'
    protocol_resume = 'protocol.resume'
    calibration_moveToTipRack = 'calibration.moveToTipRack'
    calibration_moveToPointOne = 'calibration.moveToPointOne'
    calibration_moveToDeck = 'calibration.moveToDeck'
    calibration_moveToReferencePoint = 'calibration.moveToReferencePoint'
    calibration_pickUpTip = 'calibration.pickUpTip'
    calibration_confirmTip = 'calibration.confirmTip'
    calibration_invalidateTip = 'calibration.invalidateTip'
    calibration_saveOffset = 'calibration.saveOffset'
    calibration_exitSession = 'calibration.exitSession'
    calibration_invalidateLastAction = 'calibration.invalidateLastAction'
    calibration_deck_moveToPointTwo = 'calibration.deck.moveToPointTwo'
    calibration_deck_moveToPointThree = 'calibration.deck.moveToPointThree'
    calibration_check_comparePoint = 'calibration.check.comparePoint'
    calibration_check_switchPipette = 'calibration.check.switchPipette'
    calibration_check_returnTip = 'calibration.check.returnTip'
    calibration_check_transition = 'calibration.check.transition'


class SessionCommandRequestLiteralStartRunStartSimulateCancelPauseResumeMoveToTipRackMoveToPointOneMoveToDeckMoveToReferencePointPickUpTipConfirmTipAttachedInvalidateTipSaveOffsetExitInvalidateLastActionMoveToPointTwoMoveToPointThreeComparePointSwitchPipetteReturnTipTransitionEmptyModelEmptyModel(
    BaseModel
):
    command: Command9 = Field(
        ..., description='The command description', title='Command'
    )
    data: EmptyModel = Field(..., description='The command data')


class Command10(Enum):
    pipette_aspirate = 'pipette.aspirate'


class Command11(Enum):
    pipette_dispense = 'pipette.dispense'


class Command12(Enum):
    pipette_dropTip = 'pipette.dropTip'


class Command13(Enum):
    calibration_jog = 'calibration.jog'


class Command14(Enum):
    calibration_loadLabware = 'calibration.loadLabware'


class Command15(Enum):
    equipment_loadLabware = 'equipment.loadLabware'


class Command16(Enum):
    equipment_loadPipette = 'equipment.loadPipette'


class Command17(Enum):
    pipette_pickUpTip = 'pipette.pickUpTip'


class Command18(Enum):
    calibration_setHasCalibrationBlock = 'calibration.setHasCalibrationBlock'


class Command19(Enum):
    protocol_startRun = 'protocol.startRun'
    protocol_startSimulate = 'protocol.startSimulate'
    protocol_cancel = 'protocol.cancel'
    protocol_pause = 'protocol.pause'
    protocol_resume = 'protocol.resume'
    calibration_moveToTipRack = 'calibration.moveToTipRack'
    calibration_moveToPointOne = 'calibration.moveToPointOne'
    calibration_moveToDeck = 'calibration.moveToDeck'
    calibration_moveToReferencePoint = 'calibration.moveToReferencePoint'
    calibration_pickUpTip = 'calibration.pickUpTip'
    calibration_confirmTip = 'calibration.confirmTip'
    calibration_invalidateTip = 'calibration.invalidateTip'
    calibration_saveOffset = 'calibration.saveOffset'
    calibration_exitSession = 'calibration.exitSession'
    calibration_invalidateLastAction = 'calibration.invalidateLastAction'
    calibration_deck_moveToPointTwo = 'calibration.deck.moveToPointTwo'
    calibration_deck_moveToPointThree = 'calibration.deck.moveToPointThree'
    calibration_check_comparePoint = 'calibration.check.comparePoint'
    calibration_check_switchPipette = 'calibration.check.switchPipette'
    calibration_check_returnTip = 'calibration.check.returnTip'
    calibration_check_transition = 'calibration.check.transition'


class SessionType6(Enum):
    """
    The available session types
    """

    calibrationCheck = 'calibrationCheck'
    tipLengthCalibration = 'tipLengthCalibration'
    deckCalibration = 'deckCalibration'
    pipetteOffsetCalibration = 'pipetteOffsetCalibration'


class CommandType228(Enum):
    heaterShaker_setAndWaitForShakeSpeed = 'heaterShaker/setAndWaitForShakeSpeed'


class SetAndWaitForShakeSpeedParams(BaseModel):
    """
    Input parameters to set and wait for a shake speed for a Heater-Shaker Module.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )
    rpm: float = Field(
        ..., description='Target speed in rotations per minute.', title='Rpm'
    )


class SetAndWaitForShakeSpeedResult(BaseModel):
    """
    Result data from setting and waiting for a Heater-Shaker's shake speed.
    """

    pipetteRetracted: bool = Field(
        ...,
        description='Whether this command automatically retracted the pipettes before starting the shake, to avoid a potential collision.',
        title='Pipetteretracted',
    )


class SetHasCalibrationBlockRequestData(BaseModel):
    hasBlock: bool = Field(
        ...,
        description='whether or not there is a calibration block present',
        title='Hasblock',
    )


class CommandType230(Enum):
    setRailLights = 'setRailLights'


class SetRailLightsParams(BaseModel):
    """
    Payload required to set the rail lights on or off.
    """

    on: bool = Field(
        ...,
        description='The field that determines if the light is turned off or on.',
        title='On',
    )


class SetRailLightsResult(BaseModel):
    """
    Result data from the execution of a setRailLights command.
    """


class CommandType232(Enum):
    setStatusBar = 'setStatusBar'


class SetStatusBarResult(BaseModel):
    """
    Result data from the execution of a SetStatusBar command.
    """


class CommandType234(Enum):
    flexStacker_setStoredLabware = 'flexStacker/setStoredLabware'


class InitialCount(BaseModel):
    __root__: int = Field(
        ...,
        description='The number of labware that should be initially stored in the stacker. This number will be silently clamped to\nthe maximum number of labware that will fit; do not rely on the parameter to know how many labware are in the stacker.\n\nThis field works with the initialStoredLabware field in a complex way.\n\nThe following must be true for initialCount to be valid:\n  - It is not specified, and initialStoredLabware is not specified, in which case the stacker will start empty\n  - It is not specified, and initialStoredLabware is specified, in which case the contents of the stacker are entirely\n    determined by initialStoredLabware.\n  - It is specified, and initialStoredLabware is specified, in which case the length of initialStoredLabware must be\n    exactly initialCount, and the contents of the stacker will be determined by initialStoredLabware.\n',
        ge=0,
        title='Initialcount',
    )


class CommandType236(Enum):
    thermocycler_setTargetBlockTemperature = 'thermocycler/setTargetBlockTemperature'


class SetTargetBlockTemperatureParams(BaseModel):
    """
    Input parameters to set a Thermocycler's target block temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler Module.', title='Moduleid'
    )
    celsius: float = Field(
        ..., description='Target temperature in °C.', title='Celsius'
    )
    blockMaxVolumeUl: float | None = Field(
        None,
        description='Amount of liquid in uL of the most-full well in labware loaded onto the thermocycler.',
        title='Blockmaxvolumeul',
    )
    holdTimeSeconds: float | None = Field(
        None,
        description='Amount of time, in seconds, to hold the temperature for. If specified, a waitForBlockTemperature command will block until the given hold time has elapsed.',
        title='Holdtimeseconds',
    )


class SetTargetBlockTemperatureResult(BaseModel):
    """
    Result data from setting a Thermocycler's target block temperature.
    """

    targetBlockTemperature: float = Field(
        ...,
        description='The target block temperature that was set after validation.',
        title='Targetblocktemperature',
    )


class CommandType238(Enum):
    thermocycler_setTargetLidTemperature = 'thermocycler/setTargetLidTemperature'


class SetTargetLidTemperatureParams(BaseModel):
    """
    Input parameters to set a Thermocycler's target lid temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler Module.', title='Moduleid'
    )
    celsius: float = Field(
        ..., description='Target temperature in °C.', title='Celsius'
    )


class SetTargetLidTemperatureResult(BaseModel):
    """
    Result data from setting a Thermocycler's target lid temperature.
    """

    targetLidTemperature: float = Field(
        ...,
        description='The target lid temperature that was set after validation.',
        title='Targetlidtemperature',
    )


class Id26(Enum):
    SetupCommandNotAllowed = 'SetupCommandNotAllowed'


class SetupCommandNotAllowed(BaseModel):
    """
    An error if a given run setup command is not allowed.
    """

    id: Id26 = Field('SetupCommandNotAllowed', const=True, title='Id')
    title: str | None = Field('Setup Command Not Allowed', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class SimpleBodyDeckConfigurationResponse(BaseModel):
    data: DeckConfigurationResponse = Field(
        ..., description='The document’s primary data'
    )


class SimpleBodyDoorStatusModel(BaseModel):
    data: DoorStatusModel = Field(..., description='The document’s primary data')


class SimpleBodyEstopStatusModel(BaseModel):
    data: EstopStatusModel = Field(..., description='The document’s primary data')


class SimpleBodyLabwareDefinitionSummary(BaseModel):
    data: LabwareDefinitionSummary = Field(
        ..., description='The document’s primary data'
    )


class SimpleBodyResponseData(BaseModel):
    data: ResponseData = Field(..., description='The document’s primary data')


class SimpleBodyDictStrObject(BaseModel):
    data: dict[str, Any] = Field(
        ..., description='The document’s primary data', title='Data'
    )


class SimpleEmptyBody(BaseModel):
    """
    A response that returns no data and no links.
    """


class SimpleMultiBodyErrorOccurrence(BaseModel):
    data: list[ErrorOccurrence] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimpleMultiBodyStr(BaseModel):
    data: list[str] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimulatedProbeResult(BaseModel):
    """
    A sentinel value to substitute for the resulting volume/height of a liquid probe during simulation.
    """

    operations_after_probe: list[float] | None = Field(
        [], title='Operations After Probe'
    )
    net_liquid_exchanged_after_probe: float | None = Field(
        0, title='Net Liquid Exchanged After Probe'
    )


class FlowRateByVolumeItem61(BaseModel):
    __root__: int = Field(..., ge=0)


class FlowRateByVolumeItem62(BaseModel):
    __root__: float = Field(..., ge=0.0)


class FlowRateByVolumeItem63(BaseModel):
    __root__: int = Field(..., ge=0)


class FlowRateByVolumeItem64(BaseModel):
    __root__: float = Field(..., ge=0.0)


class FlowRateByVolumeItem6(BaseModel):
    __root__: tuple[
        FlowRateByVolumeItem61 | FlowRateByVolumeItem62,
        FlowRateByVolumeItem63 | FlowRateByVolumeItem64,
    ] = Field(...)  # Removed min_items=2, max_items=2


class CorrectionByVolumeItem41(BaseModel):
    __root__: int = Field(..., ge=0)


class CorrectionByVolumeItem42(BaseModel):
    __root__: float = Field(..., ge=0.0)


class CorrectionByVolumeItem4(BaseModel):
    __root__: tuple[
        CorrectionByVolumeItem41 | CorrectionByVolumeItem42, int | float
    ] = Field(...)  # Removed min_items=2, max_items=2


class PushOutByVolumeItem1(BaseModel):
    __root__: int = Field(..., ge=0)


class PushOutByVolumeItem2(BaseModel):
    __root__: float = Field(..., ge=0.0)


class PushOutByVolumeItem3(BaseModel):
    __root__: int = Field(..., ge=0)


class PushOutByVolumeItem4(BaseModel):
    __root__: float = Field(..., ge=0.0)


class PushOutByVolumeItem(BaseModel):
    __root__: tuple[
        PushOutByVolumeItem1 | PushOutByVolumeItem2,
        PushOutByVolumeItem3 | PushOutByVolumeItem4,
    ] = Field(...)  # Removed min_items=2, max_items=2


class Style4(Enum):
    SINGLE = 'SINGLE'


class SingleNozzleLayoutConfiguration(BaseModel):
    """
    Minimum information required for a new nozzle configuration.
    """

    style: Style4 = Field('SINGLE', const=True, title='Style')
    primaryNozzle: PrimaryNozzle = Field(
        ...,
        description='The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle.',
        title='Primarynozzle',
    )


class SpringDirectionalForce(Enum):
    backLeftBottom = 'backLeftBottom'


class SourceType(Enum):
    """
    Calibration source type
    """

    default = 'default'
    factory = 'factory'
    user = 'user'
    calibration_check = 'calibration_check'
    legacy = 'legacy'
    unknown = 'unknown'


class SpeedStatus(Enum):
    holding_at_target = 'holding at target'
    speeding_up = 'speeding up'
    slowing_down = 'slowing down'
    idle = 'idle'
    error = 'error'


class Shape7(Enum):
    spherical = 'spherical'


class RadiusOfCurvature(BaseModel):
    __root__: int = Field(..., ge=0, title='Radiusofcurvature')


class RadiusOfCurvature1(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Radiusofcurvature')


class TopHeight6(BaseModel):
    __root__: int = Field(..., ge=0, title='Topheight')


class TopHeight7(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topheight')


class BottomHeight6(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomheight')


class BottomHeight7(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomheight')


class SphericalSegment(BaseModel):
    shape: Literal['spherical'] = Field(..., const=True, title='Shape')
    radiusOfCurvature: RadiusOfCurvature | RadiusOfCurvature1 = Field(
        ..., title='Radiusofcurvature'
    )
    topHeight: TopHeight6 | TopHeight7 = Field(..., title='Topheight')
    bottomHeight: BottomHeight6 | BottomHeight7 = Field(..., title='Bottomheight')
    xCount: int | None = Field(1, ge=0, title='Xcount')
    yCount: int | None = Field(1, ge=0, title='Ycount')


class Shape8(Enum):
    squaredcone = 'squaredcone'


class CircleDiameter2(BaseModel):
    __root__: int = Field(..., ge=0, title='Circlediameter')


class CircleDiameter3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Circlediameter')


class RectangleXDimension2(BaseModel):
    __root__: int = Field(..., ge=0, title='Rectanglexdimension')


class RectangleXDimension3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Rectanglexdimension')


class RectangleYDimension2(BaseModel):
    __root__: int = Field(..., ge=0, title='Rectangleydimension')


class RectangleYDimension3(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Rectangleydimension')


class TopHeight8(BaseModel):
    __root__: int = Field(..., ge=0, title='Topheight')


class TopHeight9(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Topheight')


class BottomHeight8(BaseModel):
    __root__: int = Field(..., ge=0, title='Bottomheight')


class BottomHeight9(BaseModel):
    __root__: float = Field(..., ge=0.0, title='Bottomheight')


class SquaredConeSegment(BaseModel):
    shape: Literal['squaredcone'] = Field(..., const=True, title='Shape')
    bottomCrossSection: BottomCrossSection = Field(..., title='Bottomcrosssection')
    circleDiameter: CircleDiameter2 | CircleDiameter3 = Field(
        ..., title='Circlediameter'
    )
    rectangleXDimension: RectangleXDimension2 | RectangleXDimension3 = Field(
        ..., title='Rectanglexdimension'
    )
    rectangleYDimension: RectangleYDimension2 | RectangleYDimension3 = Field(
        ..., title='Rectangleydimension'
    )
    topHeight: TopHeight8 | TopHeight9 = Field(..., title='Topheight')
    bottomHeight: BottomHeight8 | BottomHeight9 = Field(..., title='Bottomheight')
    xCount: int | None = Field(1, ge=0, title='Xcount')
    yCount: int | None = Field(1, ge=0, title='Ycount')


class StackerFillEmptyStrategy(Enum):
    """
    Strategy to use for filling or emptying a stacker.
    """

    manualWithPause = 'manualWithPause'
    logical = 'logical'


class StackerLabwareMovementStrategy(Enum):
    """
    Strategy to retrieve or store labware.
    """

    automatic = 'automatic'
    manual = 'manual'


class StackerStoredLabwareDetails(BaseModel):
    """
    The parameters defining a labware to be stored in the stacker.
    """

    loadName: str = Field(
        ...,
        description='Name used to reference the definition of this labware.',
        title='Loadname',
    )
    namespace: str = Field(
        ...,
        description='Namespace of the definition of this labware.',
        title='Namespace',
    )
    version: int = Field(
        ..., description='Version of the definition of this labware.', title='Version'
    )


class StackerStoredLabwareGroup(BaseModel):
    """
    Represents one group of labware stored in a stacker hopper.
    """

    primaryLabwareId: str = Field(..., title='Primarylabwareid')
    adapterLabwareId: str | None = Field(None, title='Adapterlabwareid')
    lidLabwareId: str | None = Field(None, title='Lidlabwareid')


class ErrorType3(Enum):
    stallOrCollision = 'stallOrCollision'


class StallOrCollisionError(BaseModel):
    """
    Returned when the machine detects that axis encoders are reading a different position than expected.

    All axes are stopped at the point where the error was encountered.

    The next thing to move the machine must account for the robot not having a valid estimate
    of its position. It should be a `home` or `unsafe/updatePositionEstimators`.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(True, title='Isdefined')
    errorType: ErrorType3 = Field('stallOrCollision', const=True, title='Errortype')
    errorCode: str = Field(..., title='Errorcode')
    detail: str | None = Field('Stall or Collision Detected', title='Detail')
    errorInfo: dict[str, Any] = Field(
        ...,
        description='Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n',
        title='Errorinfo',
    )
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class StatusBarAnimation(Enum):
    """
    Status Bar animation options.
    """

    idle = 'idle'
    confirm = 'confirm'
    updating = 'updating'
    disco = 'disco'
    off = 'off'


class CommandType240(Enum):
    flexStacker_store = 'flexStacker/store'


class StoreParams(BaseModel):
    """
    Input parameters for a labware storage command.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the flex stacker.', title='Moduleid'
    )
    strategy: StackerLabwareMovementStrategy = Field(
        ...,
        description='If manual, indicates that labware has been moved to the hopper manually by the user, as required in error recovery.',
    )


class StoreResult(BaseModel):
    """
    Result data from a labware storage command.
    """

    eventualDestinationLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location in which all labware moved by this command will eventually reside.',
        title='Eventualdestinationlocationsequence',
    )
    primaryOriginLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The origin location of the primary labware.',
        title='Primaryoriginlocationsequence',
    )
    primaryLabwareId: str | None = Field(
        None,
        description='The primary labware in the stack that was stored.',
        title='Primarylabwareid',
    )
    adapterOriginLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The origin location of the adapter labware, if any.',
        title='Adapteroriginlocationsequence',
    )
    adapterLabwareId: str | None = Field(
        None,
        description='The adapter in the stack that was stored, if any.',
        title='Adapterlabwareid',
    )
    lidOriginLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The origin location of the lid labware, if any.',
        title='Lidoriginlocationsequence',
    )
    lidLabwareId: str | None = Field(
        None,
        description='The lid in the stack that was stored, if any.',
        title='Lidlabwareid',
    )
    primaryLabwareURI: str = Field(
        ...,
        description='The labware definition URI of the primary labware.',
        title='Primarylabwareuri',
    )
    adapterLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the adapter labware.',
        title='Adapterlabwareuri',
    )
    lidLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the lid labware.',
        title='Lidlabwareuri',
    )


class LocationSequence5(Enum):
    """
    Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location.
    """

    anyLocation = 'anyLocation'


class LocationSequence61(BaseModel):
    __root__: (
        OnLabwareOffsetLocationSequenceComponent
        | OnModuleOffsetLocationSequenceComponent
        | OnAddressableAreaOffsetLocationSequenceComponent
    ) = Field(..., discriminator='kind')


class LocationSequence6(BaseModel):
    __root__: list[LocationSequence61] = Field(
        ...,
        description='Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location.',
        min_items=1,  # Changed from min_length=1
        title='Locationsequence',
    )


class LocationSequence7(Enum):
    """
    Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location.
    """

    anyLocation = 'anyLocation'


class StoredLabwareOffsetCreate(BaseModel):
    """
    Create an offset for storage.
    """

    definitionUri: str = Field(
        ..., description="The URI for the labware's definition.", title='Definitionuri'
    )
    locationSequence: LocationSequence6 | LocationSequence7 = Field(
        ...,
        description='Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location.',
        title='Locationsequence',
    )
    vector: LabwareOffsetVector = Field(
        ..., description='The offset applied to matching labware.'
    )


class SubSystem(Enum):
    """
    Specific hardware elements of the robot system.

    Only certain subsystems might be valid for a certain robot, and not all subsystems
    might be attached at any given time. In general, specific subsystems should only
    be provided if general queries indicate that they are present.
    """

    gantry_x = 'gantry_x'
    gantry_y = 'gantry_y'
    head = 'head'
    pipette_left = 'pipette_left'
    pipette_right = 'pipette_right'
    gripper = 'gripper'
    rear_panel = 'rear_panel'
    hepa_uv = 'hepa_uv'
    motor_controller_board = 'motor_controller_board'


class Speed6(BaseModel):
    __root__: int = Field(
        ...,
        description='Speed of submerging, in millimeters per second.',
        ge=0,
        title='Speed',
    )


class Speed7(BaseModel):
    __root__: float = Field(
        ...,
        description='Speed of submerging, in millimeters per second.',
        ge=0.0,
        title='Speed',
    )


class Id27(Enum):
    SubsystemNotPresent = 'SubsystemNotPresent'


class SubsystemNotPresent(BaseModel):
    """
    An error if a subsystem that is not present is requested.
    """

    id: Id27 = Field('SubsystemNotPresent', const=True, title='Id')
    title: str | None = Field('Subsystem Not Present', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class SystemTimeAttributes(BaseModel):
    """
    System time attributes common to requests and responses.
    """

    systemTime: datetime = Field(..., title='Systemtime')


class SystemTimeResponseAttributes(BaseModel):
    """
    System time response model attributes.
    """

    systemTime: datetime = Field(..., title='Systemtime')
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )


class ModuleType4(Enum):
    temperatureModuleType = 'temperatureModuleType'


class ModuleModel4(Enum):
    temperatureModuleV1 = 'temperatureModuleV1'
    temperatureModuleV2 = 'temperatureModuleV2'


class TemperatureStatus(Enum):
    holding_at_target = 'holding at target'
    cooling = 'cooling'
    heating = 'heating'
    idle = 'idle'
    error = 'error'


class ThermocyclerLidStatus(Enum):
    """
    Thermocycler lid status.
    """

    unknown = 'unknown'
    closed = 'closed'
    in_between = 'in_between'
    open = 'open'
    max = 'max'


class ModuleType5(Enum):
    thermocyclerModuleType = 'thermocyclerModuleType'


class ModuleModel5(Enum):
    thermocyclerModuleV1 = 'thermocyclerModuleV1'
    thermocyclerModuleV2 = 'thermocyclerModuleV2'


class ThermocyclerModuleData(BaseModel):
    """
    Live data from an attached Thermocycler Module.
    """

    status: TemperatureStatus = Field(
        ..., description='The current heating status of the thermocycler block.'
    )
    currentTemperature: float | None = Field(
        ...,
        description='The current temperature of the thermocycler block, if known, in degrees Celsius.',
        title='Currenttemperature',
    )
    targetTemperature: float | None = Field(
        ...,
        description='The target temperature of the thermocycler block, if set, in degrees Celsius.',
        title='Targettemperature',
    )
    lidStatus: ThermocyclerLidStatus = Field(
        ..., description='The current lid status of the thermocycler.'
    )
    lidTemperatureStatus: TemperatureStatus = Field(
        ..., description='The current heating status of the lid.'
    )
    lidTemperature: float | None = Field(
        ...,
        description='The current temperature of the lid, if known, in degrees Celsius.',
        title='Lidtemperature',
    )
    lidTargetTemperature: float | None = Field(
        ...,
        description='The target temperature of the lid, if set, in degrees Celsius.',
        title='Lidtargettemperature',
    )
    holdTime: float | None = Field(
        ...,
        description='The time left in the current hold step, if any, in seconds.',
        title='Holdtime',
    )
    rampRate: float | None = Field(
        ...,
        description='The current ramp rate for the thermocycler block, if set, in degrees Celsius per second.',
        title='Ramprate',
    )
    currentCycleIndex: int | None = Field(
        ...,
        description='The index of the current cycle within the current sequence, if a cycle is running.',
        title='Currentcycleindex',
    )
    totalCycleCount: int | None = Field(
        ...,
        description='The total number of cycles within the current sequence, if a cycle is running.',
        title='Totalcyclecount',
    )
    currentStepIndex: int | None = Field(
        ...,
        description='The index of the current step within the current step, if a cycle is running.',
        title='Currentstepindex',
    )
    totalStepCount: int | None = Field(
        ...,
        description='The total number of steps within the current cycle, if a cycle is running.',
        title='Totalstepcount',
    )


class TipComparisonMap(BaseModel):
    status: Status3 = Field(
        ...,
        description='The status of this calibration type,dependent on the calibration beinginside or outside of the threshold',
        title='Status',
    )
    comparingTip: ComparisonStatus | None = Field(
        None, description='tip validation step'
    )


class TipData(BaseModel):
    """
    A model for tip length calibration data
    """

    value: float | None = Field(
        ..., description='The tip length of a labware', title='Value'
    )
    lastModified: datetime | None = Field(
        ..., description='When this calibration was last modified', title='Lastmodified'
    )


class SessionType7(Enum):
    tipLengthCalibration = 'tipLengthCalibration'


class ErrorType4(Enum):
    tipPhysicallyAttached = 'tipPhysicallyAttached'


class TipPhysicallyAttachedError(BaseModel):
    """
    Returned when sensors determine that a tip remains on the pipette after a drop attempt.

    The pipette will act as if the tip was not dropped. So, you won't be able to pick
    up a new tip without dropping the current one, and movement commands will assume
    there is a tip hanging off the bottom of the pipette.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(True, title='Isdefined')
    errorType: ErrorType4 = Field(
        'tipPhysicallyAttached', const=True, title='Errortype'
    )
    errorCode: str = Field(..., title='Errorcode')
    detail: str | None = Field('Tip Drop Failed', title='Detail')
    errorInfo: ErrorLocationInfo
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class ErrorType5(Enum):
    tipPhysicallyMissing = 'tipPhysicallyMissing'


class TipPhysicallyMissingError(BaseModel):
    """
    Returned when sensors determine that no tip was physically picked up.

    That space in the tip rack is marked internally as not having any tip,
    as if the tip were consumed by a pickup.

    The pipette will act as if no tip was picked up. So, you won't be able to aspirate
    anything, and movement commands will assume there is no tip hanging off the bottom
    of the pipette.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(True, title='Isdefined')
    errorType: ErrorType5 = Field('tipPhysicallyMissing', const=True, title='Errortype')
    errorCode: str = Field(..., title='Errorcode')
    detail: str | None = Field('No Tip Detected', title='Detail')
    errorInfo: dict[str, Any] = Field(
        ...,
        description='Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n',
        title='Errorinfo',
    )
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class TipPickUpParams(BaseModel):
    """
    Payload used to specify press-tip parameters for a seal command.
    """

    prepDistance: float | None = Field(
        0,
        description='The distance to move down to fit the tips on.',
        title='Prepdistance',
    )
    pressDistance: float | None = Field(
        0, description='The distance to press on tips.', title='Pressdistance'
    )
    ejectorPushMm: float | None = Field(
        0,
        description='The distance to back off to ensure that the tip presence sensors are not triggered.',
        title='Ejectorpushmm',
    )


class TipPosition(BaseModel):
    """
    Properties for tip position reference and relative offset.
    """

    class Config:
        extra = Extra.forbid

    position_reference: PositionReference = Field(
        ..., description='Position reference for tip position.'
    )
    offset: Coordinate = Field(
        ..., description='Relative offset from position reference.'
    )


class TipPresenceStatus(Enum):
    """
    Tip presence status reported by a pipette.
    """

    present = 'present'
    absent = 'absent'
    unknown = 'unknown'


class TipState(BaseModel):
    """
    Information about the tip, if any, currently attached to a pipette.
    """

    hasTip: bool = Field(..., title='Hastip')


class CommandType242(Enum):
    touchTip = 'touchTip'


class TouchTipProperties(BaseModel):
    """
    Shared properties for the touch-tip function.
    """

    class Config:
        extra = Extra.forbid

    enable: bool = Field(
        ..., description='Whether touch-tip is enabled.', title='Enable'
    )
    params: LiquidClassTouchTipParams | None = Field(
        None, description='Parameters for the touch-tip function.', title='Params'
    )


class TouchTipResult(BaseModel):
    """
    Result data from the execution of a TouchTip.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class CommandType244(Enum):
    tryLiquidProbe = 'tryLiquidProbe'


class TryLiquidProbeResult(BaseModel):
    """
    Result data from the execution of a `tryLiquidProbe` command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    z_position: float | SimulatedProbeResult = Field(
        ...,
        description='The Z coordinate, in mm, of the found liquid in deck space. If no liquid was found, `null` or omitted.',
        title='Z Position',
    )


class Id28(Enum):
    UnexpectedFileFormat = 'UnexpectedFileFormat'


class UnexpectedFileFormat(BaseModel):
    """
    An error returned when specified file is not in expected format.
    """

    id: Id28 = Field('UnexpectedFileFormat', const=True, title='Id')
    title: str | None = Field('Unexpected file format', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Kind10(Enum):
    unknown = 'unknown'


class UnknownLabwareOffsetLocationSequenceComponent(BaseModel):
    """
    A labware offset location sequence component from the future.
    """

    kind: Literal['unknown'] = Field(..., const=True, title='Kind')
    storedKind: str = Field(..., title='Storedkind')
    primaryValue: str = Field(..., title='Primaryvalue')


class CommandType246(Enum):
    unsafe_blowOutInPlace = 'unsafe/blowOutInPlace'


class UnsafeBlowOutInPlaceParams(BaseModel):
    """
    Payload required to blow-out in place while position is unknown.
    """

    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class UnsafeBlowOutInPlaceResult(BaseModel):
    """
    Result data from an UnsafeBlowOutInPlace command.
    """


class CommandType248(Enum):
    unsafe_dropTipInPlace = 'unsafe/dropTipInPlace'


class UnsafeDropTipInPlaceParams(BaseModel):
    """
    Payload required to drop a tip in place even if the plunger position is not known.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    homeAfter: bool | None = Field(
        None,
        description="Whether to home this pipette's plunger after dropping the tip. You should normally leave this unspecified to let the robot choose a safe default depending on its hardware.",
        title='Homeafter',
    )


class UnsafeDropTipInPlaceResult(BaseModel):
    """
    Result data from the execution of an UnsafeDropTipInPlace command.
    """


class CommandType250(Enum):
    unsafe_engageAxes = 'unsafe/engageAxes'


class UnsafeEngageAxesParams(BaseModel):
    """
    Payload required for an UnsafeEngageAxes command.
    """

    axes: list[MotorAxis] = Field(
        ..., description='The axes for which to enable.', title='Axes'
    )


class UnsafeEngageAxesResult(BaseModel):
    """
    Result data from the execution of an UnsafeEngageAxes command.
    """


class CommandType252(Enum):
    unsafe_flexStacker_closeLatch = 'unsafe/flexStacker/closeLatch'


class UnsafeFlexStackerCloseLatchParams(BaseModel):
    """
    The parameters defining how a stacker should close its latch.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker', title='Moduleid'
    )


class UnsafeFlexStackerCloseLatchResult(BaseModel):
    """
    Result data from a stacker UnsafeFlexStackerCloseLatch command.
    """


class CommandType254(Enum):
    unsafe_flexStacker_manualRetrieve = 'unsafe/flexStacker/manualRetrieve'


class UnsafeFlexStackerManualRetrieveParams(BaseModel):
    """
    Input parameters for a labware retrieval command.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker.', title='Moduleid'
    )
    labwareId: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Labwareid',
    )
    displayName: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Displayname',
    )
    adapterId: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Adapterid',
    )
    lidId: str | None = Field(
        None,
        description='Do not use. Present for internal backward compatibility.',
        title='Lidid',
    )


class UnsafeFlexStackerManualRetrieveResult(BaseModel):
    """
    Result data from a labware retrieval command.
    """

    labwareId: str = Field(
        ...,
        description='The labware ID of the primary retrieved labware.',
        title='Labwareid',
    )
    adapterId: str | None = Field(
        None,
        description='The optional Adapter Labware ID of the adapter under a primary labware.',
        title='Adapterid',
    )
    lidId: str | None = Field(
        None,
        description='The optional Lid Labware ID of the lid on a primary labware.',
        title='Lidid',
    )
    primaryLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(
        ...,
        description='The origin location of the primary labware.',
        title='Primarylocationsequence',
    )
    lidLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The origin location of the adapter labware under a primary labware.',
        title='Lidlocationsequence',
    )
    adapterLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The origin location of the lid labware on a primary labware.',
        title='Adapterlocationsequence',
    )
    originalPrimaryLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(
        ...,
        description='The original location of the just-retrieved primary labware',
        title='Originalprimarylocationsequence',
    )
    originalAdapterLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The original location of an adapter labware if any',
        title='Originaladapterlocationsequence',
    )
    originalLidLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The original location of a lid labware if any',
        title='Originallidlocationsequence',
    )
    primaryLabwareURI: str = Field(
        ...,
        description='The labware definition URI of the primary labware.',
        title='Primarylabwareuri',
    )
    adapterLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the adapter labware.',
        title='Adapterlabwareuri',
    )
    lidLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the lid labware.',
        title='Lidlabwareuri',
    )


class CommandType256(Enum):
    unsafe_flexStacker_openLatch = 'unsafe/flexStacker/openLatch'


class UnsafeFlexStackerOpenLatchParams(BaseModel):
    """
    The parameters defining how a stacker should open its latch.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker', title='Moduleid'
    )


class UnsafeFlexStackerOpenLatchResult(BaseModel):
    """
    Result data from a stacker UnsafeFlexStackerOpenLatch command.
    """


class CommandType258(Enum):
    unsafe_flexStacker_prepareShuttle = 'unsafe/flexStacker/prepareShuttle'


class UnsafeFlexStackerPrepareShuttleParams(BaseModel):
    """
    The parameters for a UnsafeFlexStackerPrepareShuttle command.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker', title='Moduleid'
    )
    ignoreLatch: bool | None = Field(
        False, description='Ignore the latch state of the shuttle', title='Ignorelatch'
    )


class UnsafeFlexStackerPrepareShuttleResult(BaseModel):
    """
    Result data from a stacker UnsafeFlexStackerPrepareShuttle command.
    """


class CommandType260(Enum):
    unsafe_placeLabware = 'unsafe/placeLabware'


class UnsafePlaceLabwareResult(BaseModel):
    """
    Result data from the execution of an UnsafePlaceLabware command.
    """


class CommandType262(Enum):
    unsafe_ungripLabware = 'unsafe/ungripLabware'


class UnsafeUngripLabwareParams(BaseModel):
    """
    Payload required for an UngripLabware command.
    """


class UnsafeUngripLabwareResult(BaseModel):
    """
    Result data from the execution of an UngripLabware command.
    """


class CommandType264(Enum):
    unsealPipetteFromTip = 'unsealPipetteFromTip'


class UnsealPipetteFromTipResult(BaseModel):
    """
    Result data from the execution of a DropTip command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class CommandType266(Enum):
    unsafe_updatePositionEstimators = 'unsafe/updatePositionEstimators'


class UpdatePositionEstimatorsParams(BaseModel):
    """
    Payload required for an UpdatePositionEstimators command.
    """

    axes: list[MotorAxis] = Field(
        ...,
        description='The axes for which to update the position estimators. Any axes that are not physically present will be ignored.',
        title='Axes',
    )


class UpdatePositionEstimatorsResult(BaseModel):
    """
    Result data from the execution of an UpdatePositionEstimators command.
    """


class UpdateState(Enum):
    """
    The high-level state of an ongoing update.
    """

    queued = 'queued'
    updating = 'updating'
    done = 'done'
    failed = 'failed'


class UsbPort(BaseModel):
    """
    The USB port the module is connected to.
    """

    port: int = Field(
        ...,
        description='The USB port the module is plugged into. If connected via a hub, ``port`` represents the port the hub is plugged into.',
        title='Port',
    )
    portGroup: str = Field(
        ...,
        description='The physical USB port bank the module is plugged into.',
        title='Portgroup',
    )
    hub: bool = Field(
        ..., description='If the module is connected via a USB hub.', title='Hub'
    )
    hubPort: int | None = Field(
        ...,
        description='If the module is connected via a USB hub, the port on the hub the module is plugged into.',
        title='Hubport',
    )
    path: str = Field(
        ..., description='The virtual path of the USB port in the system.', title='Path'
    )


class UserDefinedVolumes(BaseModel):
    heightToVolumeMap: list[HeightVolumePair] = Field(..., title='Heighttovolumemap')


class V1BasicResponse(BaseModel):
    """
    A response with a human readable message
    """

    message: str = Field(..., description='A human-readable message', title='Message')


class ValidationError(BaseModel):
    loc: list[str | int] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class Vec3f(BaseModel):
    """
    A 3D vector of floats.
    """

    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')
    z: float = Field(..., title='Z')


class Vector2D(BaseModel):
    x: float = Field(..., title='X')
    y: float = Field(..., title='Y')


class Vector3D(BaseModel):
    x: int | float = Field(..., title='X')
    y: int | float = Field(..., title='Y')
    z: int | float = Field(..., title='Z')


class CommandType268(Enum):
    verifyTipPresence = 'verifyTipPresence'


class VerifyTipPresenceParams(BaseModel):
    """
    Payload required for a VerifyTipPresence command.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    expectedState: TipPresenceStatus = Field(
        ..., description='The expected tip presence status on the pipette.'
    )
    followSingularSensor: InstrumentSensorId | None = Field(
        None,
        description='The sensor id to follow if the other can be ignored.',
        title='Followsingularsensor',
    )


class VerifyTipPresenceResult(BaseModel):
    """
    Result data from the execution of a VerifyTipPresence command.
    """


class CommandType270(Enum):
    thermocycler_waitForBlockTemperature = 'thermocycler/waitForBlockTemperature'


class WaitForBlockTemperatureParams(BaseModel):
    """
    Input parameters to wait for Thermocycler's target block temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler Module.', title='Moduleid'
    )


class WaitForBlockTemperatureResult(BaseModel):
    """
    Result data from wait for Thermocycler's target block temperature.
    """


class CommandType272(Enum):
    waitForDuration = 'waitForDuration'


class WaitForDurationParams(BaseModel):
    """
    Payload required to pause the protocol.
    """

    seconds: float = Field(
        ..., description='Duration, in seconds, to wait for.', title='Seconds'
    )
    message: str | None = Field(
        None,
        description='A user-facing message associated with the pause',
        title='Message',
    )


class WaitForDurationResult(BaseModel):
    """
    Result data from the execution of a wait for duration command.
    """


class CommandType274(Enum):
    thermocycler_waitForLidTemperature = 'thermocycler/waitForLidTemperature'


class WaitForLidTemperatureParams(BaseModel):
    """
    Input parameters to wait for Thermocycler's lid temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler Module.', title='Moduleid'
    )


class WaitForLidTemperatureResult(BaseModel):
    """
    Result data from wait for Thermocycler's lid temperature.
    """


class CommandType276(Enum):
    waitForResume = 'waitForResume'
    pause = 'pause'


class WaitForResumeParams(BaseModel):
    """
    Payload required to pause the protocol.
    """

    message: str | None = Field(
        None,
        description='A user-facing message associated with the pause',
        title='Message',
    )


class WaitForResumeResult(BaseModel):
    """
    Result data from the execution of a WaitForResume command.
    """


class WellOffset(BaseModel):
    """
    An offset vector in (x, y, z).
    """

    x: float | None = Field(0, title='X')
    y: float | None = Field(0, title='Y')
    z: float | None = Field(0, title='Z')


class WellOrigin(Enum):
    """
    Origin of WellLocation offset.

    Props:
        TOP: the top-center of the well
        BOTTOM: the bottom-center of the well
        CENTER: the middle-center of the well
        MENISCUS: the meniscus-center of the well
    """

    top = 'top'
    bottom = 'bottom'
    center_ = 'center'
    meniscus = 'meniscus'


class WifiConfiguration(BaseModel):
    ssid: str = Field(
        ...,
        description="The SSID to connect to. If this isn't an SSID that is being broadcast by a network, you should also set `hidden` to `true`.",
        title='Ssid',
    )
    hidden: bool | None = Field(
        False,
        description='`true` if the network is hidden (not broadcasting an SSID). `false` (default if key is not present) otherwise.',
        title='Hidden',
    )
    securityType: NetworkingSecurityType | None = None
    psk: SecretStr | None = Field(
        None,
        description='If this is a PSK-secured network (`securityType` is `"wpa-psk"`), the PSK',
        title='Psk',
    )
    eapConfig: dict[str, str] | None = Field(
        None,
        description='All options required to configure EAP access to the Wi-Fi. All options should match one of the cases described in `/wifi/eap-options`; for instance, configuring for peap/mschapv2 should have `"peap/mschapv2"` as the `eapType`; it should have `"identity"` and `"password"` props, both of which are identified as mandatory in `/wifi/eap-options`; and it may also have `"anonymousIdentity"` and `"caCert"` properties, both of which are identified as present but not required.',
        title='Eapconfig',
    )


class WifiConfigurationResponse(BaseModel):
    """
    The OT-2 successfully connected to the specified network using the
    specified parameters
    """

    message: str = Field(
        ..., description='A human-readable success message', title='Message'
    )
    ssid: str = Field(..., description='The SSID configured', title='Ssid')


class WifiKeyFile(BaseModel):
    """
    Wifi Key File
    """

    uri: str = Field(
        ...,
        description='A URI for the key (mostly for use with DELETE /wifi/keys/{key_id})',
        title='Uri',
    )
    id: str = Field(
        ...,
        description='A contents hash of the key used to specify the key in POST /wifi/configure (and also to determine the key URI)',
        title='Id',
    )
    name: str = Field(..., description='The original filename of the key', title='Name')


class WifiKeyFiles(BaseModel):
    """
    The list of key files
    """

    keys: list[WifiKeyFile] | None = Field(
        default_factory=list, description='A list of keys in the system', title='Keys'
    )


class WifiNetwork(BaseModel):
    """
    Identifier of a wifi network
    """

    ssid: str = Field(..., description="The network's SSID", title='Ssid')


class WifiNetworkFull(BaseModel):
    """
    A visible Network
    """

    ssid: str = Field(..., description="The network's SSID", title='Ssid')
    signal: int = Field(
        ...,
        description='A unitless signal strength; a higher number is a better signal',
        title='Signal',
    )
    active: bool = Field(
        ..., description='Whether there is a connection active', title='Active'
    )
    security: str = Field(
        ...,
        description='The raw NetworkManager output about the Wi-Fi security',
        title='Security',
    )
    securityType: NetworkingSecurityType


class WifiNetworks(BaseModel):
    """
    The list of networks
    """

    list: list[WifiNetworkFull] = Field(..., title='List')


class FieldNoParams(BaseModel):
    pass


class OpentronsCalibrationStorageTypesCalibrationStatus(BaseModel):
    markedBad: bool | None = Field(False, title='Markedbad')
    source: SourceType | None = None
    markedAt: datetime | None = Field(None, title='Markedat')


class CommandType278(Enum):
    absorbanceReader_closeLid = 'absorbanceReader/closeLid'


class OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidParams(BaseModel):
    """
    Input parameters to close the lid on an absorbance reading.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the absorbance reader.', title='Moduleid'
    )


class OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidResult(BaseModel):
    """
    Result data from closing the lid on an aborbance reading.
    """


class CommandType280(Enum):
    absorbanceReader_openLid = 'absorbanceReader/openLid'


class OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidParams(BaseModel):
    """
    Input parameters to open the lid on an absorbance reading.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the absorbance reader.', title='Moduleid'
    )


class OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidResult(BaseModel):
    """
    Result data from opening the lid on an aborbance reading.
    """


class OpentronsProtocolEngineCommandsCommandCommandStatus(Enum):
    """
    Command execution status.
    """

    queued = 'queued'
    running = 'running'
    succeeded = 'succeeded'
    failed = 'failed'


class CommandType282(Enum):
    heaterShaker_setTargetTemperature = 'heaterShaker/setTargetTemperature'


class OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureParams(
    BaseModel
):
    """
    Input parameters to set a Heater-Shaker's target temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )
    celsius: float = Field(
        ..., description='Target temperature in °C.', title='Celsius'
    )


class OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureResult(
    BaseModel
):
    """
    Result data from setting a Heater-Shaker's target temperature.
    """


class CommandType284(Enum):
    heaterShaker_waitForTemperature = 'heaterShaker/waitForTemperature'


class OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureParams(
    BaseModel
):
    """
    Input parameters to wait for a Heater-Shaker's target temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Heater-Shaker Module.', title='Moduleid'
    )
    celsius: float | None = Field(
        None,
        description="Target temperature in °C. If not specified, will default to the module's target temperature. Specifying a celsius parameter other than the target temperature could lead to unpredictable behavior and hence is not recommended for use. This parameter can be removed in a future version without prior notice.",
        title='Celsius',
    )


class OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureResult(
    BaseModel
):
    """
    Result data from waiting for a Heater-Shaker's target temperature.
    """


class OpentronsProtocolEngineCommandsMoveLabwareErrorDetails(BaseModel):
    """
    Location details for a failed gripper move.
    """

    originLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(..., title='Originlocationsequence')
    immediateDestinationLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(..., title='Immediatedestinationlocationsequence')
    eventualDestinationLocationSequence: list[
        OnLabwareLocationSequenceComponent
        | OnModuleLocationSequenceComponent
        | OnAddressableAreaLocationSequenceComponent
        | NotOnDeckLocationSequenceComponent
        | OnCutoutFixtureLocationSequenceComponent
        | InStackerHopperLocation
    ] = Field(..., title='Eventualdestinationlocationsequence')


class CommandType286(Enum):
    temperatureModule_setTargetTemperature = 'temperatureModule/setTargetTemperature'


class OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureParams(
    BaseModel
):
    """
    Input parameters to set a Temperature Module's target temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Temperature Module.', title='Moduleid'
    )
    celsius: float = Field(
        ..., description='Target temperature in °C.', title='Celsius'
    )


class OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureResult(
    BaseModel
):
    """
    Result data from setting a Temperature Module's target temperature.
    """

    targetTemperature: float = Field(
        ...,
        description='The target temperature that was set after validation and type conversion (if any).',
        title='Targettemperature',
    )


class CommandType288(Enum):
    temperatureModule_waitForTemperature = 'temperatureModule/waitForTemperature'


class OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureParams(
    BaseModel
):
    """
    Input parameters to wait for a Temperature Module's target temperature.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Temperature Module.', title='Moduleid'
    )
    celsius: float | None = Field(
        None,
        description="Target temperature in °C. If not specified, will default to the module's target temperature. Specifying a celsius parameter other than the target temperature could lead to unpredictable behavior and hence is not recommended for use. This parameter can be removed in a future version without prior notice.",
        title='Celsius',
    )


class OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureResult(
    BaseModel
):
    """
    Result data from waiting for a Temperature Module's target temperature.
    """


class CommandType290(Enum):
    thermocycler_closeLid = 'thermocycler/closeLid'


class OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidParams(BaseModel):
    """
    Input parameters to close a Thermocycler's lid.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler.', title='Moduleid'
    )


class OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidResult(BaseModel):
    """
    Result data from closing a Thermocycler's lid.
    """


class CommandType292(Enum):
    thermocycler_openLid = 'thermocycler/openLid'


class OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidParams(BaseModel):
    """
    Input parameters to open a Thermocycler's lid.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler.', title='Moduleid'
    )


class OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidResult(BaseModel):
    """
    Result data from opening a Thermocycler's lid.
    """


class OpentronsTypesMountType(Enum):
    left = 'left'
    right = 'right'
    extension = 'extension'


class DisplayVolumeUnits(Enum):
    µL = 'µL'
    mL = 'mL'
    L = 'L'


class OpentronsSharedDataLabwareLabwareDefinitionMetadata(BaseModel):
    displayName: str = Field(..., title='Displayname')
    displayCategory: DisplayCategory
    displayVolumeUnits: DisplayVolumeUnits = Field(..., title='Displayvolumeunits')
    tags: list[str] | None = Field(None, title='Tags')


class Id29(Enum):
    StatelessCommandNotFound = 'StatelessCommandNotFound'


class RobotServerCommandsRouterCommandNotFound(BaseModel):
    """
    An error returned if the given command cannot be found.
    """

    id: Id29 = Field('StatelessCommandNotFound', const=True, title='Id')
    title: str | None = Field('Stateless Command Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4000', title='Errorcode')


class RobotServerErrorsErrorResponsesErrorBodyCommandNotFound3(BaseModel):
    errors: list[RobotServerCommandsRouterCommandNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerErrorsErrorResponsesErrorDetails(BaseModel):
    """
    An error response with error type and occurrence details.

    Extend this class to create specific error responses, and use it in your
    route handlers.

    Example:
        from fastapi import status
        from typing_extensions import Literal
        from robot_server.errors.error_responses import ErrorResponse, ErrorDetails

        class BadRequest(ErrorDetails):
            id: Literal["BadRequest"] = "BadRequest"
            title: str = "Bad Request"

        # ...

        @router.get(
            path="/some/path",
            response_model=SomeModel,
            responses={
                status.HTTP_400_BAD_REQUEST: {"model": ErrorResponse[BadRequest]},
            }
        )
        def get_some_model():
            # ...
            raise BadRequest.as_error(status.HTTP_400_BAD_REQUEST)
    """

    id: str = Field(
        ..., description='A unique identifier for this type of error.', title='Id'
    )
    title: str = Field(
        ...,
        description='A short, human readable name for this type of error',
        title='Title',
    )
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id30(Enum):
    RunNotFound = 'RunNotFound'


class RobotServerMaintenanceRunsRouterBaseRouterRunNotFound(BaseModel):
    """
    An error if a given run is not found.
    """

    id: Id30 = Field('RunNotFound', const=True, title='Id')
    title: str | None = Field('Run Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id31(Enum):
    RunNotIdle = 'RunNotIdle'


class RobotServerMaintenanceRunsRouterBaseRouterRunNotIdle(BaseModel):
    """
    An error if one tries to delete a run that is not idle.
    """

    id: Id31 = Field('RunNotIdle', const=True, title='Id')
    title: str | None = Field('Run is not idle.', title='Title')
    detail: str | None = Field(
        'Run is currently active. Allow the run to finish or stop it with a `stop` action before attempting to modify it.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id32(Enum):
    CommandNotAllowed = 'CommandNotAllowed'


class RobotServerMaintenanceRunsRouterCommandsRouterCommandNotAllowed(BaseModel):
    """
    An error if a given run command is not allowed.
    """

    id: Id32 = Field('CommandNotAllowed', const=True, title='Id')
    title: str | None = Field('Setup Command Not Allowed', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id33(Enum):
    CommandNotFound = 'CommandNotFound'


class RobotServerMaintenanceRunsRouterCommandsRouterCommandNotFound(BaseModel):
    """
    An error if a given run command is not found.
    """

    id: Id33 = Field('CommandNotFound', const=True, title='Id')
    title: str | None = Field('Run Command Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class RobotServerProtocolsProtocolModelsMetadata(BaseModel):
    """
    Extra, nonessential information about the protocol.

    This can include data like:

    * A human-readable title and description.
    * A last-modified date.
    * A list of authors.

    Metadata may contain fields other than those explicitly
    listed in this schema.

    The metadata *should not* include information needed
    to run the protocol correctly. For historical reasons, Python
    protocols define their `apiLevel` inside their metadata, but
    this should be considered an exception to the rule.
    """

    class Config:
        extra = Extra.allow


class RobotServerRobotCalibrationCheckModelsSessionCreateParams(BaseModel):
    """
    Calibration Health Check create params
    """

    hasCalibrationBlock: bool | None = Field(
        False,
        description='Whether to use a calibration block in thecalibration health check flow.',
        title='Hascalibrationblock',
    )
    tipRacks: list[dict[str, Any]] | None = Field(
        [],
        description='A list of labware definitions to use incalibration health check',
        title='Tipracks',
    )


class RobotServerRobotCalibrationHelperClassesAttachedPipette(BaseModel):
    """
    Pipette (if any) attached to the mount
    """

    model: str | None = Field(
        None,
        description='The model of the attached pipette. These are snake case as in the Protocol API. This includes the full version string',
        title='Model',
    )
    name: str | None = Field(
        None,
        description='Short name of pipette model withoutgeneration version',
        title='Name',
    )
    tipLength: float | None = Field(
        None, description='The default tip length for this pipette', title='Tiplength'
    )
    mount: str | None = Field(
        None, description='The mount this pipette attached to', title='Mount'
    )
    serial: str | None = Field(
        None, description='The serial number of the attached pipette', title='Serial'
    )
    defaultTipracks: list[dict[str, Any]] | None = Field(
        None,
        description='A list of default tipracks for this pipette',
        title='Defaulttipracks',
    )


class RobotServerRobotCalibrationModelsSessionCreateParams(BaseModel):
    """
    The parameters required to start the following types of sessions;
    1. Tip Length Calibration
    2. Pipette Offset Calibration
    3. Tip Length Calibration + Pipette Offset Calibration
    """

    mount: str = Field(
        ...,
        description='The mount on which the pipette is attached, left or right',
        title='Mount',
    )
    hasCalibrationBlock: bool | None = Field(
        False,
        description='Whether to use a calibration block in theinstance of TLC + pipette offset flow. If no tip length is performed, this is ignored, but it should always be specified.',
        title='Hascalibrationblock',
    )
    tipRackDefinition: dict[str, Any] | None = Field(
        None,
        description='The full labware definition of the tip rack to calibrate. If not specified, then a default will be used - either the same tiprack as in the current calibration, or, if there is no calibration, the default Opentrons tiprack for this pipette.',
        title='Tiprackdefinition',
    )
    shouldRecalibrateTipLength: bool | None = Field(
        True,
        description='whether to perform TLC with the loaded tip rack, prior to recalibrating the pipette offset. If the tiprack used (either the one specified by tipRackDefinition or the default if not specified) does not have a tip length calibration, this will be forced to be true.',
        title='Shouldrecalibratetiplength',
    )


class Id34(Enum):
    RunNotFound = 'RunNotFound'


class RobotServerRunsRouterBaseRouterRunNotFound(BaseModel):
    """
    An error if a given run is not found.
    """

    id: Id34 = Field('RunNotFound', const=True, title='Id')
    title: str | None = Field('Run Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4000', title='Errorcode')


class Id35(Enum):
    RunNotIdle = 'RunNotIdle'


class RobotServerRunsRouterBaseRouterRunNotIdle(BaseModel):
    """
    An error if one tries to delete a run that is not idle.
    """

    id: Id35 = Field('RunNotIdle', const=True, title='Id')
    title: str | None = Field('Run is not idle.', title='Title')
    detail: str | None = Field(
        'Run is currently active. Allow the run to finish or stop it with a `stop` action before attempting to modify it.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field('4001', title='Errorcode')


class Id36(Enum):
    CommandNotAllowed = 'CommandNotAllowed'


class RobotServerRunsRouterCommandsRouterCommandNotAllowed(BaseModel):
    """
    An error if a given run command is not allowed.
    """

    id: Id36 = Field('CommandNotAllowed', const=True, title='Id')
    title: str | None = Field('Command Not Allowed', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class Id37(Enum):
    CommandNotFound = 'CommandNotFound'


class RobotServerRunsRouterCommandsRouterCommandNotFound(BaseModel):
    """
    An error if a given run command is not found.
    """

    id: Id37 = Field('CommandNotFound', const=True, title='Id')
    title: str | None = Field('Run Command Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class RobotServerServiceLegacyModelsPipettesAttachedPipette(BaseModel):
    """
    Pipette (if any) attached to the mount
    """

    model: str | None = Field(
        ...,
        description='The model of the attached pipette. These are snake case as in the Protocol API. This includes the full version string',
        title='Model',
    )
    name: str | None = Field(
        ...,
        description='The name of the attached pipette - the model without the version string',
        title='Name',
    )
    tip_length: float | None = Field(
        ...,
        description='The default tip length for this pipette, if attached',
        title='Tip Length',
    )
    mount_axis: str = Field(
        ...,
        description='The axis that moves this pipette up and down',
        title='Mount Axis',
    )
    plunger_axis: str = Field(
        ...,
        description="The axis that moves this pipette's plunger",
        title='Plunger Axis',
    )
    id: str | None = Field(
        ..., description='The serial number of the attached pipette', title='Id'
    )


class RobotServerServicePipetteOffsetModelsMountType(Enum):
    """
    Pipette mount type
    """

    left = 'left'
    right = 'right'


class RobotServerServiceSessionModelsCommandCommandStatus(Enum):
    """
    The command status.
    """

    executed = 'executed'
    queued = 'queued'
    failed = 'failed'


class RobotServerServiceSharedModelsCalibrationCalibrationStatus(BaseModel):
    """
    A model describing whether a calibration on the robot is valid
    or not. This should be used for all calibration data models.
    """

    markedBad: bool = Field(
        ..., description='Whether a calibration is invalid or not', title='Markedbad'
    )
    source: SourceType | None = Field(
        None, description='The source that marked the calibration bad.'
    )
    markedAt: datetime | None = Field(
        None, description='The time the calibration was marked bad.', title='Markedat'
    )


class AbsorbanceReaderModuleData(BaseModel):
    """
    Live data from an Absorbance Reader module.
    """

    status: AbsorbanceReaderStatus = Field(
        ..., description='Overall status of the module.'
    )
    lidStatus: AbsorbanceReaderLidStatus = Field(..., description='Lid status.')
    platePresence: AbsorbanceReaderPlatePresence = Field(
        ..., description='Plate presence status.'
    )
    measureMode: str = Field(
        ...,
        description='The measirement mode (single or multi) the device is configured for.',
        title='Measuremode',
    )
    sampleWavelengths: list[int] = Field(
        ...,
        description='The current list of sample wavelengths, in nanometers.',
        title='Samplewavelengths',
    )
    referenceWavelength: int | None = Field(
        ...,
        description='The reference wavelength used for single measurement mode.',
        title='Referencewavelength',
    )


class ActiveNozzleLayout(BaseModel):
    """
    Details about the active nozzle layout for a pipette used in the current run.
    """

    startingNozzle: str = Field(
        ...,
        description='The nozzle used when issuing pipette commands.',
        title='Startingnozzle',
    )
    activeNozzles: list[str] = Field(
        ...,
        description='A map of all the pipette nozzles active in the current configuration.',
        title='Activenozzles',
    )
    config: NozzleLayoutConfig = Field(
        ..., description='The active nozzle configuration.'
    )


class AdvancedSettingsResponse(BaseModel):
    """
    A dump of advanced settings and suitable links for next action
    """

    settings: list[AdvancedSetting] = Field(..., title='Settings')
    links: Links


class AirGapInPlace(BaseModel):
    """
    AirGapInPlace command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['airGapInPlace'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: AirGapInPlaceParams
    result: AirGapInPlaceResult | None = None
    error: OverpressureError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class AirGapInPlaceCreate(BaseModel):
    """
    AirGapInPlace command request model.
    """

    commandType: Literal['airGapInPlace'] = Field(..., const=True, title='Commandtype')
    params: AirGapInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class AllRunsLinks(BaseModel):
    """
    Links returned along with a collection of runs.
    """

    current: ResourceLink | None = Field(
        None, description='Path to the currently active run, if a run is active.'
    )


class AnalysisNotFound(BaseModel):
    """
    An error returned when a given protocol analysis cannot be found.
    """

    id: Id = Field('AnalysisNotFound', const=True, title='Id')
    title: str | None = Field('Protocol Analysis Not Found', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class AspirateInPlace(BaseModel):
    """
    AspirateInPlace command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['aspirateInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: AspirateInPlaceParams
    result: AspirateInPlaceResult | None = None
    error: OverpressureError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class AspirateInPlaceCreate(BaseModel):
    """
    AspirateInPlace command request model.
    """

    commandType: Literal['aspirateInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: AspirateInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class AspirateResult(BaseModel):
    """
    Result data from execution of an Aspirate command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class AspirateWhileTrackingResult(BaseModel):
    """
    Result data from execution of an Aspirate command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    volume: float = Field(
        ...,
        description='Amount of liquid in uL handled in the operation.',
        ge=0.0,
        title='Volume',
    )


class AttachTip(BaseModel):
    target: MotionTarget
    point: list[float] = Field(
        ...,
        description='A point in deck coordinates (x, y, z)',
        max_items=3,
        min_items=3,
        title='Point',
    )


class Axes(BaseModel):
    """
    A list of motor axes to disengage
    """

    axes: list[MotorName] = Field(..., title='Axes')


class AxisAlignedBoundingBox3D(BaseModel):
    backLeftBottom: Vector3D
    frontRightTop: Vector3D


class BadGripper(BaseModel):
    """
    Represents a gripper that is physically connected but not ready to operate.
    """

    subsystem: SubSystem = Field(
        ..., description='The hardware subsystem for this instrument'
    )
    status: str = Field(
        ...,
        description='A route on this server to more information about the status of the hardware',
        title='Status',
    )
    update: str = Field(
        ...,
        description='A route on this server to begin an update of the instrument',
        title='Update',
    )
    ok: Ok = Field(
        False,
        const=True,
        description='If the instrument is not OK, a previous update was interrupted. It must be updated again.',
        title='Ok',
    )
    instrumentType: InstrumentType = Field(
        'gripper', const=True, title='Instrumenttype'
    )


class BadPipette(BaseModel):
    """
    Represents a pipette that is physically connected but not ready to operate.
    """

    subsystem: SubSystem = Field(
        ..., description='The hardware subsystem for this instrument'
    )
    status: str = Field(
        ...,
        description='A route on this server to more information about the status of the hardware',
        title='Status',
    )
    update: str = Field(
        ...,
        description='A route on this server to begin an update of the instrument',
        title='Update',
    )
    ok: bool | Any = Field(
        False,
        description='If False, a previous update was interrupted.',
        title='Ok',
    )
    instrumentType: Literal['pipette'] | Any = Field(
        'pipette', title='Instrumenttype'
    )


class BlowOutInPlace(BaseModel):
    """
    BlowOutInPlace command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['blowOutInPlace'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: BlowOutInPlaceParams
    result: BlowOutInPlaceResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class BlowOutInPlaceCreate(BaseModel):
    """
    BlowOutInPlace command request model.
    """

    commandType: Literal['blowOutInPlace'] = Field(..., const=True, title='Commandtype')
    params: BlowOutInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class BlowOutResult(BaseModel):
    """
    Result data from the execution of a blow-out command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )


class BodyCreateProtocolProtocolsPost(BaseModel):
    files: list[bytes] = Field(..., title='Files')
    key: str | None = Field(
        None,
        description="An arbitrary client-defined string to attach to the new protocol resource. This should be no longer than ~100 characters or so. It's intended to store something like a UUID, to help clients that store protocols locally keep track of which local files correspond to which protocol resources on the robot.",
        title='Key',
    )
    run_time_parameter_values: str | None = Field(
        None,
        description='Key-value pairs of run-time parameters defined in a protocol. Note that this is expected to be a string holding a JSON object. Also, if this data is included in the request, the server will always trigger an analysis (for now).',
        title='Run Time Parameter Values',
    )
    protocol_kind: ProtocolKind | None = Field(
        'standard',
        description='Whether this is a `standard` protocol or a `quick-transfer` protocol.if omitted, the protocol will be `standard` by default.',
    )
    run_time_parameter_files: str | None = Field(
        None,
        description='Param-file pairs of CSV run-time parameters defined in the protocol.',
        title='Run Time Parameter Files',
    )


class CSVParameter(BaseModel):
    """
    A CSV file parameter defined in a protocol.
    """

    displayName: str = Field(
        ..., description='Display string for the parameter.', title='Displayname'
    )
    variableName: str = Field(
        ..., description='Python variable name of the parameter.', title='Variablename'
    )
    description: str | None = Field(
        None, description='Detailed description of the parameter.', title='Description'
    )
    suffix: str | None = Field(
        None,
        description='Units (like mL, mm/sec, etc) or a custom suffix for the parameter.',
        title='Suffix',
    )
    type: Type1 = Field(
        'csv_file',
        const=True,
        description='String specifying the type of this parameter',
        title='Type',
    )
    file: FileInfo | None = Field(
        None,
        description='ID of the CSV file stored on the robot; to be used for fetching the CSV file. For local analysis this will most likely be empty.',
    )


class CalibrateGripperParams(BaseModel):
    """
    Parameters for a `calibrateGripper` command.
    """

    jaw: CalibrateGripperParamsJaw = Field(
        ...,
        description="Which of the gripper's jaws to use to measure its offset. The robot will assume that a human operator has already attached the capacitive probe to the jaw and none is attached to the other jaw.",
    )
    otherJawOffset: Vec3f | None = Field(
        None,
        description='If an offset for the other probe is already found, then specifying it here will enable the CalibrateGripper command to complete the calibration process by calculating the total offset and saving it to disk. If this param is not specified then the command will only find and return the offset for the specified probe.',
        title='Otherjawoffset',
    )


class CalibrateModuleParams(BaseModel):
    """
    Payload required to calibrate-module.
    """

    moduleId: str = Field(
        ..., description='The unique id of module to calibrate.', title='Moduleid'
    )
    labwareId: str = Field(
        ...,
        description='The unique id of module calibration adapter labware.',
        title='Labwareid',
    )
    mount: OpentronsTypesMountType = Field(
        ..., description='The instrument mount used to calibrate the module.'
    )


class CalibratePipetteParams(BaseModel):
    """
    Payload required to calibrate-pipette.
    """

    mount: OpentronsTypesMountType = Field(
        ..., description='Instrument mount to calibrate.'
    )


class CalibratePipetteResult(BaseModel):
    """
    Result data from the execution of a calibrate-pipette command.
    """

    pipetteOffset: InstrumentOffsetVector = Field(
        ..., description='Offset of calibrated pipette.'
    )


class CalibrationCheckCreateAttributes(BaseModel):
    """
    The calibration check create request.
    """

    sessionType: SessionType = Field(
        'calibrationCheck', const=True, title='Sessiontype'
    )
    createParams: RobotServerRobotCalibrationCheckModelsSessionCreateParams


class CalibrationData(BaseModel):
    """
    A model for labware calibration data
    """

    offset: OffsetData = Field(..., description='An array of XYZ offset data.')
    tipLength: TipData = Field(
        ..., description='The tip length of a labware, if relevant.'
    )


class ChangePipette(BaseModel):
    target: MotionTarget
    left: list[float] = Field(
        ...,
        description='A point in deck coordinates (x, y, z)',
        max_items=3,
        min_items=3,
        title='Left',
    )
    right: list[float] = Field(
        ...,
        description='A point in deck coordinates (x, y, z)',
        max_items=3,
        min_items=3,
        title='Right',
    )


class ClientDataKeyDoesNotExist(BaseModel):
    """
    An error returned if trying to access a client data key that doesn't exist.
    """

    id: Id1 = Field('ClientDataKeyDoesNotExist', const=True, title='Id')
    title: str | None = Field('Client Data Key Does Not Exist', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class CloseGripperJaw(BaseModel):
    """
    CloseGripperJaw command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['robot/closeGripperJaw'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CloseGripperJawParams
    result: CloseGripperJawResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CloseGripperJawCreate(BaseModel):
    """
    CloseGripperJaw command request model.
    """

    commandType: Literal['robot/closeGripperJaw'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: CloseGripperJawParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class CloseLabwareLatch(BaseModel):
    """
    A command to close a Heater-Shaker's latch.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/closeLabwareLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CloseLabwareLatchParams
    result: CloseLabwareLatchResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CloseLabwareLatchCreate(BaseModel):
    """
    A request to create a Heater-Shaker's close latch command.
    """

    commandType: Literal['heaterShaker/closeLabwareLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: CloseLabwareLatchParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class CommandLink(BaseModel):
    """
    A link to a command resource.
    """

    href: str = Field(..., description='The HTTP API path to the command', title='Href')
    meta: CommandLinkMeta = Field(..., description='Information about the command.')


class CommandMatcher(BaseModel):
    """
    Command/error data used for matching rules.
    """

    commandType: str = Field(
        ...,
        description='The command type that this rule applies to.',
        title='Commandtype',
    )
    error: ErrorMatcher = Field(
        ..., description='The error details that this rule applies to.'
    )


class Comment(BaseModel):
    """
    Comment command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['comment'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CommentParams
    result: CommentResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CommentCreate(BaseModel):
    """
    Comment command request model.
    """

    commandType: Literal['comment'] = Field(..., const=True, title='Commandtype')
    params: CommentParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class ComparisonStatePerCalibration(BaseModel):
    tipLength: TipComparisonMap | None = None
    pipetteOffset: PipetteOffsetComparisonMap | None = None
    deck: DeckComparisonMap | None = None


class ComparisonStatePerPipette(BaseModel):
    first: ComparisonStatePerCalibration
    second: ComparisonStatePerCalibration


class ConfigureForVolume(BaseModel):
    """
    Configure for volume command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['configureForVolume'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: ConfigureForVolumeParams
    result: ConfigureForVolumeResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class ConfigureForVolumeCreate(BaseModel):
    """
    Configure for volume command creation request model.
    """

    commandType: Literal['configureForVolume'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: ConfigureForVolumeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class ConfigureNozzleLayoutParams(BaseModel):
    """
    Parameters required to configure the nozzle layout for a specific pipette.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    configurationParams: (
        AllNozzleLayoutConfiguration
        | SingleNozzleLayoutConfiguration
        | RowNozzleLayoutConfiguration
        | ColumnNozzleLayoutConfiguration
        | QuadrantNozzleLayoutConfiguration
    ) = Field(..., title='Configurationparams')


class Custom(BaseModel):
    """
    Custom command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['custom'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CustomParams
    result: CustomResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CustomCreate(BaseModel):
    """
    A request to create a custom command.
    """

    commandType: Literal['custom'] = Field(..., const=True, title='Commandtype')
    params: CustomParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DataFile(BaseModel):
    """
    A model representing a data file.
    """

    id: str = Field(..., description='A unique identifier for this file.', title='Id')
    name: str = Field(..., description='Name of the data file.', title='Name')
    source: DataFileSource = Field(
        ..., description='The origin of the file (uploaded or generated)'
    )
    createdAt: datetime = Field(
        ...,
        description='When this data file was uploaded or generated..',
        title='Createdat',
    )


class DataFileInUse(BaseModel):
    """
    And error returned when attempting to delete a file that is still in use.
    """

    id: Id2 = Field('DataFileInUse', const=True, title='Id')
    title: str | None = Field('Data file is in use', title='Title')
    detail: str = Field(
        ...,
        description='A human-readable message describing this specific occurrence of the error.',
        title='Detail',
    )
    source: ErrorSource | None = Field(
        None, description='An object containing references to the source of the error.'
    )
    meta: dict[str, Any] | None = Field(
        None,
        description='An object containing non-standard information about this occurrence of the error',
        title='Meta',
    )
    errorCode: str | None = Field(
        '4000',
        description='The Opentrons error code associated with the error',
        title='Errorcode',
    )


class DeactivateBlock(BaseModel):
    """
    A command to unset a Thermocycler's target block temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/deactivateBlock'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DeactivateBlockParams
    result: DeactivateBlockResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DeactivateBlockCreate(BaseModel):
    """
    A request to create a Thermocycler's deactivate block command.
    """

    commandType: Literal['thermocycler/deactivateBlock'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DeactivateBlockParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DeactivateHeater(BaseModel):
    """
    A command to unset a Heater-Shaker's target temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/deactivateHeater'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DeactivateHeaterParams
    result: DeactivateHeaterResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DeactivateHeaterCreate(BaseModel):
    """
    A request to create a Heater-Shaker's deactivate heater command.
    """

    commandType: Literal['heaterShaker/deactivateHeater'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DeactivateHeaterParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DeactivateLid(BaseModel):
    """
    A command to unset a Thermocycler's target lid temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/deactivateLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DeactivateLidParams
    result: DeactivateLidResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DeactivateLidCreate(BaseModel):
    """
    A request to create a Thermocycler's deactivate lid command.
    """

    commandType: Literal['thermocycler/deactivateLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DeactivateLidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DeactivateShaker(BaseModel):
    """
    A command to deactivate shaker for a Heater-Shaker.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/deactivateShaker'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DeactivateShakerParams
    result: DeactivateShakerResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DeactivateShakerCreate(BaseModel):
    """
    A request to create a Heater-Shaker's deactivate shaker command.
    """

    commandType: Literal['heaterShaker/deactivateShaker'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DeactivateShakerParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DeactivateTemperature(BaseModel):
    """
    A command to deactivate a Temperature Module.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['temperatureModule/deactivate'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DeactivateTemperatureParams
    result: DeactivateTemperatureResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DeactivateTemperatureCreate(BaseModel):
    """
    A request to deactivate a Temperature Module.
    """

    commandType: Literal['temperatureModule/deactivate'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DeactivateTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DeckCalibrationCreateAttributes(BaseModel):
    """
    The deck calibration create request.
    """

    sessionType: SessionType2 = Field(
        'deckCalibration', const=True, title='Sessiontype'
    )
    createParams: FieldNoParams | None = None


class DeckCalibrationData(BaseModel):
    type: MatrixType = Field(
        ..., description='The type of deck calibration matrix: affine or attitude'
    )
    matrix: list[list[float]] = Field(
        ..., description='The deck calibration transform matrix', title='Matrix'
    )
    lastModified: datetime | None = Field(
        None,
        description='When this calibration was last modified',
        title='Lastmodified',
    )
    pipetteCalibratedWith: str | None = Field(
        None,
        description='The ID of the pipette used in this calibration',
        title='Pipettecalibratedwith',
    )
    tiprack: str | None = Field(
        None,
        deprecated=True,
        description='A hash of the labware definition of the tip rack that was used in this calibration. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes.',
        title='Tiprack',
    )
    source: SourceType | None = Field(None, description='The calibration source')
    status: RobotServerServiceSharedModelsCalibrationCalibrationStatus | None = Field(
        None,
        description='The status of this calibration as determinedby a user performing calibration check.',
    )


class DeckCalibrationSessionStatus(BaseModel):
    """
    The current status of a deck calibration session.
    """

    instrument: RobotServerRobotCalibrationHelperClassesAttachedPipette
    currentStep: str = Field(
        ...,
        description='Current step of deck calibration user flow',
        title='Currentstep',
    )
    labware: list[RequiredLabware] = Field(..., title='Labware')
    supportedCommands: list[str] = Field(
        ...,
        description='A list of supported commands for this user flow',
        title='Supportedcommands',
    )


class DeckCalibrationStatus(BaseModel):
    status: DeckTransformState = Field(
        ...,
        description='An enum stating whether a user has a valid robotdeck calibration. See DeckTransformStateclass for more information.',
    )
    data: DeckCalibrationData = Field(..., description='Deck calibration data')


class DeckSlotLocation(BaseModel):
    """
    The location of something placed in a single deck slot.
    """

    slotName: DeckSlotName = Field(
        ...,
        description='A slot on the robot\'s deck.\n\nThe plain numbers like `"5"` are for the OT-2, and the coordinates like `"C2"` are for the Flex.\n\nWhen you provide one of these values, you can use either style. It will automatically be converted to match the robot.\n\nWhen one of these values is returned, it will always match the robot.',
    )


class DeprecatedResponseModelSystemTimeResponseAttributes(BaseModel):
    data: SystemTimeResponseAttributes = Field(
        ..., description='The document’s primary data'
    )
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class Disengage(BaseModel):
    """
    A command to disengage a Magnetic Module's magnets.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['magneticModule/disengage'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DisengageParams
    result: DisengageResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DisengageCreate(BaseModel):
    """
    A request to create a Magnetic Module disengage command.
    """

    commandType: Literal['magneticModule/disengage'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DisengageParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DispenseInPlace(BaseModel):
    """
    DispenseInPlace command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['dispenseInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DispenseInPlaceParams
    result: DispenseInPlaceResult | None = None
    error: OverpressureError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DispenseInPlaceCreate(BaseModel):
    """
    DispenseInPlace command request model.
    """

    commandType: Literal['dispenseInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DispenseInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DropTipInPlace(BaseModel):
    """
    Drop tip in place command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['dropTipInPlace'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DropTipInPlaceParams
    result: DropTipInPlaceResult | None = None
    error: (
        TipPhysicallyAttachedError
        | OverpressureError
        | StallOrCollisionError
        | ErrorOccurrence
        | None
    ) = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DropTipInPlaceCreate(BaseModel):
    """
    Drop tip in place command creation request model.
    """

    commandType: Literal['dropTipInPlace'] = Field(..., const=True, title='Commandtype')
    params: DropTipInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DropTipWellLocation(BaseModel):
    """
    Like WellLocation, but for dropping tips.

    Unlike a typical WellLocation, the location for a drop tip
    defaults to location based on the tip length rather than the well's top.
    """

    origin: DropTipWellOrigin | None = 'default'
    offset: WellOffset | None = None


class EapConfigOption(BaseModel):
    """
    An object describing the name and format of an EAP config option
    """

    name: str = Field(..., description='The name of the config option', title='Name')
    displayName: str = Field(
        ...,
        description='A human-readable and nicely formatted name for the option',
        title='Displayname',
    )
    required: bool = Field(
        ...,
        description='Whether the option is required for this EAP variant or optional',
        title='Required',
    )
    type: EapConfigOptionType = Field(
        ...,
        description='The type of the value. If string, a non-sensitive string like a username. If password, a sensitive string like a passphrase for a keyfile or a password. If file, upload the file with POST /wifi/keys and pass the hash.',
    )


class EapVariant(BaseModel):
    """
    An object describing an EAP variant
    """

    name: str = Field(
        ..., description='The identifier for the EAP variant', title='Name'
    )
    displayName: str = Field(
        ...,
        description='A human-readable formatted name for the EAP variant',
        title='Displayname',
    )
    options: list[EapConfigOption] = Field(
        ...,
        description='A list of objects describing configuration options for the EAP variant',
        title='Options',
    )


class EmptyParams(BaseModel):
    """
    The parameters defining how a stacker should be emptied.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker', title='Moduleid'
    )
    strategy: StackerFillEmptyStrategy = Field(
        ...,
        description='How to empty the stacker. If manualWithPause, pause the protocol until the client sends an interaction, and mark the labware pool as empty thereafter. If logical, do not pause but immediately apply the specified count.',
    )
    message: str | None = Field(
        None,
        description='The message to display on connected clients during a manualWithPause strategy empty.',
        title='Message',
    )
    count: Count | None = Field(
        None,
        description='The new count of labware in the pool. If None, default to an empty pool. If this number is larger than the amount of labware currently in the pool, default to the smaller amount. Do not use the value in the parameters as an outside observer; instead, use the count value from the results.',
        title='Count',
    )


class EmptyResult(BaseModel):
    """
    Result data from a stacker empty command.
    """

    count: int = Field(
        ...,
        description='The new amount of labware stored in the stacker labware pool.',
        title='Count',
    )
    primaryLabwareURI: str = Field(
        ...,
        description='The labware definition URI of the primary labware.',
        title='Primarylabwareuri',
    )
    adapterLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the adapter labware.',
        title='Adapterlabwareuri',
    )
    lidLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the lid labware.',
        title='Lidlabwareuri',
    )
    storedLabware: list[StackerStoredLabwareGroup] = Field(
        ...,
        description='The primary labware loaded into the stacker labware pool.',
        title='Storedlabware',
    )
    removedLabware: list[StackerStoredLabwareGroup] = Field(
        ...,
        description='The labware objects that have just been removed from the stacker labware pool.',
        title='Removedlabware',
    )
    originalPrimaryLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each newly-removed primary labware, in the same order as removedLabware.',
        title='Originalprimarylabwarelocationsequences',
    )
    originalAdapterLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each newly-removed adapter labware, in the same order as removedLabware. None if the pool does not specify an adapter.',
        title='Originaladapterlabwarelocationsequences',
    )
    originalLidLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each newly-removed lid labware, in the same order as removedLabware. None if the  pool does not specify a lid.',
        title='Originallidlabwarelocationsequences',
    )
    newPrimaryLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each newly-removed primary labware, in the same order as removedLabware.',
        title='Newprimarylabwarelocationsequences',
    )
    newAdapterLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each newly-removed adapter labware, in the same order as removedLabware. None if the pool does not specify an adapter.',
        title='Newadapterlabwarelocationsequences',
    )
    newLidLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each newly-removed lid labware, in the same order as removedLabware. None if the pool does not specify a lid labware.',
        title='Newlidlabwarelocationsequences',
    )


class Engage(BaseModel):
    """
    A command to engage a Magnetic Module's magnets.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['magneticModule/engage'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: EngageParams
    result: EngageResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class EngageCreate(BaseModel):
    """
    A request to create a Magnetic Module engage command.
    """

    commandType: Literal['magneticModule/engage'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: EngageParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class ErrorBody(BaseModel):
    """
    A response body for a single error.
    """

    errors: list[RobotServerErrorsErrorResponsesErrorDetails] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyClientDataKeyDoesNotExist(BaseModel):
    errors: list[ClientDataKeyDoesNotExist] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyDataFileInUse(BaseModel):
    errors: list[DataFileInUse] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyFileIdNotFound(BaseModel):
    errors: list[FileIdNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyFileNotFound(BaseModel):
    errors: list[FileNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyFirmwareUpdateFailed(BaseModel):
    errors: list[FirmwareUpdateFailed] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyInvalidDeckConfiguration(BaseModel):
    errors: list[InvalidDeckConfiguration] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyLabwareCalibrationEndpointsRemoved(BaseModel):
    errors: list[LabwareCalibrationEndpointsRemoved] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyLastAnalysisPending(BaseModel):
    errors: list[LastAnalysisPending] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyNoCurrentRunFound(BaseModel):
    errors: list[NoCurrentRunFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyNoOngoingUpdate(BaseModel):
    errors: list[NoOngoingUpdate] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyNoUpdateAvailable(BaseModel):
    errors: list[NoUpdateAvailable] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyNotSupportedOnOT2(BaseModel):
    errors: list[NotSupportedOnOT2] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyPreSerializedCommandsNotAvailable(BaseModel):
    errors: list[PreSerializedCommandsNotAvailable] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyProtocolNotFound(BaseModel):
    errors: list[ProtocolNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyProtocolRunIsActive(BaseModel):
    errors: list[ProtocolRunIsActive] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyProtocolUsedByRun(BaseModel):
    errors: list[ProtocolUsedByRun] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyRunActive(BaseModel):
    errors: list[RunActive] = Field(..., description='Error details.', title='Errors')
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyRunAlreadyActive(BaseModel):
    errors: list[RunAlreadyActive] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyRunNotIdle(BaseModel):
    errors: list[RobotServerMaintenanceRunsRouterBaseRouterRunNotIdle] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyRunStopped(BaseModel):
    errors: list[RunStopped] = Field(..., description='Error details.', title='Errors')
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodySubsystemNotPresent(BaseModel):
    errors: list[SubsystemNotPresent] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionFileIdNotFoundFileNotFound(BaseModel):
    errors: list[FileIdNotFound | FileNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionMultipleDataFileSourcesNoDataFileSourceProvidedUnexpectedFileFormat(
    BaseModel
):
    errors: list[
        MultipleDataFileSources | NoDataFileSourceProvided | UnexpectedFileFormat
    ] = Field(..., description='Error details.', title='Errors')
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionProtocolFilesInvalidProtocolRobotTypeMismatchFileIdNotFound(
    BaseModel
):
    errors: list[ProtocolFilesInvalid | ProtocolRobotTypeMismatch | FileIdNotFound] = (
        Field(..., description='Error details.', title='Errors')
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionProtocolNotFoundAnalysisNotFound(BaseModel):
    errors: list[ProtocolNotFound | AnalysisNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionRunActionNotAllowedRunStopped(BaseModel):
    errors: list[RunActionNotAllowed | RunStopped] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionRunStoppedRunNotIdle(BaseModel):
    errors: list[RunStopped | RobotServerRunsRouterBaseRouterRunNotIdle] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class ErrorBodyUnionRunStoppedSetupCommandNotAllowed(BaseModel):
    errors: list[RunStopped | SetupCommandNotAllowed] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class Extents(BaseModel):
    total: AxisAlignedBoundingBox3D


class FactoryResetOption(BaseModel):
    id: ResetOptionId = Field(
        ..., description='A short machine-readable id for the setting'
    )
    name: str = Field(
        ..., description='A short human-readable name for the setting', title='Name'
    )
    description: str = Field(
        ...,
        description='A longer human-readable description of the setting',
        title='Description',
    )


class FactoryResetOptions(BaseModel):
    """
    Available values to reset as factory reset
    """

    options: list[FactoryResetOption] = Field(..., title='Options')


class FillParams(BaseModel):
    """
    The parameters defining how a stacker should be filled.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker', title='Moduleid'
    )
    strategy: StackerFillEmptyStrategy = Field(
        ...,
        description='How to fill the stacker. If manualWithPause, pause the protocol until the client sends an interaction, and apply the new specified count thereafter. If logical, do not pause but immediately apply the specified count.',
    )
    message: str | None = Field(
        None,
        description='The message to display on connected clients during a manualWithPause strategy fill.',
        title='Message',
    )
    count: Count1 | None = Field(
        None,
        description='How full the labware pool should now be. If None, default to the maximum amount of the currently-configured labware the pool can hold. If this number is larger than the maximum the pool can hold, it will be clamped to the maximum. If this number is smaller than the current amount of labware the pool holds, it will be clamped to that minimum. Do not use the value in the parameters as an outside observer; instead, use the count value from the results.',
        title='Count',
    )
    labwareToStore: list[StackerStoredLabwareGroup] | None = Field(
        None,
        description='A list of IDs that should be initially stored in the stacker.\n\nIf specified, the first element of the list is the labware on the physical bottom that will be the first labware retrieved.\n\nThis is a complex field. The following must be true for the field to be valid:\n- If this field is specified, then either initialCount must not be specified, or this field must have exactly initalCount elements\n- Each element must contain an id for each corresponding labware details field (i.e. if lidLabware is specified, each element must have\n  a lidLabwareId) and must not contain an id for a corresponding labware details field that is not specified (i.e., if adapterLabware\n  is not specified, each element must not have an adapterLabwareId).\n\nThe behavior of the command depends on the values of both this field and initialCount.\n- If this field is not specified and initialCount is not specified, the command will create the maximum number of labware objects\n  the stacker can hold according to the labware pool specifications.\n- If this field is not specified and initialCount is specified to be 0, the command will create 0 labware objects and the stacker will be empty.\n- If this field is not specified and initialCount is specified to be non-0, the command will create initialCount labware objects of\n  each specified labware type (primary, lid, and adapter), with appropriate positions, and arbitrary IDs, loaded into the stacker\n- If this field is specified (and therefore initialCount is not specified or is specified to be the length of this field) then the\n  command will create labware objects with the IDs specified in this field and appropriate positions, loaded into the stacker.\n\nBehavior is also different depending on whether the labware identified by ID in this field exist or not. Either all labware specified\nin this field must exist, or all must not exist.\n\nFurther,\n- If the labware exist, they must be of the same type as identified in the primaryLabware field.\n- If the labware exist and the adapterLabware field is specified, each labware must be currently loaded on a labware of the same kind as\n  specified in the adapterLabware field, and that labware must be loaded off-deck\n- If the labware exist and the adapterLabware field is not specified, each labware must be currently loaded off deck directly\n- If the labware exist and the lidLabware field is specified, each labware must currently have a loaded lid of the same kind as specified\n  in the lidLabware field\n- If the labware exist and the lidLabware field is not specified, each labware must not currently have a lid\n- If the labware exist, they must have nothing loaded underneath them or above them other than what is mentioned above\n\nIf all the above are true, when this command executes the labware will be immediately moved into InStackerHopper. If any of the above\nare not true, analysis will fail.\n',
        title='Labwaretostore',
    )


class FillResult(BaseModel):
    """
    Result data from a stacker fill command.
    """

    count: int = Field(
        ...,
        description='The new amount of labware stored in the stacker.',
        title='Count',
    )
    primaryLabwareURI: str = Field(
        ...,
        description='The labware definition URI of the primary labware.',
        title='Primarylabwareuri',
    )
    adapterLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the adapter labware.',
        title='Adapterlabwareuri',
    )
    lidLabwareURI: str | None = Field(
        None,
        description='The labware definition URI of the lid labware.',
        title='Lidlabwareuri',
    )
    storedLabware: list[StackerStoredLabwareGroup] | None = Field(
        None,
        description='The labware now stored in the stacker.',
        title='Storedlabware',
    )
    addedLabware: list[StackerStoredLabwareGroup] | None = Field(
        None, description='The labware just added to the stacker.', title='Addedlabware'
    )
    originalPrimaryLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each primary labware, in the same order as storedLabware.',
        title='Originalprimarylabwarelocationsequences',
    )
    originalAdapterLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each adapter labware, in the same order as storedLabware. None if the pool does not specify an adapter.',
        title='Originaladapterlabwarelocationsequences',
    )
    originalLidLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each lid labware, in the same order as storedLabware. None if the pool does not specify a lid.',
        title='Originallidlabwarelocationsequences',
    )
    newPrimaryLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each primary labware, in the same order as storedLabware.',
        title='Newprimarylabwarelocationsequences',
    )
    newAdapterLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each adapter labware, in the same order as storedLabware. None if the pool does not specify an adapter.',
        title='Newadapterlabwarelocationsequences',
    )
    newLidLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each lid labware, in the same order as storedLabware. None if the pool does not specify a lid labware.',
        title='Newlidlabwarelocationsequences',
    )


class FlexStackerModuleData(BaseModel):
    """
    Live data from a Flex Stacker module.
    """

    status: str = Field(
        ..., description='Overall status of the module.', title='Status'
    )
    latchState: LatchState = Field(..., description='The state of the labware latch.')
    platformState: PlatformState = Field(..., description='The state of the platform.')
    hopperDoorState: HopperDoorState = Field(
        ..., description='The state of the hopper door.'
    )
    installDetected: bool = Field(
        ...,
        description='The install state of the Stacker on the Flex.',
        title='Installdetected',
    )


class GetNextTipCreate(BaseModel):
    """
    Get next tip command creation request model.
    """

    commandType: Literal['getNextTip'] = Field(..., const=True, title='Commandtype')
    params: GetNextTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class GetTipPresenceCreate(BaseModel):
    """
    GetTipPresence command creation request model.
    """

    commandType: Literal['getTipPresence'] = Field(..., const=True, title='Commandtype')
    params: GetTipPresenceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class GetTipPresenceResult(BaseModel):
    """
    Result data from the execution of a GetTipPresence command.
    """

    status: TipPresenceStatus = Field(
        ...,
        description='Whether or not a tip is attached on the pipette. This only works on on FLEX because OT-2 pipettes do not possess tip presence sensors, hence, will always return TipPresenceStatus.UNKNOWN.',
    )


class GripperCalibrationOffset(BaseModel):
    offset: Point
    source: SourceType
    status: OpentronsCalibrationStorageTypesCalibrationStatus
    last_modified: datetime | None = Field(None, title='Last Modified')


class GripperMovementError(BaseModel):
    """
    Returned when something physically goes wrong when the gripper moves labware.

    When this error happens, the engine will leave the labware in its original place.
    """

    id: str = Field(
        ..., description='Unique identifier of this error occurrence.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the error occurred.', title='Createdat'
    )
    isDefined: bool | None = Field(True, title='Isdefined')
    errorType: ErrorType = Field('gripperMovement', const=True, title='Errortype')
    errorCode: str = Field(
        ...,
        description='An enumerated error code for the error type.\nThis is intended to be shown to the robot operator to direct them to the\ncorrect rough area for troubleshooting.\n',
        title='Errorcode',
    )
    detail: str = Field(
        ...,
        description="A short human-readable message about the error.\n\nThis is intended to provide the robot operator with more specific details than\n`errorCode` alone. It should be no longer than a couple of sentences,\nand it should not contain internal newlines or indentation.\n\nIt should not internally repeat `errorCode`, but it may internally repeat `errorType`\nif it helps the message make sense when it's displayed in its own separate block.\n",
        title='Detail',
    )
    errorInfo: OpentronsProtocolEngineCommandsMoveLabwareErrorDetails
    wrappedErrors: list[ErrorOccurrence] = Field(
        default_factory=list,
        description='Errors that may have caused this one.',
        title='Wrappederrors',
    )


class GripperOffsets(BaseModel):
    pickUpOffset: Vector3D
    dropOffset: Vector3D


class Group(BaseModel):
    wells: list[str] = Field(..., title='Wells')
    metadata: GroupMetadata
    brand: BrandData | None = None


class HTTPValidationError(BaseModel):
    detail: list[ValidationError] | None = Field(None, title='Detail')


class Health(BaseModel):
    """
    Information about the server and system.
    """

    name: str = Field(
        ...,
        description="The robot's name. In most cases the same as its mDNS advertisement domain name, but this can get out of sync. Mostly useful for user-facing titles.",
        examples=['Otie'],
        title='Name',
    )
    robot_model: RobotModel = Field(
        ..., description='Which model of Opentrons robot this is', title='Robot Model'
    )
    api_version: str = Field(
        ...,
        description="The API server's software version",
        examples=['3.15.2'],
        title='Api Version',
    )
    fw_version: str = Field(
        ...,
        description="The motor controller's firmware version. Doesn't follow a pattern; suitable only for display or exact matching.",
        examples=['v2.15.0'],
        title='Fw Version',
    )
    board_revision: str = Field(
        ...,
        description="The hardware revision of the OT-2's central routing board.",
        examples=['2.1'],
        title='Board Revision',
    )
    logs: list[str] = Field(
        ...,
        description='List of paths at which to find log endpoints',
        examples=[['/logs/serial.log', '/logs/api.log']],
        title='Logs',
    )
    system_version: str = Field(
        ...,
        description="The robot's operating system version.",
        examples=['1.2.1'],
        title='System Version',
    )
    maximum_protocol_api_version: list[int] = Field(
        ...,
        description="The system's maximum supported Protocol API version, in the format `[major_version, minor_version]`",
        examples=[[2, 8]],
        max_items=2,
        min_items=2,
        title='Maximum Protocol Api Version',
    )
    minimum_protocol_api_version: list[int] = Field(
        ...,
        description="The system's minimum supported Protocol API version, in the format `[major_version, minor_version]`",
        examples=[[2, 0]],
        max_items=2,
        min_items=2,
        title='Minimum Protocol Api Version',
    )
    robot_serial: str | None = Field(
        None,
        description='The robot serial number. Should be used if present; if not present, use result of /server/update/health.',
        examples=['OT2CEP20190604A02'],
        title='Robot Serial',
    )
    links: HealthLinks


class HeaterShakerModuleData(BaseModel):
    """
    Live data from a Heater-Shaker module.
    """

    status: HeaterShakerStatus = Field(..., description='Overall status of the module.')
    labwareLatchStatus: HeaterShakerLabwareLatchStatus = Field(
        ..., description="Status of the module's labware latch"
    )
    speedStatus: SpeedStatus = Field(..., description="Status of the module's shaker.")
    currentSpeed: int = Field(
        ...,
        description='Current speed of the shaker, in rotations-per-minute.',
        title='Currentspeed',
    )
    targetSpeed: int | None = Field(
        ...,
        description='Target speed of the shaker, if set, in rotations-per-minute.',
        title='Targetspeed',
    )
    temperatureStatus: TemperatureStatus = Field(
        ..., description="Status of the module's heater."
    )
    currentTemperature: float = Field(
        ...,
        description='Current temperature of the heater, in degrees Celsius.',
        title='Currenttemperature',
    )
    targetTemperature: float | None = Field(
        ...,
        description='Target temperature of the heater, if set, in degrees Celsius.',
        title='Targettemperature',
    )
    errorDetails: str | None = Field(
        ...,
        description='Error details, if the module hardware has encountered something unexpected and unrecoverable.',
        title='Errordetails',
    )


class HomeParams(BaseModel):
    """
    Payload required for a Home command.
    """

    axes: list[MotorAxis] | None = Field(
        None,
        description='Axes to return to their home positions. If omitted, will home all motors. Extra axes may be implicitly homed to ensure accurate homing of the explicitly specified axes.',
        title='Axes',
    )
    skipIfMountPositionOk: OpentronsTypesMountType | None = Field(
        None,
        description='If this parameter is provided, the gantry will only be homed if the specified mount has an invalid position. If omitted, the homing action will be executed unconditionally.',
        title='Skipifmountpositionok',
    )


class IdentifyModuleParams(BaseModel):
    """
    The parameters defining the module to be identified.
    """

    model: ModuleModelModel = Field(..., description='The model of the module')
    moduleId: str = Field(..., description='Unique ID of the module', title='Moduleid')
    start: bool = Field(..., description='Start or stop identify', title='Start')
    color: str | None = Field(
        None, description='Optional color to identify module', title='Color'
    )


class InconsistentCalibrationFailure(BaseModel):
    """
    Pipette offsets are very different from each other.

    This indicates that one of the pipettes (though we can't tell which one)
    was likely calibrated with its calibration probe not fully attached, and
    should be redone. However, it's possible that the pipettes are in fact
    calibrated correctly and their offsets look strange, so this should be
    taken as an advisory.
    """

    kind: Kind1 = Field('inconsistent-pipette-offset', const=True, title='Kind')
    offsets: dict[str, Vec3f] = Field(..., title='Offsets')
    limit: float = Field(..., title='Limit')


class Initialize(BaseModel):
    """
    A command to initialize an Absorbance Reader.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['absorbanceReader/initialize'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: InitializeParams
    result: InitializeResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class InitializeCreate(BaseModel):
    """
    A request to execute an Absorbance Reader measurement.
    """

    commandType: Literal['absorbanceReader/initialize'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: InitializeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class Sections(BaseModel):
    __root__: (
        ConicalFrustum
        | CuboidalFrustum
        | SquaredConeSegment
        | RoundedCuboidSegment
        | SphericalSegment
    ) = Field(..., discriminator='shape')


class InnerWellGeometry(BaseModel):
    sections: list[Sections] = Field(..., min_items=1, title='Sections')


class InstrumentCalibrationData(BaseModel):
    """
    An instrument's calibration data.
    """

    offset: Vec3f
    source: SourceType
    last_modified: datetime | None = Field(None, title='Last Modified')
    reasonability_check_failures: list[InconsistentCalibrationFailure] = Field(
        ..., title='Reasonability Check Failures'
    )


class InstrumentCalibrationStatus(BaseModel):
    right: InstrumentOffset
    left: InstrumentOffset


class LabwareCalibration(BaseModel):
    """
    A model describing labware calibrations (tiplength and offset)
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    calibrationData: CalibrationData = Field(
        ...,
        description='A dictionary of calibration dataincluding tip length and offsets',
    )
    loadName: str = Field(
        ..., description='The loadname of the labware definition.', title='Loadname'
    )
    namespace: str = Field(
        ...,
        description='The namespace location of the labware definition',
        title='Namespace',
    )
    version: int = Field(
        ..., description='The labware definition version', title='Version'
    )
    parent: str = Field(
        ...,
        description='The module associated with this offset or an empty string if the offset is associated with a slot',
        title='Parent',
    )
    definitionHash: str = Field(
        ...,
        description='The sha256 hash of key labware definition details',
        title='Definitionhash',
    )


class LabwareDefinition2(BaseModel):
    schemaVersion: Literal[2] = Field(..., const=True, title='Schemaversion')
    version: int = Field(..., ge=1, title='Version')
    namespace: str = Field(..., regex='^[a-z0-9._]+$', title='Namespace')
    metadata: OpentronsSharedDataLabwareLabwareDefinitionMetadata
    brand: BrandData
    parameters: Parameters2
    cornerOffsetFromSlot: Vector3D
    ordering: list[list[str]] = Field(..., title='Ordering')
    dimensions: Dimensions
    wells: dict[str, CircularWellDefinition2 | RectangularWellDefinition2] = Field(
        ..., title='Wells'
    )
    groups: list[Group] = Field(..., title='Groups')
    stackingOffsetWithLabware: dict[str, Vector3D] | None = Field(
        None, title='Stackingoffsetwithlabware'
    )
    stackingOffsetWithModule: dict[str, Vector3D] | None = Field(
        None, title='Stackingoffsetwithmodule'
    )
    allowedRoles: list[LabwareRole] | None = Field(None, title='Allowedroles')
    gripperOffsets: dict[str, GripperOffsets] | None = Field(
        None, title='Gripperoffsets'
    )
    gripForce: float | None = Field(None, title='Gripforce')
    gripHeightFromLabwareBottom: float | None = Field(
        None, title='Gripheightfromlabwarebottom'
    )
    stackLimit: int | None = Field(None, title='Stacklimit')
    compatibleParentLabware: list[str] | None = Field(
        None, title='Compatibleparentlabware'
    )
    innerLabwareGeometry: dict[str, InnerWellGeometry | UserDefinedVolumes] | None = (
        Field(None, title='Innerlabwaregeometry')
    )


class LocationSequence(BaseModel):
    __root__: (
        OnLabwareOffsetLocationSequenceComponent
        | OnModuleOffsetLocationSequenceComponent
        | OnAddressableAreaOffsetLocationSequenceComponent
    ) = Field(..., discriminator='kind')


class LabwareOffsetCreate(BaseModel):
    """
    Create request data for a labware offset with a modern location sequence.
    """

    definitionUri: str = Field(
        ..., description="The URI for the labware's definition.", title='Definitionuri'
    )
    locationSequence: list[LocationSequence] = Field(
        ...,
        description='Where the labware is located on the robot.',
        title='Locationsequence',
    )
    vector: LabwareOffsetVector = Field(
        ..., description='The offset applied to matching labware.'
    )


class LegacyLabwareOffsetLocation(BaseModel):
    """
    Parameters describing when a given offset may apply to a given labware load.
    """

    slotName: DeckSlotName = Field(
        ...,
        description='The deck slot where the protocol will load the labware. Or, if the protocol will load the labware on a module, the deck slot where the protocol will load that module.\n\nThe plain numbers like `"5"` are for the OT-2, and the coordinates like `"C2"` are for the Flex.\n\nWhen you provide one of these values, you can use either style. It will automatically be converted to match the robot.\n\nWhen one of these values is returned, it will always match the robot.',
    )
    moduleModel: ModuleModelModel | None = Field(
        None,
        description="The model of the module that the labware will be loaded onto, if applicable.\n\nBecause of module compatibility, the model that the protocol requests may not be exactly the same as what it will find physically connected during execution. For this labware offset to apply, this field must be the *requested* model, not the connected one. You can retrieve this from a `loadModule` command's `params.model` in the protocol's analysis.",
    )
    definitionUri: str | None = Field(
        None,
        description='The definition URI of another labware, probably an adapter, that the labware will be loaded onto, if applicable.\n\nThis can be combined with moduleModel if the labware is loaded on top of an adapter that is loaded on a module.',
        title='Definitionuri',
    )


class LiquidHandlingWellLocation(BaseModel):
    """
    A relative location in reference to a well's location.

    To be used with commands that handle liquids.
    """

    origin: WellOrigin | None = 'top'
    offset: WellOffset | None = None
    volumeOffset: float | VolumeOffset | None = Field(
        0,
        description='A volume of liquid, in µL, to offset the z-axis offset. When "operationVolume" is specified, this volume is pulled from the command volume parameter.',
        title='Volumeoffset',
    )


class LiquidProbeResult(BaseModel):
    """
    Result data from the execution of a `liquidProbe` command.
    """

    position: DeckPoint | None = Field(
        default_factory=lambda: DeckPoint.parse_obj({'x': 0, 'y': 0, 'z': 0}),
        description="The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
    )
    z_position: float | SimulatedProbeResult = Field(
        ...,
        description='The Z coordinate, in mm, of the found liquid in deck space.',
        title='Z Position',
    )


class LoadLabwareParams(BaseModel):
    """
    Payload required to load a labware into a slot.
    """

    location: (
        DeckSlotLocation
        | ModuleLocation
        | OnLabwareLocation
        | Location
        | Location1
        | AddressableAreaLocation
    ) = Field(
        ..., description='Location the labware should be loaded into.', title='Location'
    )
    loadName: str = Field(
        ...,
        description='Name used to reference a labware definition.',
        title='Loadname',
    )
    namespace: str = Field(
        ...,
        description='The namespace the labware definition belongs to.',
        title='Namespace',
    )
    version: int = Field(
        ..., description='The labware definition version.', title='Version'
    )
    labwareId: str | None = Field(
        None,
        description='An optional ID to assign to this labware. If None, an ID will be generated.',
        title='Labwareid',
    )
    displayName: str | None = Field(
        None,
        description='An optional user-specified display name or label for this labware.',
        title='Displayname',
    )


class LoadLidParams(BaseModel):
    """
    Payload required to load a lid onto a labware.
    """

    location: (
        DeckSlotLocation
        | ModuleLocation
        | OnLabwareLocation
        | Location2
        | Location3
        | AddressableAreaLocation
    ) = Field(
        ..., description='Labware the lid should be loaded onto.', title='Location'
    )
    loadName: str = Field(
        ...,
        description='Name used to reference a lid labware definition.',
        title='Loadname',
    )
    namespace: str = Field(
        ...,
        description='The namespace the lid labware definition belongs to.',
        title='Namespace',
    )
    version: int = Field(
        ..., description='The lid labware definition version.', title='Version'
    )


class LoadLidStackParams(BaseModel):
    """
    Payload required to load a lid stack onto a location.
    """

    location: (
        DeckSlotLocation
        | ModuleLocation
        | OnLabwareLocation
        | Location4
        | Location5
        | AddressableAreaLocation
    ) = Field(
        ...,
        description='Location the lid stack should be loaded into.',
        title='Location',
    )
    loadName: str = Field(
        ...,
        description='Name used to reference a lid labware definition.',
        title='Loadname',
    )
    namespace: str = Field(
        ...,
        description='The namespace the lid labware definition belongs to.',
        title='Namespace',
    )
    version: int = Field(
        ..., description='The lid labware definition version.', title='Version'
    )
    stackLabwareId: str | None = Field(
        None,
        description='An optional ID to assign to the lid stack labware object created.If None, an ID will be generated.',
        title='Stacklabwareid',
    )
    labwareIds: list[str] | None = Field(
        None,
        description='An optional list of IDs to assign to the lids in the stack.If None, an ID will be generated.',
        title='Labwareids',
    )
    quantity: int = Field(
        ..., description='The quantity of lids to load.', title='Quantity'
    )


class LoadLiquid(BaseModel):
    """
    Load liquid command resource model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadLiquid'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadLiquidParams
    result: LoadLiquidResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadLiquidCreate(BaseModel):
    """
    Load liquid command creation request.
    """

    commandType: Literal['loadLiquid'] = Field(..., const=True, title='Commandtype')
    params: LoadLiquidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LoadModuleParams(BaseModel):
    """
    Payload required to load a module.
    """

    model: ModuleModelModel = Field(
        ...,
        description='The model name of the module to load.\n\nProtocol Engine will look for a connected module that either exactly matches this one, or is compatible.\n\n For example, if you request a `temperatureModuleV1` here, Protocol Engine might load a `temperatureModuleV1` or a `temperatureModuleV2`.\n\n The model that it finds connected will be available through `result.model`.',
    )
    location: DeckSlotLocation = Field(
        ...,
        description='The location into which this module should be loaded.\n\nFor the Thermocycler Module, which occupies multiple deck slots, this should be the front-most occupied slot (normally slot 7).',
    )
    moduleId: str | None = Field(
        None,
        description='An optional ID to assign to this module. If None, an ID will be generated.',
        title='Moduleid',
    )


class LoadModuleResult(BaseModel):
    """
    The results of loading a module.
    """

    moduleId: str = Field(
        ...,
        description='An ID to reference this module in subsequent commands.',
        title='Moduleid',
    )
    model: ModuleModelModel = Field(
        ...,
        description="The hardware model of the connected module. This can be different from the exact model that this command requested. See `params.model`.\n\nThis field is only meaningful in the run's actual execution, not in the protocol's analysis. In analysis, it will be an arbitrary placeholder.",
    )
    serialNumber: str | None = Field(
        None,
        description='Hardware serial number of the connected module. Will be `None` if a module is not electrically connected to the robot (like the Magnetic Block).',
        title='Serialnumber',
    )


class LoadPipetteParams(BaseModel):
    """
    Payload needed to load a pipette on to a mount.
    """

    pipetteName: PipetteNameType = Field(
        ..., description='The load name of the pipette to be required.'
    )
    mount: OpentronsTypesMountType = Field(
        ..., description='The mount the pipette should be present on.'
    )
    pipetteId: str | None = Field(
        None,
        description='An optional ID to assign to this pipette. If None, an ID will be generated.',
        title='Pipetteid',
    )
    tipOverlapNotAfterVersion: str | None = Field(
        None,
        description='A version of tip overlap data to not exceed. The highest-versioned tip overlap data that does not exceed this version will be used. Versions are expressed as vN where N is an integer, counting up from v0. If None, the current highest version will be used.',
        title='Tipoverlapnotafterversion',
    )
    liquidPresenceDetection: bool | None = Field(
        None,
        description='Enable liquid presence detection for this pipette. Defaults to False.',
        title='Liquidpresencedetection',
    )


class LoadedLabware(BaseModel):
    """
    A labware that has been loaded.
    """

    id: str = Field(..., title='Id')
    loadName: str = Field(..., title='Loadname')
    definitionUri: str = Field(..., title='Definitionuri')
    location: (
        DeckSlotLocation
        | ModuleLocation
        | OnLabwareLocation
        | Location8
        | Location9
        | AddressableAreaLocation
        | InStackerHopperLocation
    ) = Field(..., description="The labware's current location.", title='Location')
    lid_id: str | None = Field(
        None,
        description='Labware ID of a Lid currently loaded on top of the labware.',
        title='Lid Id',
    )
    offsetId: str | None = Field(
        None,
        description='An ID referencing the labware offset that applies to this labware placement. Null or undefined means no offset was provided for this load, so the default of (0, 0, 0) will be used.',
        title='Offsetid',
    )
    displayName: str | None = Field(
        None,
        description='A user-specified display name for this labware, if provided.',
        title='Displayname',
    )


class LoadedModule(BaseModel):
    """
    A module that has been loaded.
    """

    id: str = Field(..., title='Id')
    model: ModuleModelModel
    location: DeckSlotLocation | None = None
    serialNumber: str | None = Field(None, title='Serialnumber')


class LoadedPipette(BaseModel):
    """
    A pipette that has been loaded.
    """

    id: str = Field(..., title='Id')
    pipetteName: PipetteNameType
    mount: OpentronsTypesMountType


class LogLevel(BaseModel):
    log_level: LogLevels | None = Field(
        None, description='The value to set (conforming to Python log levels)'
    )


class MagneticModuleData(BaseModel):
    """
    Live data from an attached Magnetic Module.
    """

    status: MagneticStatus
    engaged: bool = Field(
        ..., description='Whether the magnets are raised or lowered', title='Engaged'
    )
    height: float = Field(
        ...,
        description='The height of the top of the magnets relative to the labware base, in millimeters.',
        title='Height',
    )


class MatchCriteria(BaseModel):
    """
    The criteria that this rule will attempt to match.
    """

    command: CommandMatcher = Field(
        ..., description='The command and error types that this rule applies to.'
    )


class ModuleCalibrationData(BaseModel):
    """
    A module's calibration data.
    """

    offset: Vec3f
    slot: str | None = Field(None, title='Slot')
    source: SourceType | None = None
    last_modified: datetime | None = Field(None, title='Last Modified')


class MoveAxesRelative(BaseModel):
    """
    MoveAxesRelative command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['robot/moveAxesRelative'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveAxesRelativeParams
    result: MoveAxesRelativeResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveAxesRelativeCreate(BaseModel):
    """
    MoveAxesRelative command request model.
    """

    commandType: Literal['robot/moveAxesRelative'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: MoveAxesRelativeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveAxesTo(BaseModel):
    """
    MoveAxesTo command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['robot/moveAxesTo'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveAxesToParams
    result: MoveAxesToResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveAxesToCreate(BaseModel):
    """
    MoveAxesTo command request model.
    """

    commandType: Literal['robot/moveAxesTo'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: MoveAxesToParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveLabwareParams(BaseModel):
    """
    Input parameters for a ``moveLabware`` command.
    """

    labwareId: str = Field(
        ..., description='The ID of the labware to move.', title='Labwareid'
    )
    newLocation: (
        DeckSlotLocation
        | ModuleLocation
        | OnLabwareLocation
        | NewLocation
        | NewLocation1
        | AddressableAreaLocation
    ) = Field(..., description='Where to move the labware.', title='Newlocation')
    strategy: LabwareMovementStrategy = Field(
        ...,
        description='Whether to use the gripper to perform the labware movement or to perform a manual movement with an option to pause.',
    )
    pickUpOffset: LabwareOffsetVector | None = Field(
        None,
        description='Offset to use when picking up labware. Experimental param, subject to change',
        title='Pickupoffset',
    )
    dropOffset: LabwareOffsetVector | None = Field(
        None,
        description='Offset to use when dropping off labware. Experimental param, subject to change',
        title='Dropoffset',
    )


class MoveLabwareResult(BaseModel):
    """
    The output of a successful ``moveLabware`` command.
    """

    offsetId: str | None = Field(
        None,
        description="An ID referencing the labware offset that will apply to this labware now that it's in the new location. This offset will be in effect until the labware is moved with another `moveLabware` command. Null or undefined means no offset applies, so the default of (0, 0, 0) will be used.",
        title='Offsetid',
    )
    eventualDestinationLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location in which this labware will eventually reside. This will typically be the same as its immediate destination, but if this labware is going to the trash then this field will be off deck.',
        title='Eventualdestinationlocationsequence',
    )
    immediateDestinationLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location to which this labware is being moved, right now.',
        title='Immediatedestinationlocationsequence',
    )
    originLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location down to the deck of the labware before this command.',
        title='Originlocationsequence',
    )


class MoveRelativeParams(BaseModel):
    """
    Payload required for a MoveRelative command.
    """

    pipetteId: str = Field(..., description='Pipette to move.', title='Pipetteid')
    axis: MovementAxis = Field(..., description='Axis along which to move.')
    distance: float = Field(
        ...,
        description='Distance to move in millimeters. A positive number will move towards the right (x), back (y), top (z) of the deck.',
        title='Distance',
    )


class MoveToAddressableArea(BaseModel):
    """
    Move to addressable area command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['moveToAddressableArea'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveToAddressableAreaParams
    result: MoveToAddressableAreaResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveToAddressableAreaCreate(BaseModel):
    """
    Move to addressable area command creation request model.
    """

    commandType: Literal['moveToAddressableArea'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: MoveToAddressableAreaParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveToAddressableAreaForDropTip(BaseModel):
    """
    Move to addressable area for drop tip command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['moveToAddressableAreaForDropTip'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveToAddressableAreaForDropTipParams
    result: MoveToAddressableAreaForDropTipResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveToAddressableAreaForDropTipCreate(BaseModel):
    """
    Move to addressable area for drop tip command creation request model.
    """

    commandType: Literal['moveToAddressableAreaForDropTip'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: MoveToAddressableAreaForDropTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveToCoordinates(BaseModel):
    """
    Move to well command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['moveToCoordinates'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveToCoordinatesParams
    result: MoveToCoordinatesResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveToCoordinatesCreate(BaseModel):
    """
    Move to coordinates command creation request model.
    """

    commandType: Literal['moveToCoordinates'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: MoveToCoordinatesParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveToMaintenancePositionParams(BaseModel):
    """
    Calibration set up position command parameters.
    """

    mount: OpentronsTypesMountType = Field(
        ..., description='Gantry mount to move maintenance position.'
    )
    maintenancePosition: MaintenancePosition | None = Field(
        'attachInstrument',
        description='The position the gantry mount needs to move to.',
    )


class MoveToParams(BaseModel):
    """
    Payload required to move to a destination position.
    """

    mount: OpentronsTypesMountType = Field(
        ..., description='The mount to move to the destination point.'
    )
    destination: DeckPoint = Field(
        ...,
        description="X, Y and Z coordinates in mm from deck's origin location (left-front-bottom corner of work space)",
    )
    speed: float | None = Field(
        None,
        description='The max velocity to move the axes at. Will fall to hardware defaults if none provided.',
        title='Speed',
    )


class MoveToWellParams(BaseModel):
    """
    Payload required to move a pipette to a specific well.
    """

    minimumZHeight: float | None = Field(
        None,
        description="Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect.",
        title='Minimumzheight',
    )
    forceDirect: bool | None = Field(
        False,
        description="If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
        title='Forcedirect',
    )
    speed: float | None = Field(
        None,
        description='Override the travel speed in mm/s. This controls the straight linear speed of motion.',
        title='Speed',
    )
    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: LiquidHandlingWellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class NoTipAvailable(BaseModel):
    """
    No available next tip data.
    """

    noTipReason: NoTipReason = Field(
        ..., description='The reason why no next available tip could be provided.'
    )
    message: str | None = Field(
        None,
        description="Optional message explaining why a tip wasn't available.",
        title='Message',
    )


class OpenGripperJaw(BaseModel):
    """
    openGripperJaw command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['robot/openGripperJaw'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpenGripperJawParams
    result: OpenGripperJawResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpenGripperJawCreate(BaseModel):
    """
    openGripperJaw command request model.
    """

    commandType: Literal['robot/openGripperJaw'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpenGripperJawParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpenLabwareLatch(BaseModel):
    """
    A command to open a Heater-Shaker's labware latch.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/openLabwareLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpenLabwareLatchParams
    result: OpenLabwareLatchResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpenLabwareLatchCreate(BaseModel):
    """
    A request to create a Heater-Shaker's open labware latch command.
    """

    commandType: Literal['heaterShaker/openLabwareLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpenLabwareLatchParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class PendingAnalysis(BaseModel):
    """
    A protocol analysis that is on-going.
    """

    id: str = Field(
        ..., description='Unique identifier of this analysis resource', title='Id'
    )
    status: Status2 = Field(
        'pending',
        const=True,
        description='Status marking the analysis as pending',
        title='Status',
    )
    runTimeParameters: (
        list[NumberParameter | EnumParameter | BooleanParameter | CSVParameter] | None
    ) = Field(
        None,
        description='Run time parameters used during analysis. These are the parameters that are defined in the protocol, with values specified either in the protocol creation request or reanalysis request (whichever started this analysis), or default values from the protocol if none are specified in the request.',
        title='Runtimeparameters',
    )


class PickUpTipWellLocation(BaseModel):
    """
    A relative location in reference to a well's location.

    To be used for picking up tips.
    """

    origin: PickUpTipWellOrigin | None = 'top'
    offset: WellOffset | None = None


class PipetteData(BaseModel):
    """
    Data from attached pipette.
    """

    channels: Channels = Field(
        ..., description='Number of pipette channels.', title='Channels'
    )
    min_volume: float = Field(
        ..., description='Minimum pipette volume.', title='Min Volume'
    )
    max_volume: float = Field(
        ..., description='Maximum pipette volume.', title='Max Volume'
    )
    calibratedOffset: InstrumentCalibrationData | None = Field(
        None, description='Calibrated pipette offset.'
    )


class PipetteOffsetCalibration(BaseModel):
    """
    A model describing pipette calibration based on the mount and
    the pipette's serial number
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    pipette: str = Field(..., description='The pipette ID', title='Pipette')
    mount: str = Field(..., description='The pipette mount', title='Mount')
    offset: list[float] = Field(
        ...,
        description='The pipette offset vector',
        max_items=3,
        min_items=3,
        title='Offset',
    )
    tiprack: str = Field(
        ...,
        description='A hash of the labware definition of the tip rack that was used in this calibration. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `tiprackUri` instead.',
        title='Tiprack',
    )
    tiprackUri: str = Field(
        ...,
        description='The standard labware uri of the tiprack used in this calibration',
        title='Tiprackuri',
    )
    lastModified: datetime = Field(
        ..., description='When this calibration was last modified', title='Lastmodified'
    )
    source: SourceType = Field(..., description='The calibration source')
    status: RobotServerServiceSharedModelsCalibrationCalibrationStatus = Field(
        ..., description='The status of this calibration'
    )


class PipetteOffsetCalibrationCreateAttributes(BaseModel):
    """
    Pipette offset calibration create request.
    """

    sessionType: SessionType4 = Field(
        'pipetteOffsetCalibration', const=True, title='Sessiontype'
    )
    createParams: RobotServerRobotCalibrationModelsSessionCreateParams


class PipetteOffsetCalibrationSessionStatus(BaseModel):
    """
    The current status of a pipette offset calibration session.
    """

    instrument: RobotServerRobotCalibrationHelperClassesAttachedPipette
    currentStep: str = Field(
        ..., description='Current step of pipette offset user flow', title='Currentstep'
    )
    labware: list[RequiredLabware] = Field(..., title='Labware')
    shouldPerformTipLength: bool = Field(
        ...,
        description='Does tip length calibration data exist for this pipette and tip rack combination',
        title='Shouldperformtiplength',
    )
    supportedCommands: list[str] = Field(
        ...,
        description='A list of supported commands for this user flow',
        title='Supportedcommands',
    )
    nextSteps: NextSteps | None = Field(
        None, description='Next Available Steps in Session'
    )


class PipetteSettingsField(BaseModel):
    """
    A pipette config element identified by the property's name
    """

    units: str | None = Field(
        None,
        description='The physical units this value is in (e.g. mm, uL)',
        title='Units',
    )
    type: PipetteSettingsFieldType | None = None
    min: float = Field(
        ..., description='The minimum acceptable value of the property', title='Min'
    )
    max: float = Field(
        ..., description='The maximum acceptable value of the property', title='Max'
    )
    default: float = Field(
        ..., description='The default value of the property', title='Default'
    )
    value: float = Field(
        ..., description='The current value of the property', title='Value'
    )


class PipetteSettingsFields(BaseModel):
    """
    The fields of the pipette settings
    """

    quirks: dict[str, bool] | None = Field(
        None,
        description='Quirks are behavioral changes associated with pipettes. For instance, some models of pipette might need to run their drop tip behavior twice. Specific pipettes have which can then be enabled or disabled; quirks that are not originally defined as compatible with a specific kind of pipette cannot be added to an incompatible pipette. Because quirks are only defined as compatible for a pipette if they should be on, the default value for all quirks is true.',
        title='Quirks',
    )
    top: PipetteSettingsField | None = None
    bottom: PipetteSettingsField | None = None
    blowout: PipetteSettingsField | None = None
    dropTip: PipetteSettingsField | None = None
    pickUpCurrent: PipetteSettingsField | None = None
    pickUpDistance: PipetteSettingsField | None = None
    pickUpIncrement: PipetteSettingsField | None = None
    pickUpPresses: PipetteSettingsField | None = None
    pickUpSpeed: PipetteSettingsField | None = None
    plungerCurrent: PipetteSettingsField | None = None
    dropTipCurrent: PipetteSettingsField | None = None
    dropTipSpeed: PipetteSettingsField | None = None
    tipLength: PipetteSettingsField | None = None


class PipetteSettingsUpdate(BaseModel):
    fields: dict[str, PipetteUpdateField | None] | None = Field(None, title='Fields')


class PipettesByMount(BaseModel):
    """
    The attached pipettes by mount
    """

    left: RobotServerServiceLegacyModelsPipettesAttachedPipette
    right: RobotServerServiceLegacyModelsPipettesAttachedPipette


class PlaceLabwareState(BaseModel):
    """
    Details the labware being placed by the gripper.
    """

    labwareURI: str = Field(
        ..., description='The URI of the labware to place.', title='Labwareuri'
    )
    location: (
        DeckSlotLocation | ModuleLocation | OnLabwareLocation | AddressableAreaLocation
    ) = Field(
        ..., description='The location the labware should be in.', title='Location'
    )
    shouldPlaceDown: bool = Field(
        ...,
        description='Whether the gripper should place down the labware.',
        title='Shouldplacedown',
    )


class PrepareToAspirate(BaseModel):
    """
    Prepare for aspirate command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['prepareToAspirate'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: PrepareToAspirateParams
    result: PrepareToAspirateResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class PrepareToAspirateCreate(BaseModel):
    """
    Prepare for aspirate command creation request model.
    """

    commandType: Literal['prepareToAspirate'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: PrepareToAspirateParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class PresentSubsystem(BaseModel):
    """
    Model for the status of a subsystem.
    """

    name: SubSystem = Field(..., description='The name of a connected subsystem.')
    ok: bool = Field(
        ...,
        description='Whether the subsystem is running, up to date, and in a normal state.',
        title='Ok',
    )
    current_fw_version: str = Field(
        ...,
        description='The current version of firmware the subsystem is running.',
        title='Current Fw Version',
    )
    next_fw_version: str = Field(
        ...,
        description='What firmware version a prospective update would leave the subsystem running.',
        title='Next Fw Version',
    )
    fw_update_needed: bool = Field(
        ...,
        description='True if a client should begin an update for this subsystem.',
        title='Fw Update Needed',
    )
    revision: str = Field(
        ...,
        description='A descriptor of the hardware revision of the subsystem.',
        title='Revision',
    )


class PressureDispenseParams(BaseModel):
    """
    Payload required to pressure dispense in place.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: LiquidHandlingWellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description='The amount of liquid to dispense, in µL. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors.',
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class ProfileCycle(BaseModel):
    """
    An individual cycle in a Thermocycler extended profile.
    """

    steps: list[ProfileStep] = Field(..., description='Steps to repeat.', title='Steps')
    repetitions: int = Field(
        ..., description='Number of times to repeat the steps.', title='Repetitions'
    )


class ProtocolFile(BaseModel):
    """
    A file in a protocol.
    """

    name: str = Field(
        ..., description="The file's basename, including extension", title='Name'
    )
    role: ProtocolFileRole = Field(..., description="The file's role in the protocol.")


class ProtocolLinks(BaseModel):
    """
    Links returned along with a protocol resource.
    """

    referencingRuns: list[RunLink] = Field(
        ...,
        description='Links to runs that reference the protocol, in order from the oldest run to the newest run.',
        title='Referencingruns',
    )


class ReadAbsorbance(BaseModel):
    """
    A command to execute an Absorbance Reader measurement.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['absorbanceReader/read'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: ReadAbsorbanceParams
    result: ReadAbsorbanceResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class ReadAbsorbanceCreate(BaseModel):
    """
    A request to execute an Absorbance Reader measurement.
    """

    commandType: Literal['absorbanceReader/read'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: ReadAbsorbanceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class ReloadLabware(BaseModel):
    """
    Reload labware command resource model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['reloadLabware'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: ReloadLabwareParams
    result: ReloadLabwareResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class ReloadLabwareCreate(BaseModel):
    """
    Reload labware command creation request.
    """

    commandType: Literal['reloadLabware'] = Field(..., const=True, title='Commandtype')
    params: ReloadLabwareParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class RequestModelRunUpdate(BaseModel):
    data: RunUpdate = Field(..., description="the document’s 'primary data'")


class RequestModelSystemTimeAttributes(BaseModel):
    data: SystemTimeAttributes = Field(..., description="the document’s 'primary data'")


class RequestModelUnionStoredLabwareOffsetCreateListStoredLabwareOffsetCreate(
    BaseModel
):
    data: StoredLabwareOffsetCreate | list[StoredLabwareOffsetCreate] = Field(
        ..., description="the document’s 'primary data'", title='Data'
    )


class RetractAspirate(BaseModel):
    """
    Shared properties for the retract function after aspiration.
    """

    class Config:
        extra = Extra.forbid

    end_position: TipPosition = Field(
        ..., description='Tip position at the end of the retract.'
    )
    speed: Speed2 | Speed3 = Field(
        ...,
        description='Speed of retraction, in millimeters per second.',
        title='Speed',
    )
    air_gap_by_volume: list[AirGapByVolumeItem] = Field(
        ...,
        description='Settings for air gap keyed by target aspiration volume.',
        title='Air Gap By Volume',
    )
    touch_tip: TouchTipProperties = Field(
        ..., description='Touch tip settings for retract after aspirate.'
    )
    delay: DelayProperties = Field(
        ..., description='Delay settings for retract after aspirate.'
    )


class RetractAxis(BaseModel):
    """
    Command to retract the specified axis to its home position.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['retractAxis'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: RetractAxisParams
    result: RetractAxisResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class RetractAxisCreate(BaseModel):
    """
    Data to create a Retract Axis command.
    """

    commandType: Literal['retractAxis'] = Field(..., const=True, title='Commandtype')
    params: RetractAxisParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class RetractDispense(BaseModel):
    """
    Shared properties for the retract function after dispense.
    """

    class Config:
        extra = Extra.forbid

    end_position: TipPosition = Field(
        ..., description='Tip position at the end of the retract.'
    )
    speed: Speed4 | Speed5 = Field(
        ...,
        description='Speed of retraction, in millimeters per second.',
        title='Speed',
    )
    air_gap_by_volume: list[AirGapByVolumeItem5] = Field(
        ...,
        description='Settings for air gap keyed by target aspiration volume.',
        title='Air Gap By Volume',
    )
    blowout: BlowoutProperties = Field(
        ..., description='Blowout properties for retract after dispense.'
    )
    touch_tip: TouchTipProperties = Field(
        ..., description='Touch tip settings for retract after dispense.'
    )
    delay: DelayProperties = Field(
        ..., description='Delay settings for retract after dispense.'
    )


class Retrieve(BaseModel):
    """
    A command to retrieve a labware from a Flex Stacker.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['flexStacker/retrieve'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: RetrieveParams
    result: RetrieveResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class RetrieveCreate(BaseModel):
    """
    A request to execute a Flex Stacker retrieve command.
    """

    commandType: Literal['flexStacker/retrieve'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: RetrieveParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class RobotPositions(BaseModel):
    change_pipette: ChangePipette
    attach_tip: AttachTip


class RobotPositionsResponse(BaseModel):
    positions: RobotPositions


class RunAction(BaseModel):
    """
    Run control action model.

    A RunAction resource represents a client-provided command to
    the run in order to control the execution of the run itself.

    This is different than a protocol command, which represents an individual
    robotic procedure to execute as part of a protocol.
    """

    id: str = Field(
        ..., description='A unique identifier to reference the command.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When the command was created.', title='Createdat'
    )
    actionType: RunActionType


class RunActionCreate(BaseModel):
    """
    Request model for new control action creation.
    """

    actionType: RunActionType


class RunCurrentState(BaseModel):
    """
    Current details about a run.
    """

    estopEngaged: bool = Field(..., title='Estopengaged')
    activeNozzleLayouts: dict[str, ActiveNozzleLayout] = Field(
        ..., title='Activenozzlelayouts'
    )
    tipStates: dict[str, TipState] = Field(..., title='Tipstates')
    placeLabwareState: PlaceLabwareState | None
    flexStackerStates: dict[str, FlexStackerState] | None = Field(
        ..., title='Flexstackerstates'
    )


class RunExtendedProfileParams(BaseModel):
    """
    Input parameters for an individual Thermocycler profile step.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler.', title='Moduleid'
    )
    profileElements: list[ProfileStep | ProfileCycle] = Field(
        ...,
        description='Elements of the profile. Each can be either a step or a cycle.',
        title='Profileelements',
    )
    blockMaxVolumeUl: float | None = Field(
        None,
        description='Amount of liquid in uL of the most-full well in labware loaded onto the thermocycler.',
        title='Blockmaxvolumeul',
    )


class RunProfileParams(BaseModel):
    """
    Input parameters to run a Thermocycler profile.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Thermocycler.', title='Moduleid'
    )
    profile: list[RunProfileStepParams] = Field(
        ...,
        description='Array of profile steps with target temperature and temperature hold time.',
        title='Profile',
    )
    blockMaxVolumeUl: float | None = Field(
        None,
        description='Amount of liquid in uL of the most-full well in labware loaded onto the thermocycler.',
        title='Blockmaxvolumeul',
    )


class SavePosition(BaseModel):
    """
    Save Position command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['savePosition'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SavePositionParams
    result: SavePositionResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SavePositionCreate(BaseModel):
    """
    Save position command creation request model.
    """

    commandType: Literal['savePosition'] = Field(..., const=True, title='Commandtype')
    params: SavePositionParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SealPipetteToTipParams(BaseModel):
    """
    Payload needed to seal resin tips to a pipette.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: PickUpTipWellLocation | None = Field(
        None, description='Relative well location at which to pick up the tip.'
    )
    tipPickUpParams: TipPickUpParams | None = Field(
        None, description='Specific parameters for '
    )


class SearchCreate(BaseModel):
    """
    A search query for labware offsets.
    """

    filters: list[SearchFilter] = Field(
        ...,
        description="A list of filters to search by.\n\nA result is returned if it passes any of these filters\n(in other words, these filters are OR'd together).\nIf this list is empty, no results are returned.\n",
        title='Filters',
    )


class SessionCommandRequestLiteralSetHasCalibrationBlockSetHasCalibrationBlockRequestDataEmptyModel(
    BaseModel
):
    command: Command8 = Field(
        'calibration.setHasCalibrationBlock',
        const=True,
        description='The command description',
        title='Command',
    )
    data: SetHasCalibrationBlockRequestData = Field(..., description='The command data')


class SessionCommandResponseLiteralJogJogPositionEmptyModel(BaseModel):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command13 = Field('calibration.jog', const=True, title='Command')
    data: JogPosition
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: EmptyModel | None = None


class SessionCommandResponseLiteralLoadLabwareLoadLabwareByDefinitionRequestDataEmptyModel(
    BaseModel
):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command14 = Field('calibration.loadLabware', const=True, title='Command')
    data: LoadLabwareByDefinitionRequestData
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: EmptyModel | None = None


class SessionCommandResponseLiteralSetHasCalibrationBlockSetHasCalibrationBlockRequestDataEmptyModel(
    BaseModel
):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command18 = Field(
        'calibration.setHasCalibrationBlock', const=True, title='Command'
    )
    data: SetHasCalibrationBlockRequestData
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: EmptyModel | None = None


class SessionCommandResponseLiteralStartRunStartSimulateCancelPauseResumeMoveToTipRackMoveToPointOneMoveToDeckMoveToReferencePointPickUpTipConfirmTipAttachedInvalidateTipSaveOffsetExitInvalidateLastActionMoveToPointTwoMoveToPointThreeComparePointSwitchPipetteReturnTipTransitionEmptyModelEmptyModel(
    BaseModel
):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command19 = Field(..., title='Command')
    data: EmptyModel
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: EmptyModel | None = None


class SetAndWaitForShakeSpeed(BaseModel):
    """
    A command to set and wait for a Heater-Shaker's shake speed.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/setAndWaitForShakeSpeed'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SetAndWaitForShakeSpeedParams
    result: SetAndWaitForShakeSpeedResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SetAndWaitForShakeSpeedCreate(BaseModel):
    """
    A request to create a Heater-Shaker's set and wait for shake speed command.
    """

    commandType: Literal['heaterShaker/setAndWaitForShakeSpeed'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: SetAndWaitForShakeSpeedParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SetRailLights(BaseModel):
    """
    setRailLights command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['setRailLights'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SetRailLightsParams
    result: SetRailLightsResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SetRailLightsCreate(BaseModel):
    """
    setRailLights command request model.
    """

    commandType: Literal['setRailLights'] = Field(..., const=True, title='Commandtype')
    params: SetRailLightsParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SetStatusBarParams(BaseModel):
    """
    Payload required to set the status bar to run an animation.
    """

    animation: StatusBarAnimation = Field(
        ..., description='The animation that should be executed on the status bar.'
    )


class SetStoredLabwareParams(BaseModel):
    """
    Input parameters for a setStoredLabware command.
    """

    moduleId: str = Field(
        ..., description='Unique ID of the Flex Stacker.', title='Moduleid'
    )
    primaryLabware: StackerStoredLabwareDetails = Field(
        ...,
        description='The details of the primary labware (i.e. not the lid or adapter, if any) stored in the stacker.',
    )
    lidLabware: StackerStoredLabwareDetails | None = Field(
        None,
        description='The details of the lid on the primary labware, if any.',
        title='Lidlabware',
    )
    adapterLabware: StackerStoredLabwareDetails | None = Field(
        None,
        description='The details of the adapter under the primary labware, if any.',
        title='Adapterlabware',
    )
    initialCount: InitialCount | None = Field(
        None,
        description='The number of labware that should be initially stored in the stacker. This number will be silently clamped to\nthe maximum number of labware that will fit; do not rely on the parameter to know how many labware are in the stacker.\n\nThis field works with the initialStoredLabware field in a complex way.\n\nThe following must be true for initialCount to be valid:\n  - It is not specified, and initialStoredLabware is not specified, in which case the stacker will start empty\n  - It is not specified, and initialStoredLabware is specified, in which case the contents of the stacker are entirely\n    determined by initialStoredLabware.\n  - It is specified, and initialStoredLabware is specified, in which case the length of initialStoredLabware must be\n    exactly initialCount, and the contents of the stacker will be determined by initialStoredLabware.\n',
        title='Initialcount',
    )
    initialStoredLabware: list[StackerStoredLabwareGroup] | None = Field(
        None,
        description='A list of IDs that should be initially stored in the stacker.\n\nIf specified, the first element of the list is the labware on the physical bottom that will be the first labware retrieved.\n\nThis is a complex field. The following must be true for the field to be valid:\n- If this field is specified, then either initialCount must not be specified, or this field must have exactly initalCount elements\n- Each element must contain an id for each corresponding labware details field (i.e. if lidLabware is specified, each element must have\n  a lidLabwareId) and must not contain an id for a corresponding labware details field that is not specified (i.e., if adapterLabware\n  is not specified, each element must not have an adapterLabwareId).\n\nThe behavior of the command depends on the values of both this field and initialCount.\n- If this field is not specified and initialCount is not specified, the command will create the maximum number of labware objects\n  the stacker can hold according to the labware pool specifications.\n- If this field is not specified and initialCount is specified to be 0, the command will create 0 labware objects and the stacker will be empty.\n- If this field is not specified and initialCount is specified to be non-0, the command will create initialCount labware objects of\n  each specified labware type (primary, lid, and adapter), with appropriate positions, and arbitrary IDs, loaded into the stacker\n- If this field is specified (and therefore initialCount is not specified or is specified to be the length of this field) then the\n  command will create labware objects with the IDs specified in this field and appropriate positions, loaded into the stacker.\n\nBehavior is also different depending on whether the labware identified by ID in this field exist or not. Either all labware specified\nin this field must exist, or all must not exist.\n\nFurther,\n- If the labware exist, they must be of the same type as identified in the primaryLabware field.\n- If the labware exist and the adapterLabware field is specified, each labware must be currently loaded on a labware of the same kind as\n  specified in the adapterLabware field, and that labware must be loaded off-deck\n- If the labware exist and the adapterLabware field is not specified, each labware must be currently loaded off deck directly\n- If the labware exist and the lidLabware field is specified, each labware must currently have a loaded lid of the same kind as specified\n  in the lidLabware field\n- If the labware exist and the lidLabware field is not specified, each labware must not currently have a lid\n- If the labware exist, they must have nothing loaded underneath them or above them other than what is mentioned above\n\nIf all the above are true, when this command executes the labware will be immediately moved into InStackerHopper. If any of the above\nare not true, analysis will fail.\n',
        title='Initialstoredlabware',
    )
    poolOverlapOverride: float | None = Field(
        None,
        description='Override for the Z stacking overlap of the labware pool. If not provided, the protocol engine will calculate the overlap based on the stacking offsets provided in the labware definitions.',
        title='Pooloverlapoverride',
    )


class SetTargetBlockTemperature(BaseModel):
    """
    A command to set a Thermocycler's target block temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/setTargetBlockTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SetTargetBlockTemperatureParams
    result: SetTargetBlockTemperatureResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SetTargetBlockTemperatureCreate(BaseModel):
    """
    A request to create a Thermocycler's set block temperature command.
    """

    commandType: Literal['thermocycler/setTargetBlockTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: SetTargetBlockTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SetTargetLidTemperature(BaseModel):
    """
    A command to set a Thermocycler's target lid temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/setTargetLidTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SetTargetLidTemperatureParams
    result: SetTargetLidTemperatureResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SetTargetLidTemperatureCreate(BaseModel):
    """
    A request to create a Thermocycler's set lid temperature command.
    """

    commandType: Literal['thermocycler/setTargetLidTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: SetTargetLidTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SimpleBodyDataFile(BaseModel):
    data: DataFile = Field(..., description='The document’s primary data')


class SimpleBodyPresentSubsystem(BaseModel):
    data: PresentSubsystem = Field(..., description='The document’s primary data')


class SimpleBodyRunAction(BaseModel):
    data: RunAction = Field(..., description='The document’s primary data')


class SimpleMultiBodyDataFile(BaseModel):
    data: list[DataFile] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimpleMultiBodyPresentSubsystem(BaseModel):
    data: list[PresentSubsystem] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SlotFootprintAsChildFeature(BaseModel):
    z: float = Field(..., title='Z')
    backLeft: Vector2D
    frontRight: Vector2D
    springDirectionalForce: SpringDirectionalForce = Field(
        'backLeftBottom', const=True, title='Springdirectionalforce'
    )


class SlotFootprintAsParentFeature(BaseModel):
    z: float = Field(..., title='Z')
    backLeft: Vector2D
    frontRight: Vector2D
    springDirectionalForce: SpringDirectionalForce = Field(
        'backLeftBottom', const=True, title='Springdirectionalforce'
    )


class Store(BaseModel):
    """
    A command to store a labware in a Flex Stacker.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['flexStacker/store'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: StoreParams
    result: StoreResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class StoreCreate(BaseModel):
    """
    A request to execute a Flex Stacker store command.
    """

    commandType: Literal['flexStacker/store'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: StoreParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LocationSequence41(BaseModel):
    __root__: (
        OnLabwareOffsetLocationSequenceComponent
        | OnModuleOffsetLocationSequenceComponent
        | OnAddressableAreaOffsetLocationSequenceComponent
        | UnknownLabwareOffsetLocationSequenceComponent
    ) = Field(..., discriminator='kind')


class LocationSequence4(BaseModel):
    __root__: list[LocationSequence41] = Field(
        ...,
        description='Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location.',
        min_items=1,
        title='Locationsequence',
    )


class StoredLabwareOffset(BaseModel):
    """
    An offset that the robot adds to a pipette's position when it moves to labware.
    """

    id: str = Field(
        ..., description='Unique labware offset record identifier.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When this labware offset was added.', title='Createdat'
    )
    definitionUri: str = Field(
        ..., description="The URI for the labware's definition.", title='Definitionuri'
    )
    locationSequence: LocationSequence4 | LocationSequence5 = Field(
        ...,
        description='Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location.',
        title='Locationsequence',
    )
    vector: LabwareOffsetVector = Field(
        ..., description='The offset applied to matching labware.'
    )


class Submerge(BaseModel):
    """
    Shared properties for the submerge function before aspiration or dispense.
    """

    class Config:
        extra = Extra.forbid

    start_position: TipPosition = Field(
        ..., description='Tip position before starting the submerge.'
    )
    speed: Speed6 | Speed7 = Field(
        ...,
        description='Speed of submerging, in millimeters per second.',
        title='Speed',
    )
    delay: DelayProperties = Field(..., description='Delay settings for submerge.')


class TemperatureModuleData(BaseModel):
    """
    Live data from an attached Temperature Module.
    """

    status: TemperatureStatus
    currentTemperature: float = Field(
        ...,
        description="The module's current temperature, in degrees Celsius.",
        title='Currenttemperature',
    )
    targetTemperature: float | None = Field(
        ...,
        description="The module's target temperature, if set, in degrees Celsius.",
        title='Targettemperature',
    )


class ThermocyclerModule(BaseModel):
    """
    An attached Thermocycler Module.
    """

    id: str = Field(
        ...,
        description='Unique module identifier for use in requests to /modules and /commands.',
        title='Id',
    )
    serialNumber: str = Field(
        ..., description='Device serial number.', title='Serialnumber'
    )
    firmwareVersion: str = Field(
        ..., description='Device firmware version.', title='Firmwareversion'
    )
    hardwareRevision: str = Field(
        ..., description='Device hardware revision.', title='Hardwarerevision'
    )
    hasAvailableUpdate: bool = Field(
        ...,
        description='Whether a firmware update is available.',
        title='Hasavailableupdate',
    )
    moduleType: ModuleType5 = Field(
        'thermocyclerModuleType', const=True, title='Moduletype'
    )
    moduleModel: ModuleModel5 = Field(..., title='Modulemodel')
    moduleOffset: ModuleCalibrationData | None = Field(
        None, description='The calibrated module offset.'
    )
    compatibleWithRobot: bool = Field(
        ...,
        description='Whether the detected module is compatible with this robot.',
        title='Compatiblewithrobot',
    )
    data: ThermocyclerModuleData
    usbPort: UsbPort


class TipCalibrationSessionStatus(BaseModel):
    """
    The current status of a tip length calibration session.
    """

    instrument: RobotServerRobotCalibrationHelperClassesAttachedPipette
    currentStep: str = Field(
        ...,
        description='Current step of tip calibration user flow',
        title='Currentstep',
    )
    nextSteps: NextSteps | None = Field(
        None, description='Next Available Steps in Session'
    )
    labware: list[RequiredLabware] = Field(..., title='Labware')
    supportedCommands: list[str] = Field(
        ...,
        description='A list of supported commands for this user flow',
        title='Supportedcommands',
    )


class TipLengthCalibration(BaseModel):
    """
    A model describing tip length calibration
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    tipLength: float = Field(
        ..., description='The tip length value in mm', title='Tiplength'
    )
    tiprack: str = Field(
        ...,
        deprecated=True,
        description='A hash of the labware definition of the tip rack that was used in this calibration. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `uri` instead.',
        title='Tiprack',
    )
    pipette: str = Field(..., description='The pipette ID', title='Pipette')
    lastModified: datetime = Field(
        ..., description='When this calibration was last modified', title='Lastmodified'
    )
    source: SourceType = Field(..., description='The calibration source')
    status: RobotServerServiceSharedModelsCalibrationCalibrationStatus = Field(
        ..., description='The status of this calibration'
    )
    uri: str = Field(..., description='The uri of the tiprack', title='Uri')


class TipLengthCalibrationCreateAttributes(BaseModel):
    """
    The tip length calibration create request.
    """

    sessionType: SessionType7 = Field(
        'tipLengthCalibration', const=True, title='Sessiontype'
    )
    createParams: RobotServerRobotCalibrationModelsSessionCreateParams


class TipLengthCalibrationResponseAttributes(BaseModel):
    """
    Response attributes of tip length calibration session.
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    createdAt: datetime = Field(
        ...,
        description='Date and time that this session was created',
        title='Createdat',
    )
    sessionType: SessionType7 = Field(
        'tipLengthCalibration', const=True, title='Sessiontype'
    )
    createParams: RobotServerRobotCalibrationModelsSessionCreateParams
    details: TipCalibrationSessionStatus


class UnsafeBlowOutInPlace(BaseModel):
    """
    UnsafeBlowOutInPlace command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/blowOutInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeBlowOutInPlaceParams
    result: UnsafeBlowOutInPlaceResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeBlowOutInPlaceCreate(BaseModel):
    """
    UnsafeBlowOutInPlace command request model.
    """

    commandType: Literal['unsafe/blowOutInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeBlowOutInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafeDropTipInPlace(BaseModel):
    """
    Drop tip in place command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/dropTipInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeDropTipInPlaceParams
    result: UnsafeDropTipInPlaceResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeDropTipInPlaceCreate(BaseModel):
    """
    Drop tip in place command creation request model.
    """

    commandType: Literal['unsafe/dropTipInPlace'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeDropTipInPlaceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafeEngageAxes(BaseModel):
    """
    UnsafeEngageAxes command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/engageAxes'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeEngageAxesParams
    result: UnsafeEngageAxesResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeEngageAxesCreate(BaseModel):
    """
    UnsafeEngageAxes command request model.
    """

    commandType: Literal['unsafe/engageAxes'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeEngageAxesParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafeFlexStackerCloseLatch(BaseModel):
    """
    A command to UnsafeFlexStackerCloseLatch the Flex Stacker of labware.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/flexStacker/closeLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeFlexStackerCloseLatchParams
    result: UnsafeFlexStackerCloseLatchResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeFlexStackerCloseLatchCreate(BaseModel):
    """
    A request to execute a Flex Stacker UnsafeFlexStackerCloseLatch command.
    """

    commandType: Literal['unsafe/flexStacker/closeLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeFlexStackerCloseLatchParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafeFlexStackerManualRetrieve(BaseModel):
    """
    A command to manually retrieve a labware from a Flex Stacker.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/flexStacker/manualRetrieve'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeFlexStackerManualRetrieveParams
    result: UnsafeFlexStackerManualRetrieveResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeFlexStackerManualRetrieveCreate(BaseModel):
    """
    A request to execute a Flex Stacker manual retrieve command.
    """

    commandType: Literal['unsafe/flexStacker/manualRetrieve'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeFlexStackerManualRetrieveParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafeFlexStackerOpenLatch(BaseModel):
    """
    A command to UnsafeFlexStackerOpenLatch the Flex Stacker of labware.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/flexStacker/openLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeFlexStackerOpenLatchParams
    result: UnsafeFlexStackerOpenLatchResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeFlexStackerOpenLatchCreate(BaseModel):
    """
    A request to execute a Flex Stacker UnsafeFlexStackerOpenLatch command.
    """

    commandType: Literal['unsafe/flexStacker/openLatch'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeFlexStackerOpenLatchParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafeFlexStackerPrepareShuttle(BaseModel):
    """
    A command to prepare Flex Stacker shuttle.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/flexStacker/prepareShuttle'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeFlexStackerPrepareShuttleParams
    result: UnsafeFlexStackerPrepareShuttleResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeFlexStackerPrepareShuttleCreate(BaseModel):
    """
    A request to execute a Flex Stacker UnsafeFlexStackerPrepareShuttle command.
    """

    commandType: Literal['unsafe/flexStacker/prepareShuttle'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeFlexStackerPrepareShuttleParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsafePlaceLabwareParams(BaseModel):
    """
    Payload required for an UnsafePlaceLabware command.
    """

    labwareURI: str = Field(
        ..., description='Labware URI for labware.', title='Labwareuri'
    )
    location: (
        DeckSlotLocation | ModuleLocation | OnLabwareLocation | AddressableAreaLocation
    ) = Field(..., description='Where to place the labware.', title='Location')


class UnsafeUngripLabware(BaseModel):
    """
    UnsafeUngripLabware command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/ungripLabware'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafeUngripLabwareParams
    result: UnsafeUngripLabwareResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafeUngripLabwareCreate(BaseModel):
    """
    UnsafeEngageAxes command request model.
    """

    commandType: Literal['unsafe/ungripLabware'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafeUngripLabwareParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsealPipetteFromTipParams(BaseModel):
    """
    Payload required to drop a tip in a specific well.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: DropTipWellLocation | None = Field(
        None, description='Relative well location at which to drop the tip.'
    )


class UpdatePositionEstimators(BaseModel):
    """
    UpdatePositionEstimators command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/updatePositionEstimators'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UpdatePositionEstimatorsParams
    result: UpdatePositionEstimatorsResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UpdatePositionEstimatorsCreate(BaseModel):
    """
    UpdatePositionEstimators command request model.
    """

    commandType: Literal['unsafe/updatePositionEstimators'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UpdatePositionEstimatorsParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UpdateProgressData(BaseModel):
    """
    Model for status of firmware update progress.
    """

    id: str = Field(..., description='Unique ID for the update process.', title='Id')
    createdAt: datetime = Field(
        ..., description='When the update was posted.', title='Createdat'
    )
    subsystem: SubSystem = Field(
        ..., description='The subsystem that is being updated.'
    )
    updateStatus: UpdateState = Field(
        ..., description='Whether an update is queued, in progress or completed. '
    )
    updateProgress: int = Field(
        ...,
        description='Progress of the update depicted as an integer from 0 to 100.',
        title='Updateprogress',
    )
    updateError: str | None = Field(
        ...,
        description='If the process failed, this will contain a string description of the reason.',
        title='Updateerror',
    )


class UpdateProgressSummary(BaseModel):
    """
    Model for a quick summary of an update's progress.
    """

    id: str = Field(..., description='Unique ID for the update process.', title='Id')
    createdAt: datetime = Field(
        ..., description='When the update was posted.', title='Createdat'
    )
    subsystem: SubSystem = Field(
        ..., description='The subsystem that is being updated.'
    )
    updateStatus: UpdateState = Field(
        ..., description='Whether an update is queued, in progress or completed'
    )


class VerifyTipPresence(BaseModel):
    """
    VerifyTipPresence command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['verifyTipPresence'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: VerifyTipPresenceParams
    result: VerifyTipPresenceResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class VerifyTipPresenceCreate(BaseModel):
    """
    VerifyTipPresence command creation request model.
    """

    commandType: Literal['verifyTipPresence'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: VerifyTipPresenceParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class WaitForBlockTemperature(BaseModel):
    """
    A command to wait for a Thermocycler's target block temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/waitForBlockTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: WaitForBlockTemperatureParams
    result: WaitForBlockTemperatureResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class WaitForBlockTemperatureCreate(BaseModel):
    """
    A request to create Thermocycler's wait for block temperature command.
    """

    commandType: Literal['thermocycler/waitForBlockTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: WaitForBlockTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class WaitForDuration(BaseModel):
    """
    Wait for duration command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['waitForDuration'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: WaitForDurationParams
    result: WaitForDurationResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class WaitForDurationCreate(BaseModel):
    """
    Wait for duration command request model.
    """

    commandType: Literal['waitForDuration'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: WaitForDurationParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class WaitForLidTemperature(BaseModel):
    """
    A command to wait for a Thermocycler's lid temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/waitForLidTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: WaitForLidTemperatureParams
    result: WaitForLidTemperatureResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class WaitForLidTemperatureCreate(BaseModel):
    """
    A request to create Thermocycler's wait for lid temperature command.
    """

    commandType: Literal['thermocycler/waitForLidTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: WaitForLidTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class WaitForResume(BaseModel):
    """
    Wait for resume command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['pause', 'waitForResume'] = Field(..., title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: WaitForResumeParams
    result: WaitForResumeResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class WaitForResumeCreate(BaseModel):
    """
    Wait for resume command request model.
    """

    commandType: Literal['pause', 'waitForResume'] = Field(..., title='Commandtype')
    params: WaitForResumeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class WellLocation(BaseModel):
    """
    A relative location in reference to a well's location.
    """

    origin: WellOrigin | None = 'top'
    offset: WellOffset | None = None
    volumeOffset: float | None = Field(
        0,
        description='A volume of liquid, in µL, to offset the z-axis offset.',
        title='Volumeoffset',
    )


class OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLid(BaseModel):
    """
    A command to close the lid on an Absorbance Reader.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['absorbanceReader/closeLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidParams
    result: (
        OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidResult | None
    ) = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidCreate(BaseModel):
    """
    A request to execute an Absorbance Reader close lid command.
    """

    commandType: Literal['absorbanceReader/closeLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLid(BaseModel):
    """
    A command to open the lid on an Absorbance Reader.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['absorbanceReader/openLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidParams
    result: (
        OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidResult | None
    ) = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidCreate(BaseModel):
    """
    A request to execute an Absorbance Reader open lid command.
    """

    commandType: Literal['absorbanceReader/openLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperature(
    BaseModel
):
    """
    A command to set a Heater-Shaker's target temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/setTargetTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureParams
    result: (
        OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureResult
        | None
    ) = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureCreate(
    BaseModel
):
    """
    A request to create a Heater-Shaker's set temperature command.
    """

    commandType: Literal['heaterShaker/setTargetTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperature(
    BaseModel
):
    """
    A command to wait for a Heater-Shaker's target temperature to be reached.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['heaterShaker/waitForTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureParams
    result: (
        OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureResult
        | None
    ) = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureCreate(
    BaseModel
):
    """
    A request to create a Heater-Shaker's wait for temperature command.
    """

    commandType: Literal['heaterShaker/waitForTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperature(
    BaseModel
):
    """
    A command to set a Temperature Module's target temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['temperatureModule/setTargetTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureParams
    result: (
        OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureResult
        | None
    ) = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureCreate(
    BaseModel
):
    """
    A request to create a Temperature Module's set temperature command.
    """

    commandType: Literal['temperatureModule/setTargetTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperature(
    BaseModel
):
    """
    A command to wait for a Temperature Module's target temperature.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['temperatureModule/waitForTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureParams
    result: (
        OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureResult
        | None
    ) = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureCreate(
    BaseModel
):
    """
    A request to create a Temperature Module's wait for temperature command.
    """

    commandType: Literal['temperatureModule/waitForTemperature'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLid(BaseModel):
    """
    A command to close a Thermocycler's lid.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/closeLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidParams
    result: OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidResult | None = (
        None
    )
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidCreate(BaseModel):
    """
    A request to close a Thermocycler's lid.
    """

    commandType: Literal['thermocycler/closeLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLid(BaseModel):
    """
    A command to open a Thermocycler's lid.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/openLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidParams
    result: OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidResult | None = (
        None
    )
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidCreate(BaseModel):
    """
    A request to open a Thermocycler's lid.
    """

    commandType: Literal['thermocycler/openLid'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class RobotServerErrorsErrorResponsesErrorBodyCommandNotAllowed1(BaseModel):
    errors: list[RobotServerRunsRouterCommandsRouterCommandNotAllowed] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerErrorsErrorResponsesErrorBodyCommandNotAllowed2(BaseModel):
    errors: list[RobotServerMaintenanceRunsRouterCommandsRouterCommandNotAllowed] = (
        Field(..., description='Error details.', title='Errors')
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerErrorsErrorResponsesErrorBodyCommandNotFound1(BaseModel):
    errors: list[RobotServerRunsRouterCommandsRouterCommandNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerErrorsErrorResponsesErrorBodyCommandNotFound2(BaseModel):
    errors: list[RobotServerMaintenanceRunsRouterCommandsRouterCommandNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerErrorsErrorResponsesErrorBodyRunNotFound1(BaseModel):
    errors: list[RobotServerRunsRouterBaseRouterRunNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerErrorsErrorResponsesErrorBodyRunNotFound2(BaseModel):
    errors: list[RobotServerMaintenanceRunsRouterBaseRouterRunNotFound] = Field(
        ..., description='Error details.', title='Errors'
    )
    links: dict[str, ResourceLink] | None = Field(
        None,
        description='Links that leads to further details about this particular occurrence of the problem.',
        title='Links',
    )


class RobotServerServiceLegacyModelsDeckCalibrationCalibrationStatus(BaseModel):
    """
    The calibration status
    """

    deckCalibration: DeckCalibrationStatus
    instrumentCalibration: InstrumentCalibrationStatus


class AbsorbanceReaderModule(BaseModel):
    """
    An attached Absorbance Reader Module.
    """

    id: str = Field(
        ...,
        description='Unique module identifier for use in requests to /modules and /commands.',
        title='Id',
    )
    serialNumber: str = Field(
        ..., description='Device serial number.', title='Serialnumber'
    )
    firmwareVersion: str = Field(
        ..., description='Device firmware version.', title='Firmwareversion'
    )
    hardwareRevision: str = Field(
        ..., description='Device hardware revision.', title='Hardwarerevision'
    )
    hasAvailableUpdate: bool = Field(
        ...,
        description='Whether a firmware update is available.',
        title='Hasavailableupdate',
    )
    moduleType: ModuleType = Field(
        'absorbanceReaderType', const=True, title='Moduletype'
    )
    moduleModel: ModuleModel = Field(
        'absorbanceReaderV1', const=True, title='Modulemodel'
    )
    moduleOffset: ModuleCalibrationData | None = Field(
        None, description='The calibrated module offset.'
    )
    compatibleWithRobot: bool = Field(
        ...,
        description='Whether the detected module is compatible with this robot.',
        title='Compatiblewithrobot',
    )
    data: AbsorbanceReaderModuleData
    usbPort: UsbPort


class AnalysisSummary(BaseModel):
    """
    Base model for an analysis of a protocol.
    """

    id: str = Field(
        ..., description='Unique identifier of this analysis resource', title='Id'
    )
    status: AnalysisStatus = Field(..., description='Status of the analysis')
    runTimeParameters: (
        list[NumberParameter | EnumParameter | BooleanParameter | CSVParameter] | None
    ) = Field(
        None,
        description='Run time parameters used during analysis. These are the parameters that are defined in the protocol, with values specified either in the protocol creation request or reanalysis request (whichever started this analysis), or default values from the protocol if none are specified in the request.',
        title='Runtimeparameters',
    )


class AspirateParams(BaseModel):
    """
    Parameters required to aspirate from a specific well.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: LiquidHandlingWellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description="The amount of liquid to aspirate, in µL. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors.",
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class AspirateProperties(BaseModel):
    """
    Properties specific to the aspirate function.
    """

    class Config:
        extra = Extra.forbid

    submerge: Submerge = Field(..., description='Submerge settings for aspirate.')
    retract: RetractAspirate = Field(
        ..., description='Pipette retract settings after an aspirate.'
    )
    aspirate_position: TipPosition = Field(
        ..., description='Tip position during aspirate.'
    )
    flow_rate_by_volume: list[FlowRateByVolumeItem] = Field(
        ...,
        description='Settings for flow rate keyed by target aspiration volume.',
        title='Flow Rate By Volume',
    )
    correction_by_volume: list[CorrectionByVolumeItem] = Field(
        ...,
        description='Settings for volume correction keyed by by target aspiration volume, representing additional volume the plunger should move to accurately hit target volume.',
        title='Correction By Volume',
    )
    pre_wet: bool = Field(
        ..., description='Whether to perform a pre-wet action.', title='Pre Wet'
    )
    mix: MixProperties = Field(
        ..., description='Mixing settings for before an aspirate'
    )
    delay: DelayProperties = Field(..., description='Delay settings after an aspirate')


class AspirateWhileTrackingParams(BaseModel):
    """
    Parameters required to aspirate from a specific well.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: LiquidHandlingWellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description="The amount of liquid to aspirate, in µL. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors.",
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class BlowOutParams(BaseModel):
    """
    Payload required to blow-out a specific well.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: WellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class BodyRunCurrentStateCurrentStateLinks(BaseModel):
    data: RunCurrentState = Field(..., description='The document’s primary data')
    links: CurrentStateLinks = Field(
        ..., description='A links object related to the primary data.'
    )


class CalibrateGripperCreate(BaseModel):
    """
    A request to create a `calibrateGripper` command.
    """

    commandType: Literal['calibration/calibrateGripper'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: CalibrateGripperParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class CalibrateGripperResult(BaseModel):
    """
    The result of a successful `calibrateGripper` command.
    """

    jawOffset: Vec3f = Field(
        ...,
        description="The offset from the probe's nominal position to its actual measured position.",
    )
    savedCalibration: GripperCalibrationOffset | None = Field(
        None,
        description='Gripper calibration result data, when `otherJawOffset` is provided.',
        title='Savedcalibration',
    )


class CalibrateModuleCreate(BaseModel):
    """
    Create calibrate-module command request model.
    """

    commandType: Literal['calibration/calibrateModule'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: CalibrateModuleParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class CalibrateModuleResult(BaseModel):
    """
    Result data from the execution of a calibrate-module command.
    """

    moduleOffset: ModuleOffsetVector = Field(
        ..., description='Offset of calibrated module.'
    )
    location: DeckSlotLocation = Field(
        ..., description='The deck slot this module was calibrated in.'
    )


class CalibratePipette(BaseModel):
    """
    Calibrate-pipette command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['calibration/calibratePipette'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CalibratePipetteParams
    result: CalibratePipetteResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CalibratePipetteCreate(BaseModel):
    """
    Create calibrate-pipette command request model.
    """

    commandType: Literal['calibration/calibratePipette'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: CalibratePipetteParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class CalibrationCheckSessionStatus(BaseModel):
    """
    The current status of a given session.
    """

    instruments: list[CheckAttachedPipette] = Field(..., title='Instruments')
    activePipette: CheckAttachedPipette
    currentStep: str = Field(
        ..., description='Current step of session', title='Currentstep'
    )
    comparisonsByPipette: ComparisonStatePerPipette
    labware: list[RequiredLabware] = Field(..., title='Labware')
    activeTipRack: RequiredLabware
    supportedCommands: list[str] = Field(
        ...,
        description='A list of supported commands for this user flow',
        title='Supportedcommands',
    )


class CommandCollectionLinks(BaseModel):
    """
    Links returned along with a collection of commands.
    """

    current: CommandLink | None = Field(
        None,
        description='Information about the "current" command. The "current" command is the one that\'s running right now, or, if there is none, the one that was running most recently.',
    )
    currentlyRecoveringFrom: CommandLink | None = Field(
        None,
        description='Information about the command currently undergoing error recovery. This is basically the most recent protocol command to have failed, except that once you complete error recovery (see `GET /runs/{id}/actions`), this goes back to being `null` or omitted.',
    )


class ConfigureNozzleLayout(BaseModel):
    """
    Configure nozzle layout command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['configureNozzleLayout'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: ConfigureNozzleLayoutParams
    result: ConfigureNozzleLayoutResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class ConfigureNozzleLayoutCreate(BaseModel):
    """
    Configure nozzle layout creation request model.
    """

    commandType: Literal['configureNozzleLayout'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: ConfigureNozzleLayoutParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DeckCalibrationResponseAttributes(BaseModel):
    """
    Response attributes of deck calibration session.
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    createdAt: datetime = Field(
        ...,
        description='Date and time that this session was created',
        title='Createdat',
    )
    sessionType: SessionType2 = Field(
        'deckCalibration', const=True, title='Sessiontype'
    )
    createParams: FieldNoParams | None = None
    details: DeckCalibrationSessionStatus


class DeprecatedMultiResponseModelLabwareCalibration(BaseModel):
    data: list[LabwareCalibration] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class DeprecatedMultiResponseModelPipetteOffsetCalibration(BaseModel):
    data: list[PipetteOffsetCalibration] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class DeprecatedMultiResponseModelTipLengthCalibration(BaseModel):
    data: list[TipLengthCalibration] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class DispenseParams(BaseModel):
    """
    Payload required to dispense to a specific well.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: LiquidHandlingWellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description='The amount of liquid to dispense, in µL. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors.',
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    pushOut: float | None = Field(
        None,
        description='push the plunger a small amount farther than necessary for accurate low-volume dispensing',
        title='Pushout',
    )


class DispenseWhileTrackingParams(BaseModel):
    """
    Payload required to dispense to a specific well.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: LiquidHandlingWellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    flowRate: float = Field(
        ...,
        description='Speed in µL/s configured for the pipette',
        gt=0.0,
        title='Flowrate',
    )
    volume: float = Field(
        ...,
        description='The amount of liquid to dispense, in µL. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors.',
        ge=0.0,
        title='Volume',
    )
    correctionVolume: float | None = Field(
        None, description='The correction volume in uL.', title='Correctionvolume'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    pushOut: float | None = Field(
        None,
        description='push the plunger a small amount farther than necessary for accurate low-volume dispensing',
        title='Pushout',
    )


class DropTipParams(BaseModel):
    """
    Payload required to drop a tip in a specific well.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: DropTipWellLocation | None = Field(
        None, description='Relative well location at which to drop the tip.'
    )
    homeAfter: bool | None = Field(
        None,
        description="Whether to home this pipette's plunger after dropping the tip. You should normally leave this unspecified to let the robot choose a safe default depending on its hardware.",
        title='Homeafter',
    )
    alternateDropLocation: bool | None = Field(
        None,
        description='Whether to alternate location where tip is dropped within the labware. If True, this command will ignore the wellLocation provided and alternate between dropping tips at two predetermined locations inside the specified labware well. If False, the tip will be dropped at the top center of the well.',
        title='Alternatedroplocation',
    )
    scrape_tips: bool | None = Field(
        None,
        description="Whether or not to scrape off the tips with the ejector all the way down. If True, and the target location is a tip rack well, it will move the pipette. Towards the center of the tip rack with the ejector in the 'drop_tip' position. If False, no horizontal movement will occur.",
        title='Scrape Tips',
    )


class EapOptions(BaseModel):
    """
    An object describing all supported EAP variants and their parameters
    """

    options: list[EapVariant] = Field(..., title='Options')


class Empty(BaseModel):
    """
    A command to empty the Flex Stacker of labware.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['flexStacker/empty'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: EmptyParams
    result: EmptyResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class EmptyCreate(BaseModel):
    """
    A request to execute a Flex Stacker empty command.
    """

    commandType: Literal['flexStacker/empty'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: EmptyParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class ErrorRecoveryRule(BaseModel):
    """
    Model for new error recovery rule.
    """

    matchCriteria: MatchCriteria = Field(
        ..., description='The criteria that must be met for this rule to be applied.'
    )
    ifMatch: ReactionIfMatch


class Fill(BaseModel):
    """
    A command to fill the Flex Stacker with labware.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['flexStacker/fill'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: FillParams
    result: FillResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class FillCreate(BaseModel):
    """
    A request to execute a Flex Stacker fill command.
    """

    commandType: Literal['flexStacker/fill'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: FillParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class FlexStackerModule(BaseModel):
    """
    An attached Flex Stacker Module.
    """

    id: str = Field(
        ...,
        description='Unique module identifier for use in requests to /modules and /commands.',
        title='Id',
    )
    serialNumber: str = Field(
        ..., description='Device serial number.', title='Serialnumber'
    )
    firmwareVersion: str = Field(
        ..., description='Device firmware version.', title='Firmwareversion'
    )
    hardwareRevision: str = Field(
        ..., description='Device hardware revision.', title='Hardwarerevision'
    )
    hasAvailableUpdate: bool = Field(
        ...,
        description='Whether a firmware update is available.',
        title='Hasavailableupdate',
    )
    moduleType: ModuleType1 = Field(
        'flexStackerModuleType', const=True, title='Moduletype'
    )
    moduleModel: ModuleModel1 = Field(
        'flexStackerModuleV1', const=True, title='Modulemodel'
    )
    moduleOffset: ModuleCalibrationData | None = Field(
        None, description='The calibrated module offset.'
    )
    compatibleWithRobot: bool = Field(
        ...,
        description='Whether the detected module is compatible with this robot.',
        title='Compatiblewithrobot',
    )
    data: FlexStackerModuleData
    usbPort: UsbPort


class GetNextTipResult(BaseModel):
    """
    Result data from the execution of a GetNextTip.
    """

    nextTipInfo: NextTipInfo | NoTipAvailable = Field(
        ...,
        description='Labware ID and well name of next available tip for a pipette, or information why no tip could be resolved.',
        title='Nexttipinfo',
    )


class GetTipPresence(BaseModel):
    """
    GetTipPresence command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['getTipPresence'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: GetTipPresenceParams
    result: GetTipPresenceResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class GripperData(BaseModel):
    """
    Data from attached gripper.
    """

    jawState: str = Field(..., description='Gripper Jaw state.', title='Jawstate')
    calibratedOffset: InstrumentCalibrationData | None = Field(
        None, description='Calibrated gripper offset.'
    )


class HeaterShakerModule(BaseModel):
    """
    An attached Heater-Shaker Module.
    """

    id: str = Field(
        ...,
        description='Unique module identifier for use in requests to /modules and /commands.',
        title='Id',
    )
    serialNumber: str = Field(
        ..., description='Device serial number.', title='Serialnumber'
    )
    firmwareVersion: str = Field(
        ..., description='Device firmware version.', title='Firmwareversion'
    )
    hardwareRevision: str = Field(
        ..., description='Device hardware revision.', title='Hardwarerevision'
    )
    hasAvailableUpdate: bool = Field(
        ...,
        description='Whether a firmware update is available.',
        title='Hasavailableupdate',
    )
    moduleType: ModuleType2 = Field(
        'heaterShakerModuleType', const=True, title='Moduletype'
    )
    moduleModel: ModuleModel2 = Field(
        'heaterShakerModuleV1', const=True, title='Modulemodel'
    )
    moduleOffset: ModuleCalibrationData | None = Field(
        None, description='The calibrated module offset.'
    )
    compatibleWithRobot: bool = Field(
        ...,
        description='Whether the detected module is compatible with this robot.',
        title='Compatiblewithrobot',
    )
    data: HeaterShakerModuleData
    usbPort: UsbPort


class Home(BaseModel):
    """
    Command to send some (or all) motors to their home positions.

    Homing a motor re-establishes positional accuracy the first time a motor
    is used, or any time the motor "loses" its position, for example, after
    a halt or after a collision.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['home'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: HomeParams
    result: HomeResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class HomeCreate(BaseModel):
    """
    Data to create a Home command.
    """

    commandType: Literal['home'] = Field(..., const=True, title='Commandtype')
    params: HomeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class IdentifyModule(BaseModel):
    """
    A command to identify a module.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['identifyModule'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: IdentifyModuleParams
    result: IdentifyModuleResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class IdentifyModuleCreate(BaseModel):
    """
    A request to execute an IdentifyModule command.
    """

    commandType: Literal['identifyModule'] = Field(..., const=True, title='Commandtype')
    params: IdentifyModuleParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LabwareOffset(BaseModel):
    """
    An offset that the robot adds to a pipette's position when it moves to a labware.

    During the run, if a labware is loaded whose definition URI and location
    both match what's found here, the given offset will be added to all
    pipette movements that use that labware as a reference point.
    """

    id: str = Field(
        ..., description='Unique labware offset record identifier.', title='Id'
    )
    createdAt: datetime = Field(
        ..., description='When this labware offset was added.', title='Createdat'
    )
    definitionUri: str = Field(
        ..., description="The URI for the labware's definition.", title='Definitionuri'
    )
    location: LegacyLabwareOffsetLocation = Field(
        ...,
        deprecated=True,
        description='Where the labware is located on the robot. Deprecated and present only for backwards compatibility; cannot represent certain locations. Use locationSequence instead.',
    )
    locationSequence: list[LocationSequence] | None = Field(
        None,
        description='Where the labware is located on the robot. Can represent all locations, but may not be present for older runs.',
        title='Locationsequence',
    )
    vector: LabwareOffsetVector = Field(
        ..., description='The offset applied to matching labware.'
    )


class LegacyLabwareOffsetCreate(BaseModel):
    """
    Create request data for a labware offset with a legacy location field.
    """

    definitionUri: str = Field(
        ..., description="The URI for the labware's definition.", title='Definitionuri'
    )
    location: LegacyLabwareOffsetLocation = Field(
        ..., description='Where the labware is located on the robot.'
    )
    vector: LabwareOffsetVector = Field(
        ..., description='The offset applied to matching labware.'
    )


class LiquidProbeParams(BaseModel):
    """
    Parameters required for a `liquidProbe` command.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: WellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class LoadLabwareCreate(BaseModel):
    """
    Load labware command creation request.
    """

    commandType: Literal['loadLabware'] = Field(..., const=True, title='Commandtype')
    params: LoadLabwareParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LoadLidCreate(BaseModel):
    """
    Load lid command creation request.
    """

    commandType: Literal['loadLid'] = Field(..., const=True, title='Commandtype')
    params: LoadLidParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LoadLidStackCreate(BaseModel):
    """
    Load lid stack command creation request.
    """

    commandType: Literal['loadLidStack'] = Field(..., const=True, title='Commandtype')
    params: LoadLidStackParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LoadModule(BaseModel):
    """
    The model for a load module command.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadModule'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadModuleParams
    result: LoadModuleResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadModuleCreate(BaseModel):
    """
    The model for a creation request for a load module command.
    """

    commandType: Literal['loadModule'] = Field(..., const=True, title='Commandtype')
    params: LoadModuleParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LoadPipette(BaseModel):
    """
    Load pipette command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadPipette'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadPipetteParams
    result: LoadPipetteResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadPipetteCreate(BaseModel):
    """
    Load pipette command creation request model.
    """

    commandType: Literal['loadPipette'] = Field(..., const=True, title='Commandtype')
    params: LoadPipetteParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LocatingFeatures(BaseModel):
    """
    A dictionary of locating features.
    """

    slotFootprintAsChild: SlotFootprintAsChildFeature | None = None
    slotFootprintAsParent: SlotFootprintAsParentFeature | None = None
    springDirectionalForceAsParent: SpringDirectionalForceAsParent = Field(
        'backLeftBottom', const=True, title='Springdirectionalforceasparent'
    )
    opentronsFlexTipRackLidAsParent: OpentronsFlexTipRackLidAsParentFeature | None = (
        None
    )
    opentronsFlexTipRackLidAsChild: OpentronsFlexTipRackLidAsChildFeature | None = None


class MagneticModule(BaseModel):
    """
    An attached Magnetic Module.
    """

    id: str = Field(
        ...,
        description='Unique module identifier for use in requests to /modules and /commands.',
        title='Id',
    )
    serialNumber: str = Field(
        ..., description='Device serial number.', title='Serialnumber'
    )
    firmwareVersion: str = Field(
        ..., description='Device firmware version.', title='Firmwareversion'
    )
    hardwareRevision: str = Field(
        ..., description='Device hardware revision.', title='Hardwarerevision'
    )
    hasAvailableUpdate: bool = Field(
        ...,
        description='Whether a firmware update is available.',
        title='Hasavailableupdate',
    )
    moduleType: ModuleType3 = Field(
        'magneticModuleType', const=True, title='Moduletype'
    )
    moduleModel: ModuleModel3 = Field(..., title='Modulemodel')
    moduleOffset: ModuleCalibrationData | None = Field(
        None, description='The calibrated module offset.'
    )
    compatibleWithRobot: bool = Field(
        ...,
        description='Whether the detected module is compatible with this robot.',
        title='Compatiblewithrobot',
    )
    data: MagneticModuleData
    usbPort: UsbPort


class MaintenanceRunCreate(BaseModel):
    """
    Create request data for a new maintenance run.
    """

    labwareOffsets: list[LegacyLabwareOffsetCreate | LabwareOffsetCreate] | None = (
        Field(
            None,
            description='Labware offsets to apply as labware are loaded.',
            title='Labwareoffsets',
        )
    )


class MoveLabware(BaseModel):
    """
    A ``moveLabware`` command.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['moveLabware'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveLabwareParams
    result: MoveLabwareResult | None = None
    error: GripperMovementError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveLabwareCreate(BaseModel):
    """
    A request to create a ``moveLabware`` command.
    """

    commandType: Literal['moveLabware'] = Field(..., const=True, title='Commandtype')
    params: MoveLabwareParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveRelative(BaseModel):
    """
    Command to move (jog) a given pipette a relative distance.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['moveRelative'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveRelativeParams
    result: MoveRelativeResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveRelativeCreate(BaseModel):
    """
    Data to create a MoveRelative command.
    """

    commandType: Literal['moveRelative'] = Field(..., const=True, title='Commandtype')
    params: MoveRelativeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveTo(BaseModel):
    """
    MoveTo command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['robot/moveTo'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveToParams
    result: MoveToResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveToCreate(BaseModel):
    """
    MoveTo command request model.
    """

    commandType: Literal['robot/moveTo'] = Field(..., const=True, title='Commandtype')
    params: MoveToParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveToMaintenancePosition(BaseModel):
    """
    Calibration set up position command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['calibration/moveToMaintenancePosition'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveToMaintenancePositionParams
    result: MoveToMaintenancePositionResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveToMaintenancePositionCreate(BaseModel):
    """
    Calibration set up position command creation request model.
    """

    commandType: Literal['calibration/moveToMaintenancePosition'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: MoveToMaintenancePositionParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MoveToWell(BaseModel):
    """
    Move to well command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['moveToWell'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: MoveToWellParams
    result: MoveToWellResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class MoveToWellCreate(BaseModel):
    """
    Move to well command creation request model.
    """

    commandType: Literal['moveToWell'] = Field(..., const=True, title='Commandtype')
    params: MoveToWellParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MultiDispenseProperties(BaseModel):
    """
    Properties specific to the multi-dispense function.
    """

    class Config:
        extra = Extra.forbid

    submerge: Submerge = Field(..., description='Submerge settings for multi-dispense.')
    retract: RetractDispense = Field(
        ..., description='Pipette retract settings after a multi-dispense.'
    )
    dispense_position: TipPosition = Field(
        ..., description='Tip position during dispense.'
    )
    flow_rate_by_volume: list[FlowRateByVolumeItem5] = Field(
        ...,
        description='Settings for flow rate keyed by target dispense volume.',
        title='Flow Rate By Volume',
    )
    correction_by_volume: list[CorrectionByVolumeItem3] = Field(
        ...,
        description='Settings for volume correction keyed by by target dispense volume, representing additional volume the plunger should move to accurately hit target volume.',
        title='Correction By Volume',
    )
    conditioning_by_volume: list[ConditioningByVolumeItem] = Field(
        ...,
        description='Settings for conditioning volume keyed by target dispense volume.',
        title='Conditioning By Volume',
    )
    disposal_by_volume: list[DisposalByVolumeItem] = Field(
        ...,
        description='Settings for disposal volume keyed by target dispense volume.',
        title='Disposal By Volume',
    )
    delay: DelayProperties = Field(
        ..., description='Delay settings after each dispense'
    )


class PickUpTipParams(BaseModel):
    """
    Payload needed to move a pipette to a specific well.
    """

    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: PickUpTipWellLocation | None = Field(
        None, description='Relative well location at which to pick up the tip.'
    )


class Pipette(BaseModel):
    """
    Attached pipette info & configuration.
    """

    mount: str = Field(
        ..., description='The mount this instrument is attached to.', title='Mount'
    )
    instrumentType: Literal['pipette'] | Any = Field(
        'pipette', title='Instrumenttype'
    )
    instrumentModel: str = Field(..., title='Instrumentmodel')
    serialNumber: str = Field(
        ..., description='Instrument hardware serial number.', title='Serialnumber'
    )
    subsystem: SubSystem | None = Field(
        None, description='The subsystem corresponding to this instrument.'
    )
    ok: bool | Any = Field(
        True,
        description='Whether this instrument is OK and ready to go',
        title='Ok',
    )
    firmwareVersion: str | None = Field(
        None,
        description='The firmware version of this instrument (if applicable)',
        title='Firmwareversion',
    )
    data: PipetteData
    instrumentName: InstrumentName = Field(..., title='Instrumentname')
    state: PipetteState | None = None


class PipetteOffsetCalibrationResponseAttributes(BaseModel):
    """
    Response attributes of pipette offset calibration session.
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    createdAt: datetime = Field(
        ...,
        description='Date and time that this session was created',
        title='Createdat',
    )
    sessionType: SessionType4 = Field(
        'pipetteOffsetCalibration', const=True, title='Sessiontype'
    )
    createParams: RobotServerRobotCalibrationModelsSessionCreateParams
    details: PipetteOffsetCalibrationSessionStatus


class PipetteSettings(BaseModel):
    info: PipetteSettingsInfo
    fields: PipetteSettingsFields


class PressureDispense(BaseModel):
    """
    PressureDispense command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['pressureDispense'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: PressureDispenseParams
    result: PressureDispenseResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class PressureDispenseCreate(BaseModel):
    """
    PressureDispense command request model.
    """

    commandType: Literal['pressureDispense'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: PressureDispenseParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class Protocol(BaseModel):
    """
    A model representing an uploaded protocol resource.
    """

    id: str = Field(
        ..., description='A unique identifier for this protocol.', title='Id'
    )
    createdAt: datetime = Field(
        ...,
        description='When this protocol was *uploaded.* (`metadata` may have information about when this protocol was *authored.*)',
        title='Createdat',
    )
    files: list[ProtocolFile] = Field(..., title='Files')
    protocolType: ProtocolType = Field(
        ..., description='The type of protocol file (JSON or Python).'
    )
    robotType: RobotType1 = Field(
        ...,
        description='The type of robot that this protocol can run on.',
        title='Robottype',
    )
    metadata: RobotServerProtocolsProtocolModelsMetadata
    analyses: list[Any] | None = Field(
        None,
        description='This field was deprecated for performance reasons. It will always be returned as an empty list. Use `analysisSummaries` and `GET /protocols/:id/analyses` instead.',
        title='Analyses',
    )
    analysisSummaries: list[AnalysisSummary] = Field(
        ...,
        description='Summaries of any analyses run to check how this protocol is expected to run. For more detailed information, use `GET /protocols/:id/analyses`.\n\nReturned in order from the least-recently started analysis to the most-recently started analysis.',
        title='Analysissummaries',
    )
    key: str | None = Field(
        None,
        description='An arbitrary client-defined string, set when this protocol was uploaded. See `POST /protocols`.',
        title='Key',
    )
    protocolKind: ProtocolKind | None = Field(
        ...,
        description='The kind of protocol (standard or quick-transfer).The client provides this field when the protocol is uploaded. See `POST /protocols`.',
    )


class RequestModelMaintenanceRunCreate(BaseModel):
    data: MaintenanceRunCreate = Field(..., description="the document’s 'primary data'")


class RequestModelRunActionCreate(BaseModel):
    data: RunActionCreate = Field(..., description="the document’s 'primary data'")


class RequestModelSearchCreate(BaseModel):
    data: SearchCreate = Field(..., description="the document’s 'primary data'")


class RequestModelUnionCalibrationCheckCreateAttributesTipLengthCalibrationCreateAttributesDeckCalibrationCreateAttributesPipetteOffsetCalibrationCreateAttributes(
    BaseModel
):
    data: (
        CalibrationCheckCreateAttributes
        | TipLengthCalibrationCreateAttributes
        | DeckCalibrationCreateAttributes
        | PipetteOffsetCalibrationCreateAttributes
    ) = Field(..., description="the document’s 'primary data'", title='Data')


class RequestModelUnionLabwareOffsetCreateLegacyLabwareOffsetCreateListUnionLabwareOffsetCreateLegacyLabwareOffsetCreate(
    BaseModel
):
    data: (
        LabwareOffsetCreate
        | LegacyLabwareOffsetCreate
        | list[LabwareOffsetCreate | LegacyLabwareOffsetCreate]
    ) = Field(..., description="the document’s 'primary data'", title='Data')


class RunCreate(BaseModel):
    """
    Create request data for a new run.
    """

    protocolId: str | None = Field(
        None,
        description='Protocol resource ID that this run will be using, if applicable.',
        title='Protocolid',
    )
    labwareOffsets: list[LegacyLabwareOffsetCreate | LabwareOffsetCreate] | None = (
        Field(
            None,
            description='Labware offsets to apply as labware are loaded.',
            title='Labwareoffsets',
        )
    )
    runTimeParameterValues: dict[str, int | float | bool | str] | None = Field(
        None,
        description='Key-value pairs of run-time parameters defined in a protocol.',
        title='Runtimeparametervalues',
    )
    runTimeParameterFiles: dict[str, str] | None = Field(
        None,
        description='Key-fileId pairs of CSV run-time parameters defined in a run.',
        title='Runtimeparameterfiles',
    )


class RunExtendedProfile(BaseModel):
    """
    A command to execute a Thermocycler profile run.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/runExtendedProfile'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: RunExtendedProfileParams
    result: RunExtendedProfileResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class RunExtendedProfileCreate(BaseModel):
    """
    A request to execute a Thermocycler profile run.
    """

    commandType: Literal['thermocycler/runExtendedProfile'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: RunExtendedProfileParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class RunProfile(BaseModel):
    """
    A command to execute a Thermocycler profile run.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['thermocycler/runProfile'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: RunProfileParams
    result: RunProfileResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class RunProfileCreate(BaseModel):
    """
    A request to execute a Thermocycler profile run.
    """

    commandType: Literal['thermocycler/runProfile'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: RunProfileParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SealPipetteToTip(BaseModel):
    """
    Seal tip command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['sealPipetteToTip'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SealPipetteToTipParams
    result: SealPipetteToTipResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SealPipetteToTipCreate(BaseModel):
    """
    Seal tip command creation request model.
    """

    commandType: Literal['sealPipetteToTip'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: SealPipetteToTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SessionCommandRequestLiteralLoadLabwareLoadLabwareCreateLoadLabwareResult(
    BaseModel
):
    command: Command5 = Field(
        'equipment.loadLabware',
        const=True,
        description='The command description',
        title='Command',
    )
    data: LoadLabwareCreate = Field(..., description='The command data')


class SessionCommandRequestLiteralLoadPipetteLoadPipetteCreateLoadPipetteResult(
    BaseModel
):
    command: Command6 = Field(
        'equipment.loadPipette',
        const=True,
        description='The command description',
        title='Command',
    )
    data: LoadPipetteCreate = Field(..., description='The command data')


class SessionCommandResponseLiteralLoadPipetteLoadPipetteCreateLoadPipetteResult(
    BaseModel
):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command16 = Field('equipment.loadPipette', const=True, title='Command')
    data: LoadPipetteCreate
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: LoadPipetteResult | None = None


class SetStatusBar(BaseModel):
    """
    setStatusBar command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['setStatusBar'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SetStatusBarParams
    result: SetStatusBarResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SetStatusBarCreate(BaseModel):
    """
    setStatusBar command request model.
    """

    commandType: Literal['setStatusBar'] = Field(..., const=True, title='Commandtype')
    params: SetStatusBarParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SetStoredLabwareCreate(BaseModel):
    """
    A request to execute a Flex Stacker SetStoredLabware command.
    """

    commandType: Literal['flexStacker/setStoredLabware'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: SetStoredLabwareParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class SimpleBodyAnnotatedUnionHomeSetRailLightsSetStatusBarEngageDisengageSetTargetTemperatureDeactivateTemperatureSetTargetBlockTemperatureSetTargetLidTemperatureDeactivateBlockDeactivateLidOpenLidCloseLidSetTargetTemperatureSetAndWaitForShakeSpeedDeactivateHeaterDeactivateShakerOpenLabwareLatchCloseLabwareLatchUnsafeFlexStackerPrepareShuttleCreateUnsafeFlexStackerCloseLatchCreateUnsafeFlexStackerOpenLatchCreateIdentifyModuleFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorCommandType(
    BaseModel
):
    data: (
        Home
        | SetRailLights
        | SetStatusBar
        | Engage
        | Disengage
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperature
        | DeactivateTemperature
        | SetTargetBlockTemperature
        | SetTargetLidTemperature
        | DeactivateBlock
        | DeactivateLid
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLid
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLid
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperature
        | SetAndWaitForShakeSpeed
        | DeactivateHeater
        | DeactivateShaker
        | OpenLabwareLatch
        | CloseLabwareLatch
        | UnsafeFlexStackerPrepareShuttleCreate
        | UnsafeFlexStackerCloseLatchCreate
        | UnsafeFlexStackerOpenLatchCreate
        | IdentifyModule
    ) = Field(
        ...,
        description='The document’s primary data',
        discriminator='commandType',
        title='Data',
    )


class SimpleBodyProtocol(BaseModel):
    data: Protocol = Field(..., description='The document’s primary data')


class SimpleBodyStoredLabwareOffset(BaseModel):
    data: StoredLabwareOffset = Field(..., description='The document’s primary data')


class SimpleBodyUnionLabwareOffsetListLabwareOffset(BaseModel):
    data: LabwareOffset | list[LabwareOffset] = Field(
        ..., description='The document’s primary data', title='Data'
    )


class SimpleBodyUnionStoredLabwareOffsetListStoredLabwareOffset(BaseModel):
    data: StoredLabwareOffset | list[StoredLabwareOffset] = Field(
        ..., description='The document’s primary data', title='Data'
    )


class SimpleBodyUpdateProgressData(BaseModel):
    data: UpdateProgressData = Field(..., description='The document’s primary data')


class SimpleMultiBodyAnalysisSummary(BaseModel):
    data: list[AnalysisSummary] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class Data1(BaseModel):
    __root__: (
        Home
        | SetRailLights
        | SetStatusBar
        | Engage
        | Disengage
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperature
        | DeactivateTemperature
        | SetTargetBlockTemperature
        | SetTargetLidTemperature
        | DeactivateBlock
        | DeactivateLid
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLid
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLid
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperature
        | SetAndWaitForShakeSpeed
        | DeactivateHeater
        | DeactivateShaker
        | OpenLabwareLatch
        | CloseLabwareLatch
        | UnsafeFlexStackerPrepareShuttleCreate
        | UnsafeFlexStackerCloseLatchCreate
        | UnsafeFlexStackerOpenLatchCreate
        | IdentifyModule
    ) = Field(..., discriminator='commandType')


class SimpleMultiBodyAnnotatedUnionHomeSetRailLightsSetStatusBarEngageDisengageSetTargetTemperatureDeactivateTemperatureSetTargetBlockTemperatureSetTargetLidTemperatureDeactivateBlockDeactivateLidOpenLidCloseLidSetTargetTemperatureSetAndWaitForShakeSpeedDeactivateHeaterDeactivateShakerOpenLabwareLatchCloseLabwareLatchUnsafeFlexStackerPrepareShuttleCreateUnsafeFlexStackerCloseLatchCreateUnsafeFlexStackerOpenLatchCreateIdentifyModuleFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorCommandType(
    BaseModel
):
    data: list[Data1] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimpleMultiBodyProtocol(BaseModel):
    data: list[Protocol] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimpleMultiBodyStoredLabwareOffset(BaseModel):
    data: list[StoredLabwareOffset] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimpleMultiBodyUpdateProgressData(BaseModel):
    data: list[UpdateProgressData] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SimpleMultiBodyUpdateProgressSummary(BaseModel):
    data: list[UpdateProgressSummary] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class SingleDispenseProperties(BaseModel):
    """
    Properties specific to the single-dispense function.
    """

    class Config:
        extra = Extra.forbid

    submerge: Submerge = Field(
        ..., description='Submerge settings for single dispense.'
    )
    retract: RetractDispense = Field(
        ..., description='Pipette retract settings after a single dispense.'
    )
    dispense_position: TipPosition = Field(
        ..., description='Tip position during dispense.'
    )
    flow_rate_by_volume: list[FlowRateByVolumeItem6] = Field(
        ...,
        description='Settings for flow rate keyed by target dispense volume.',
        title='Flow Rate By Volume',
    )
    correction_by_volume: list[CorrectionByVolumeItem4] = Field(
        ...,
        description='Settings for volume correction keyed by by target dispense volume, representing additional volume the plunger should move to accurately hit target volume.',
        title='Correction By Volume',
    )
    mix: MixProperties = Field(..., description='Mixing settings for after a dispense')
    push_out_by_volume: list[PushOutByVolumeItem] = Field(
        ...,
        description='Settings for pushout keyed by target dispense volume.',
        title='Push Out By Volume',
    )
    delay: DelayProperties = Field(..., description='Delay after dispense, in seconds.')


class TemperatureModule(BaseModel):
    """
    An attached Temperature Module.
    """

    id: str = Field(
        ...,
        description='Unique module identifier for use in requests to /modules and /commands.',
        title='Id',
    )
    serialNumber: str = Field(
        ..., description='Device serial number.', title='Serialnumber'
    )
    firmwareVersion: str = Field(
        ..., description='Device firmware version.', title='Firmwareversion'
    )
    hardwareRevision: str = Field(
        ..., description='Device hardware revision.', title='Hardwarerevision'
    )
    hasAvailableUpdate: bool = Field(
        ...,
        description='Whether a firmware update is available.',
        title='Hasavailableupdate',
    )
    moduleType: ModuleType4 = Field(
        'temperatureModuleType', const=True, title='Moduletype'
    )
    moduleModel: ModuleModel4 = Field(..., title='Modulemodel')
    moduleOffset: ModuleCalibrationData | None = Field(
        None, description='The calibrated module offset.'
    )
    compatibleWithRobot: bool = Field(
        ...,
        description='Whether the detected module is compatible with this robot.',
        title='Compatiblewithrobot',
    )
    data: TemperatureModuleData
    usbPort: UsbPort


class TouchTipParams(BaseModel):
    """
    Payload needed to touch a pipette tip the sides of a specific well.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: WellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )
    radius: float | None = Field(
        1,
        description="The proportion of the target well's radius the pipette tip will move towards.",
        title='Radius',
    )
    mmFromEdge: float | None = Field(
        None,
        description='Offset away from the the well edge, in millimeters.Incompatible when a radius is included as a non 1.0 value.',
        title='Mmfromedge',
    )
    speed: float | None = Field(
        None,
        description='Override the travel speed in mm/s. This controls the straight linear speed of motion.',
        title='Speed',
    )


class TryLiquidProbeParams(BaseModel):
    """
    Parameters required for a `tryLiquidProbe` command.
    """

    labwareId: str = Field(
        ..., description='Identifier of labware to use.', title='Labwareid'
    )
    wellName: str = Field(
        ..., description='Name of well to use in labware.', title='Wellname'
    )
    wellLocation: WellLocation | None = Field(
        None, description='Relative well location at which to perform the operation'
    )
    pipetteId: str = Field(
        ...,
        description='Identifier of pipette to use for liquid handling.',
        title='Pipetteid',
    )


class UnsafePlaceLabware(BaseModel):
    """
    UnsafePlaceLabware command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsafe/placeLabware'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsafePlaceLabwareParams
    result: UnsafePlaceLabwareResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsafePlaceLabwareCreate(BaseModel):
    """
    UnsafePlaceLabware command request model.
    """

    commandType: Literal['unsafe/placeLabware'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsafePlaceLabwareParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class UnsealPipetteFromTip(BaseModel):
    """
    Unseal pipette command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['unsealPipetteFromTip'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: UnsealPipetteFromTipParams
    result: UnsealPipetteFromTipResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class UnsealPipetteFromTipCreate(BaseModel):
    """
    Unseal pipette command creation request model.
    """

    commandType: Literal['unsealPipetteFromTip'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: UnsealPipetteFromTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class Aspirate(BaseModel):
    """
    Aspirate command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['aspirate'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: AspirateParams
    result: AspirateResult | None = None
    error: OverpressureError | StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class AspirateCreate(BaseModel):
    """
    Create aspirate command request model.
    """

    commandType: Literal['aspirate'] = Field(..., const=True, title='Commandtype')
    params: AspirateParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class AspirateWhileTracking(BaseModel):
    """
    AspirateWhileTracking command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['aspirateWhileTracking'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: AspirateWhileTrackingParams
    result: AspirateWhileTrackingResult | None = None
    error: OverpressureError | StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class AspirateWhileTrackingCreate(BaseModel):
    """
    Create aspirateWhileTracking command request model.
    """

    commandType: Literal['aspirateWhileTracking'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: AspirateWhileTrackingParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class BlowOut(BaseModel):
    """
    Blow-out command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['blowout'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: BlowOutParams
    result: BlowOutResult | None = None
    error: OverpressureError | StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class BlowOutCreate(BaseModel):
    """
    Create blow-out command request model.
    """

    commandType: Literal['blowout'] = Field(..., const=True, title='Commandtype')
    params: BlowOutParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class BodyProtocolProtocolLinks(BaseModel):
    data: Protocol = Field(..., description='The document’s primary data')
    links: ProtocolLinks = Field(
        ..., description='A links object related to the primary data.'
    )


class CalibrateGripper(BaseModel):
    """
    A `calibrateGripper` command.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['calibration/calibrateGripper'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CalibrateGripperParams
    result: CalibrateGripperResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CalibrateModule(BaseModel):
    """
    Calibrate-module command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['calibration/calibrateModule'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: CalibrateModuleParams
    result: CalibrateModuleResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class CalibrationCheckResponseAttributes(BaseModel):
    """
    Response attributes of cal check session.
    """

    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    createdAt: datetime = Field(
        ...,
        description='Date and time that this session was created',
        title='Createdat',
    )
    sessionType: SessionType = Field(
        'calibrationCheck', const=True, title='Sessiontype'
    )
    createParams: RobotServerRobotCalibrationCheckModelsSessionCreateParams
    details: CalibrationCheckSessionStatus


class DeprecatedMultiResponseModelUnionCalibrationCheckResponseAttributesTipLengthCalibrationResponseAttributesDeckCalibrationResponseAttributesPipetteOffsetCalibrationResponseAttributes(
    BaseModel
):
    data: list[
        CalibrationCheckResponseAttributes
        | TipLengthCalibrationResponseAttributes
        | DeckCalibrationResponseAttributes
        | PipetteOffsetCalibrationResponseAttributes
    ] = Field(..., description='The document’s primary data', title='Data')
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class DeprecatedResponseModelUnionCalibrationCheckResponseAttributesTipLengthCalibrationResponseAttributesDeckCalibrationResponseAttributesPipetteOffsetCalibrationResponseAttributes(
    BaseModel
):
    data: (
        CalibrationCheckResponseAttributes
        | TipLengthCalibrationResponseAttributes
        | DeckCalibrationResponseAttributes
        | PipetteOffsetCalibrationResponseAttributes
    ) = Field(..., description='The document’s primary data', title='Data')
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class Dispense(BaseModel):
    """
    Dispense command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['dispense'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DispenseParams
    result: DispenseResult | None = None
    error: OverpressureError | StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DispenseCreate(BaseModel):
    """
    Create dispense command request model.
    """

    commandType: Literal['dispense'] = Field(..., const=True, title='Commandtype')
    params: DispenseParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DispenseWhileTracking(BaseModel):
    """
    Dispense command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['dispenseWhileTracking'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DispenseWhileTrackingParams
    result: DispenseWhileTrackingResult | None = None
    error: OverpressureError | StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DispenseWhileTrackingCreate(BaseModel):
    """
    Create dispenseWhileTracking command request model.
    """

    commandType: Literal['dispenseWhileTracking'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: DispenseWhileTrackingParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class DropTip(BaseModel):
    """
    Drop tip command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['dropTip'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: DropTipParams
    result: DropTipResult | None = None
    error: (
        TipPhysicallyAttachedError | StallOrCollisionError | ErrorOccurrence | None
    ) = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class DropTipCreate(BaseModel):
    """
    Drop tip command creation request model.
    """

    commandType: Literal['dropTip'] = Field(..., const=True, title='Commandtype')
    params: DropTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class ErrorRecoveryPolicy(BaseModel):
    """
    Request/Response model for new error recovery policy rules creation.
    """

    policyRules: list[ErrorRecoveryRule] = Field(
        ...,
        description="A list of error recovery rules to apply for a run's recovery management. The rules are evaluated first-to-last. The first exact match will dictate recovery management.",
        title='Policyrules',
    )


class GetNextTip(BaseModel):
    """
    Get next tip command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['getNextTip'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: GetNextTipParams
    result: GetNextTipResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class Gripper(BaseModel):
    """
    Attached gripper info & configuration.
    """

    mount: str = Field(
        ..., description='The mount this instrument is attached to.', title='Mount'
    )
    instrumentType: Literal['gripper'] | Any = Field(
        'gripper', title='Instrumenttype'
    )
    instrumentModel: str = Field(..., title='Instrumentmodel')
    serialNumber: str = Field(
        ..., description='Instrument hardware serial number.', title='Serialnumber'
    )
    subsystem: SubSystem | None = Field(
        None, description='The subsystem corresponding to this instrument.'
    )
    ok: bool | Any = Field(
        True,
        description='Whether this instrument is OK and ready to go',
        title='Ok',
    )
    firmwareVersion: str | None = Field(
        None,
        description='The firmware version of this instrument (if applicable)',
        title='Firmwareversion',
    )
    data: GripperData


class LabwareDefinition3(BaseModel):
    field_otSharedSchema: FieldOtSharedSchema = Field(
        '#/labware/schemas/3',
        alias='$otSharedSchema',
        const=True,
        title='$Otsharedschema',
    )
    schemaVersion: Literal[3] = Field(..., const=True, title='Schemaversion')
    version: int = Field(..., ge=1, title='Version')
    namespace: str = Field(..., regex='^[a-z0-9._]+$', title='Namespace')
    metadata: OpentronsSharedDataLabwareLabwareDefinitionMetadata
    brand: BrandData
    parameters: Parameters3
    ordering: list[list[str]] = Field(..., title='Ordering')
    features: LocatingFeatures
    extents: Extents
    wells: dict[str, CircularWellDefinition3 | RectangularWellDefinition3] = Field(
        ..., title='Wells'
    )
    groups: list[Group] = Field(..., title='Groups')
    stackingOffsetWithLabware: dict[str, Vector3D] | None = Field(
        None, title='Stackingoffsetwithlabware'
    )
    stackingOffsetWithModule: dict[str, Vector3D] | None = Field(
        None, title='Stackingoffsetwithmodule'
    )
    allowedRoles: list[LabwareRole] | None = Field(None, title='Allowedroles')
    gripperOffsets: dict[str, GripperOffsets] | None = Field(
        None, title='Gripperoffsets'
    )
    gripForce: float | None = Field(None, title='Gripforce')
    gripHeightFromLabwareOrigin: float | None = Field(
        None, title='Gripheightfromlabwareorigin'
    )
    stackLimit: int | None = Field(None, title='Stacklimit')
    compatibleParentLabware: list[str] | None = Field(
        None, title='Compatibleparentlabware'
    )
    innerLabwareGeometry: dict[str, InnerWellGeometry] | None = Field(
        None, title='Innerlabwaregeometry'
    )


class LiquidClassRecord(BaseModel):
    """
    LiquidClassRecord is our internal representation of an (immutable) liquid class.

    Conceptually, a liquid class record is the tuple (name, pipette, tip, transfer properties).
    We consider two liquid classes to be the same if every entry in that tuple is the same; and liquid
    classes are different if any entry in the tuple is different.

    This class defines the tuple via inheritance so that we can reuse the definitions from shared_data.
    """

    class Config:
        extra = Extra.forbid

    aspirate: AspirateProperties = Field(
        ..., description='Aspirate parameters for this tip type.'
    )
    dispense: SingleDispenseProperties = Field(
        ..., description='Single dispense parameters for this tip type.'
    )
    multi_dispense: MultiDispenseProperties | None = Field(
        None,
        description='Optional multi-dispense parameters for this tip type.',
        title='Multi Dispense',
    )
    tiprack: str = Field(
        ...,
        description='The name of tiprack whose tip will be used when handling this specific liquid class with this pipette',
        title='Tiprack',
    )
    liquidClassName: str = Field(
        ...,
        description='Identifier for the liquid of this liquid class, e.g. glycerol50.',
        title='Liquidclassname',
    )
    pipetteModel: str = Field(
        ...,
        description='Identifier for the pipette of this liquid class.',
        title='Pipettemodel',
    )


class LiquidClassRecordWithId(BaseModel):
    """
    A LiquidClassRecord with its ID, for use in summary lists.
    """

    class Config:
        extra = Extra.forbid

    aspirate: AspirateProperties = Field(
        ..., description='Aspirate parameters for this tip type.'
    )
    dispense: SingleDispenseProperties = Field(
        ..., description='Single dispense parameters for this tip type.'
    )
    multi_dispense: MultiDispenseProperties | None = Field(
        None,
        description='Optional multi-dispense parameters for this tip type.',
        title='Multi Dispense',
    )
    tiprack: str = Field(
        ...,
        description='The name of tiprack whose tip will be used when handling this specific liquid class with this pipette',
        title='Tiprack',
    )
    liquidClassName: str = Field(
        ...,
        description='Identifier for the liquid of this liquid class, e.g. glycerol50.',
        title='Liquidclassname',
    )
    pipetteModel: str = Field(
        ...,
        description='Identifier for the pipette of this liquid class.',
        title='Pipettemodel',
    )
    liquidClassId: str = Field(
        ...,
        description='Unique identifier for this liquid class.',
        title='Liquidclassid',
    )


class LiquidProbe(BaseModel):
    """
    The model for a full `liquidProbe` command.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['liquidProbe'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LiquidProbeParams
    result: LiquidProbeResult | None = None
    error: (
        LiquidNotFoundError
        | StallOrCollisionError
        | OverpressureError
        | ErrorOccurrence
        | None
    ) = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LiquidProbeCreate(BaseModel):
    """
    The request model for a `liquidProbe` command.
    """

    commandType: Literal['liquidProbe'] = Field(..., const=True, title='Commandtype')
    params: LiquidProbeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class LoadLabwareResult(BaseModel):
    """
    Result data from the execution of a LoadLabware command.
    """

    labwareId: str = Field(..., description='The id of the labware.', title='Labwareid')
    locationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location down to the deck on which this labware exists. The reason this can be `null` or omitted is just backwards compatibility, for older runs and analyses. This should always be present for new runs and analyses, even for labware whose location is off-deck.',
        title='Locationsequence',
    )
    offsetId: str | None = Field(
        None,
        description='An ID referencing the labware offset that will apply to this labware in this location.',
        title='Offsetid',
    )
    definition: LabwareDefinition2 | LabwareDefinition3 = Field(
        ...,
        description='The full definition data for this labware.',
        discriminator='schemaVersion',
        title='Definition',
    )


class LoadLidResult(BaseModel):
    """
    Result data from the execution of a LoadLabware command.
    """

    labwareId: str = Field(..., description='The id of the labware.', title='Labwareid')
    locationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The full location down to the deck on which this labware exists. The reason this can be `null` or omitted is just backwards compatibility, for older runs and analyses. This should always be present for new runs and analyses, even for labware whose location is off-deck.',
        title='Locationsequence',
    )
    definition: LabwareDefinition2 | LabwareDefinition3 = Field(
        ...,
        description='The full definition data for this lid labware.',
        discriminator='schemaVersion',
        title='Definition',
    )


class LoadLidStackResult(BaseModel):
    """
    Result data from the execution of a LoadLidStack command.
    """

    stackLabwareId: str = Field(
        ...,
        description='An ID to reference the lid stack labware object created.',
        title='Stacklabwareid',
    )
    labwareIds: list[str] = Field(
        ...,
        description='A list of lid labware IDs to reference the lids in this stack by. The first ID is the bottom of the stack.',
        title='Labwareids',
    )
    definition: LabwareDefinition2 | LabwareDefinition3 | None = Field(
        ...,
        description='The full definition data for this lid labware.',
        title='Definition',
    )
    location: (
        DeckSlotLocation
        | ModuleLocation
        | OnLabwareLocation
        | Location6
        | Location7
        | AddressableAreaLocation
    ) = Field(
        ...,
        description='The Location that the stack of lid labware has been loaded.',
        title='Location',
    )
    lidStackDefinition: LabwareDefinition2 | LabwareDefinition3 | None = Field(
        None,
        description='The definition of the lid stack object. Optional for backwards-compatibility.',
        title='Lidstackdefinition',
    )
    stackLocationSequence: (
        list[
            OnLabwareLocationSequenceComponent
            | OnModuleLocationSequenceComponent
            | OnAddressableAreaLocationSequenceComponent
            | NotOnDeckLocationSequenceComponent
            | OnCutoutFixtureLocationSequenceComponent
            | InStackerHopperLocation
        ]
        | None
    ) = Field(
        None,
        description='The location sequence for the lid stack labware object created.',
        title='Stacklocationsequence',
    )
    locationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The location sequences for the lids just loaded into the stack. These are in the same order as labwareIds.',
        title='Locationsequences',
    )


class LoadLiquidClassParams(BaseModel):
    """
    The liquid class transfer properties to store.
    """

    liquidClassId: str | None = Field(
        None,
        description='Unique identifier for the liquid class to store. If you do not supply a liquidClassId, we will generate one.',
        title='Liquidclassid',
    )
    liquidClassRecord: LiquidClassRecord = Field(
        ..., description='The liquid class to store.'
    )


class MaintenanceRun(BaseModel):
    """
    Maintenance run resource model.
    """

    id: str = Field(..., description='Unique run identifier.', title='Id')
    createdAt: datetime = Field(
        ..., description='When the run was created', title='Createdat'
    )
    status: EngineStatus = Field(..., description='Execution status of the run')
    current: bool = Field(
        ...,
        description='Whether this run is currently controlling the robot. There can be, at most, one current run.',
        title='Current',
    )
    actions: list[Any] = Field(
        ...,
        description=' This is currently always an empty list, and is provided for symmetry with non-maintenance runs. Non-maintenance runs let you issue actions with `POST /runs/{id}/actions`, but there is currently no equivalent endpoint for maintenance runs.',
        title='Actions',
    )
    errors: list[ErrorOccurrence] = Field(
        ...,
        description="The run's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element.",
        title='Errors',
    )
    hasEverEnteredErrorRecovery: bool = Field(
        ...,
        description='Whether the run has entered error recovery.',
        title='Haseverenterederrorrecovery',
    )
    pipettes: list[LoadedPipette] = Field(
        ...,
        description='Pipettes that have been loaded into the run.',
        title='Pipettes',
    )
    modules: list[LoadedModule] = Field(
        ..., description='Modules that have been loaded into the run.', title='Modules'
    )
    labware: list[LoadedLabware] = Field(
        ..., description='Labware that has been loaded into the run.', title='Labware'
    )
    liquids: list[Liquid] = Field(
        ..., description='Liquids loaded to the run.', title='Liquids'
    )
    liquidClasses: list[LiquidClassRecordWithId] = Field(
        ..., description='Liquid classes loaded to the run.', title='Liquidclasses'
    )
    labwareOffsets: list[LabwareOffset] = Field(
        ...,
        description='Labware offsets to apply as labware are loaded.',
        title='Labwareoffsets',
    )
    completedAt: datetime | None = Field(
        None, description='Run completed at timestamp.', title='Completedat'
    )
    startedAt: datetime | None = Field(
        None, description='Run started at timestamp.', title='Startedat'
    )


class PickUpTip(BaseModel):
    """
    Pick up tip command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['pickUpTip'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: PickUpTipParams
    result: PickUpTipResult | None = None
    error: (
        TipPhysicallyMissingError | StallOrCollisionError | ErrorOccurrence | None
    ) = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class PickUpTipCreate(BaseModel):
    """
    Pick up tip command creation request model.
    """

    commandType: Literal['pickUpTip'] = Field(..., const=True, title='Commandtype')
    params: PickUpTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class RequestModelAnnotatedUnionHomeCreateSetRailLightsCreateSetStatusBarCreateEngageCreateDisengageCreateSetTargetTemperatureCreateDeactivateTemperatureCreateSetTargetBlockTemperatureCreateSetTargetLidTemperatureCreateDeactivateBlockCreateDeactivateLidCreateOpenLidCreateCloseLidCreateSetTargetTemperatureCreateSetAndWaitForShakeSpeedCreateDeactivateHeaterCreateDeactivateShakerCreateOpenLabwareLatchCreateCloseLabwareLatchCreateUnsafeFlexStackerPrepareShuttleCreateUnsafeFlexStackerCloseLatchCreateUnsafeFlexStackerOpenLatchCreateIdentifyModuleCreateFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorCommandType(
    BaseModel
):
    data: (
        HomeCreate
        | SetRailLightsCreate
        | SetStatusBarCreate
        | EngageCreate
        | DisengageCreate
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureCreate
        | DeactivateTemperatureCreate
        | SetTargetBlockTemperatureCreate
        | SetTargetLidTemperatureCreate
        | DeactivateBlockCreate
        | DeactivateLidCreate
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidCreate
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidCreate
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureCreate
        | SetAndWaitForShakeSpeedCreate
        | DeactivateHeaterCreate
        | DeactivateShakerCreate
        | OpenLabwareLatchCreate
        | CloseLabwareLatchCreate
        | UnsafeFlexStackerPrepareShuttleCreate
        | UnsafeFlexStackerCloseLatchCreate
        | UnsafeFlexStackerOpenLatchCreate
        | IdentifyModuleCreate
    ) = Field(
        ...,
        description="the document’s 'primary data'",
        discriminator='commandType',
        title='Data',
    )


class RequestModelAnnotatedUnionLabwareDefinition2LabwareDefinition3Discriminator(
    BaseModel
):
    data: LabwareDefinition2 | LabwareDefinition3 = Field(
        ...,
        description="the document’s 'primary data'",
        discriminator='schemaVersion',
        title='Data',
    )


class RequestModelErrorRecoveryPolicy(BaseModel):
    data: ErrorRecoveryPolicy = Field(..., description="the document’s 'primary data'")


class RequestModelRunCreate(BaseModel):
    data: RunCreate = Field(..., description="the document’s 'primary data'")


class Run(BaseModel):
    """
    Run resource model.
    """

    id: str = Field(..., description='Unique run identifier.', title='Id')
    ok: Ok5 = Field(True, const=True, title='Ok')
    createdAt: datetime = Field(
        ..., description='When the run was created', title='Createdat'
    )
    status: EngineStatus = Field(..., description='Execution status of the run')
    current: bool = Field(
        ...,
        description='Whether this run is currently controlling the robot. There can be, at most, one current run.',
        title='Current',
    )
    actions: list[RunAction] = Field(
        ...,
        description='Client-initiated run control actions, ordered oldest to newest.',
        title='Actions',
    )
    errors: list[ErrorOccurrence] = Field(
        ...,
        description="The run's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element.",
        title='Errors',
    )
    hasEverEnteredErrorRecovery: bool = Field(
        ...,
        description='Whether the run has entered error recovery.',
        title='Haseverenterederrorrecovery',
    )
    pipettes: list[LoadedPipette] = Field(
        ...,
        description='Pipettes that have been loaded into the run.',
        title='Pipettes',
    )
    modules: list[LoadedModule] = Field(
        ..., description='Modules that have been loaded into the run.', title='Modules'
    )
    labware: list[LoadedLabware] = Field(
        ..., description='Labware that has been loaded into the run.', title='Labware'
    )
    liquids: list[Liquid] = Field(
        ..., description='Liquids loaded to the run.', title='Liquids'
    )
    liquidClasses: list[LiquidClassRecordWithId] = Field(
        ..., description='Liquid classes loaded to the run.', title='Liquidclasses'
    )
    labwareOffsets: list[LabwareOffset] = Field(
        ...,
        description='Labware offsets to apply as labware are loaded.',
        title='Labwareoffsets',
    )
    runTimeParameters: (
        list[NumberParameter | EnumParameter | BooleanParameter | CSVParameter] | None
    ) = Field(
        None,
        description='Run time parameters used during the run. These are the parameters that are defined in the protocol, with values specified either in the run creation request or default values from the protocol if none are specified in the request.',
        title='Runtimeparameters',
    )
    outputFileIds: list[str] = Field(
        ...,
        description='File IDs of files output during a protocol run.',
        title='Outputfileids',
    )
    protocolId: str | None = Field(
        None,
        description='Protocol resource being run, if any. If not present, the run may still be used to execute protocol commands over HTTP.',
        title='Protocolid',
    )
    completedAt: datetime | None = Field(
        None, description='Run completed at timestamp.', title='Completedat'
    )
    startedAt: datetime | None = Field(
        None, description='Run started at timestamp.', title='Startedat'
    )


class RunCommandSummary(BaseModel):
    """
    A stripped down model of a full Command for usage in a Run response.
    """

    id: str = Field(..., description='Unique command identifier.', title='Id')
    key: str = Field(
        ...,
        description='An identifier representing this command as a step in a protocol.',
        title='Key',
    )
    commandType: (
        CommandType122
        | CommandType123
        | CommandType124
        | CommandType125
        | CommandType126
        | CommandType127
        | CommandType128
        | CommandType129
        | CommandType130
        | CommandType131
        | CommandType132
        | CommandType133
        | CommandType134
        | CommandType135
        | CommandType136
        | CommandType137
        | CommandType138
        | CommandType139
        | CommandType140
        | CommandType141
        | CommandType142
        | CommandType143
        | CommandType144
        | CommandType145
        | CommandType146
        | CommandType147
        | CommandType148
        | CommandType149
        | CommandType150
        | CommandType151
        | CommandType152
        | CommandType153
        | CommandType154
        | CommandType155
        | CommandType156
        | CommandType157
        | CommandType158
        | CommandType159
        | CommandType160
        | CommandType161
        | CommandType162
        | CommandType163
        | CommandType164
        | CommandType165
        | CommandType166
        | CommandType167
        | CommandType168
        | CommandType169
        | CommandType170
        | CommandType171
        | CommandType172
        | CommandType173
        | CommandType174
        | CommandType175
        | CommandType176
        | CommandType177
        | CommandType178
        | CommandType179
        | CommandType180
        | CommandType181
        | CommandType182
        | CommandType183
        | CommandType184
        | CommandType185
        | CommandType186
        | CommandType187
        | CommandType188
        | CommandType189
        | CommandType190
        | CommandType191
        | CommandType192
        | CommandType193
        | CommandType194
        | CommandType195
        | CommandType196
        | CommandType197
        | CommandType198
        | CommandType199
        | CommandType200
        | CommandType201
        | CommandType202
        | CommandType203
        | CommandType204
        | CommandType205
        | CommandType206
        | CommandType207
        | CommandType208
        | CommandType209
        | CommandType210
        | CommandType211
        | CommandType212
        | CommandType213
        | CommandType214
        | CommandType215
        | CommandType216
        | CommandType217
        | CommandType218
        | CommandType219
    ) = Field(..., description='Specific type of command.', title='Commandtype')
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Execution status of the command.'
    )
    error: ErrorOccurrence | None = Field(
        None, description="Error occurrence, if status is 'failed'"
    )
    params: (
        AirGapInPlaceParams
        | AspirateParams
        | AspirateWhileTrackingParams
        | AspirateInPlaceParams
        | CommentParams
        | ConfigureForVolumeParams
        | ConfigureNozzleLayoutParams
        | CustomParams
        | DispenseParams
        | DispenseInPlaceParams
        | DispenseWhileTrackingParams
        | BlowOutParams
        | BlowOutInPlaceParams
        | DropTipParams
        | DropTipInPlaceParams
        | HomeParams
        | RetractAxisParams
        | LoadLabwareParams
        | LoadLidStackParams
        | LoadLidParams
        | ReloadLabwareParams
        | LoadLiquidParams
        | LoadLiquidClassParams
        | LoadModuleParams
        | IdentifyModuleParams
        | LoadPipetteParams
        | MoveLabwareParams
        | MoveRelativeParams
        | MoveToCoordinatesParams
        | MoveToWellParams
        | MoveToAddressableAreaParams
        | MoveToAddressableAreaForDropTipParams
        | PrepareToAspirateParams
        | WaitForResumeParams
        | WaitForDurationParams
        | PickUpTipParams
        | SavePositionParams
        | SetRailLightsParams
        | TouchTipParams
        | SetStatusBarParams
        | VerifyTipPresenceParams
        | GetTipPresenceParams
        | GetNextTipParams
        | LiquidProbeParams
        | TryLiquidProbeParams
        | SealPipetteToTipParams
        | PressureDispenseParams
        | UnsealPipetteFromTipParams
        | OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureParams
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureParams
        | DeactivateHeaterParams
        | SetAndWaitForShakeSpeedParams
        | DeactivateShakerParams
        | OpenLabwareLatchParams
        | CloseLabwareLatchParams
        | DisengageParams
        | EngageParams
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureParams
        | OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureParams
        | DeactivateTemperatureParams
        | SetTargetBlockTemperatureParams
        | WaitForBlockTemperatureParams
        | SetTargetLidTemperatureParams
        | WaitForLidTemperatureParams
        | DeactivateBlockParams
        | DeactivateLidParams
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidParams
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidParams
        | RunProfileParams
        | RunExtendedProfileParams
        | OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidParams
        | OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidParams
        | InitializeParams
        | ReadAbsorbanceParams
        | RetrieveParams
        | StoreParams
        | SetStoredLabwareParams
        | FillParams
        | EmptyParams
        | CalibrateGripperParams
        | CalibratePipetteParams
        | CalibrateModuleParams
        | MoveToMaintenancePositionParams
        | UnsafeBlowOutInPlaceParams
        | UnsafeDropTipInPlaceParams
        | UpdatePositionEstimatorsParams
        | UnsafeEngageAxesParams
        | UnsafeUngripLabwareParams
        | UnsafePlaceLabwareParams
        | UnsafeFlexStackerManualRetrieveParams
        | UnsafeFlexStackerCloseLatchParams
        | UnsafeFlexStackerOpenLatchParams
        | UnsafeFlexStackerPrepareShuttleParams
        | MoveAxesRelativeParams
        | MoveAxesToParams
        | MoveToParams
        | OpenGripperJawParams
        | CloseGripperJawParams
    ) = Field(..., description='Command execution parameters.', title='Params')
    intent: CommandIntent | None = Field(
        None, description='Why this command was added to the run.'
    )
    notes: list[CommandNote] | None = Field(
        None, description='Notes pertaining to this command.', title='Notes'
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SessionCommandRequestLiteralAspirateAspirateCreateAspirateResult(BaseModel):
    command: Command = Field(
        'pipette.aspirate',
        const=True,
        description='The command description',
        title='Command',
    )
    data: AspirateCreate = Field(..., description='The command data')


class SessionCommandRequestLiteralDispenseDispenseCreateDispenseResult(BaseModel):
    command: Command1 = Field(
        'pipette.dispense',
        const=True,
        description='The command description',
        title='Command',
    )
    data: DispenseCreate = Field(..., description='The command data')


class SessionCommandRequestLiteralDropTipDropTipCreateDropTipResult(BaseModel):
    command: Command2 = Field(
        'pipette.dropTip',
        const=True,
        description='The command description',
        title='Command',
    )
    data: DropTipCreate = Field(..., description='The command data')


class SessionCommandRequestLiteralPickUpTipPickUpTipCreatePickUpTipResult(BaseModel):
    command: Command7 = Field(
        'pipette.pickUpTip',
        const=True,
        description='The command description',
        title='Command',
    )
    data: PickUpTipCreate = Field(..., description='The command data')


class SessionCommandResponseLiteralAspirateAspirateCreateAspirateResult(BaseModel):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command10 = Field('pipette.aspirate', const=True, title='Command')
    data: AspirateCreate
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: AspirateResult | None = None


class SessionCommandResponseLiteralDispenseDispenseCreateDispenseResult(BaseModel):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command11 = Field('pipette.dispense', const=True, title='Command')
    data: DispenseCreate
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: DispenseResult | None = None


class SessionCommandResponseLiteralDropTipDropTipCreateDropTipResult(BaseModel):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command12 = Field('pipette.dropTip', const=True, title='Command')
    data: DropTipCreate
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: DropTipResult | None = None


class SessionCommandResponseLiteralLoadLabwareLoadLabwareCreateLoadLabwareResult(
    BaseModel
):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command15 = Field('equipment.loadLabware', const=True, title='Command')
    data: LoadLabwareCreate
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: LoadLabwareResult | None = None


class SessionCommandResponseLiteralPickUpTipPickUpTipCreatePickUpTipResult(BaseModel):
    id: str = Field(
        ..., description='Unique identifier for the resource object.', title='Id'
    )
    command: Command17 = Field('pipette.pickUpTip', const=True, title='Command')
    data: PickUpTipCreate
    status: RobotServerServiceSessionModelsCommandCommandStatus
    createdAt: datetime | None = Field(None, title='Createdat')
    startedAt: datetime | None = Field(None, title='Startedat')
    completedAt: datetime | None = Field(None, title='Completedat')
    result: PickUpTipResult | None = None


class SetStoredLabwareResult(BaseModel):
    """
    Result data from a setstoredlabware command.
    """

    primaryLabwareDefinition: LabwareDefinition2 | LabwareDefinition3 = Field(
        ...,
        description='The definition of the primary labware.',
        discriminator='schemaVersion',
        title='Primarylabwaredefinition',
    )
    lidLabwareDefinition: LabwareDefinition2 | LabwareDefinition3 | None = Field(
        None,
        description='The definition of the lid on the primary labware, if any.',
        discriminator='schemaVersion',
        title='Lidlabwaredefinition',
    )
    adapterLabwareDefinition: LabwareDefinition2 | LabwareDefinition3 | None = Field(
        None,
        description='The definition of the adapter under the primary labware, if any.',
        discriminator='schemaVersion',
        title='Adapterlabwaredefinition',
    )
    storedLabware: list[StackerStoredLabwareGroup] = Field(
        ...,
        description='The primary labware loaded into the stacker labware pool.',
        title='Storedlabware',
    )
    count: int = Field(
        ...,
        description='The number of labware now stored in the hopper.',
        title='Count',
    )
    originalPrimaryLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each primary labware, in the same order as storedLabware.',
        title='Originalprimarylabwarelocationsequences',
    )
    originalAdapterLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each adapter labware, in the same order as storedLabware. None if the pool does not specify an adapter.',
        title='Originaladapterlabwarelocationsequences',
    )
    originalLidLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The previous position of each lid labware, in the same order as storedLabware. None if the pool does not specify a lid.',
        title='Originallidlabwarelocationsequences',
    )
    newPrimaryLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each primary labware, in the same order as storedLabware.',
        title='Newprimarylabwarelocationsequences',
    )
    newAdapterLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each adapter labware, in the same order as storedLabware. None if the pool does not specify an adapter.',
        title='Newadapterlabwarelocationsequences',
    )
    newLidLabwareLocationSequences: (
        list[
            list[
                OnLabwareLocationSequenceComponent
                | OnModuleLocationSequenceComponent
                | OnAddressableAreaLocationSequenceComponent
                | NotOnDeckLocationSequenceComponent
                | OnCutoutFixtureLocationSequenceComponent
                | InStackerHopperLocation
            ]
        ]
        | None
    ) = Field(
        None,
        description='The new position of each lid labware, in the same order as storedLabware. None if the pool does not specify a lid labware.',
        title='Newlidlabwarelocationsequences',
    )


class SimpleBodyErrorRecoveryPolicy(BaseModel):
    data: ErrorRecoveryPolicy = Field(..., description='The document’s primary data')


class SimpleBodyMaintenanceRun(BaseModel):
    data: MaintenanceRun = Field(..., description='The document’s primary data')


class SimpleBodyRun(BaseModel):
    data: Run = Field(..., description='The document’s primary data')


class Data(BaseModel):
    __root__: LabwareDefinition2 | LabwareDefinition3 = Field(
        ..., discriminator='schemaVersion'
    )


class SimpleBodyListAnnotatedUnionLabwareDefinition2LabwareDefinition3Discriminator(
    BaseModel
):
    data: list[Data] = Field(
        ..., description='The document’s primary data', title='Data'
    )


class SimpleMultiBodyUnionPipetteGripperBadPipetteBadGripper(BaseModel):
    data: List[Union[Pipette, Gripper, BadPipette, BadGripper]] = Field(
        ..., description='The document\'s primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )

    class Config:
        use_enum_values = True


class SimpleMultiBodyUnionTemperatureModuleMagneticModuleThermocyclerModuleHeaterShakerModuleAbsorbanceReaderModuleFlexStackerModule(
    BaseModel
):
    data: list[
        TemperatureModule
        | MagneticModule
        | ThermocyclerModule
        | HeaterShakerModule
        | AbsorbanceReaderModule
        | FlexStackerModule
    ] = Field(..., description='The document’s primary data', title='Data')
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class TouchTip(BaseModel):
    """
    Touch up tip command model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['touchTip'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: TouchTipParams
    result: TouchTipResult | None = None
    error: StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class TouchTipCreate(BaseModel):
    """
    Touch tip command creation request model.
    """

    commandType: Literal['touchTip'] = Field(..., const=True, title='Commandtype')
    params: TouchTipParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class TryLiquidProbe(BaseModel):
    """
    The model for a full `tryLiquidProbe` command.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['tryLiquidProbe'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: TryLiquidProbeParams
    result: TryLiquidProbeResult | None = None
    error: OverpressureError | StallOrCollisionError | ErrorOccurrence | None = Field(
        None,
        description='Reference to error occurrence, if execution failed',
        title='Error',
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class TryLiquidProbeCreate(BaseModel):
    """
    The request model for a `tryLiquidProbe` command.
    """

    commandType: Literal['tryLiquidProbe'] = Field(..., const=True, title='Commandtype')
    params: TryLiquidProbeParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class BadRun(BaseModel):
    """
    Resource model representation for a bad run that could not be loaded.
    """

    id: str = Field(..., description='Unique run identifier.', title='Id')
    ok: Ok2 = Field(False, const=True, title='Ok')
    dataError: RunDataError = Field(..., description='Error from loading the data.')
    createdAt: datetime = Field(
        ..., description='When the run was created', title='Createdat'
    )
    status: EngineStatus = Field(..., description='Execution status of the run')
    current: bool = Field(
        ...,
        description='Whether this run is currently controlling the robot. There can be, at most, one current run.',
        title='Current',
    )
    actions: list[RunAction] = Field(
        ...,
        description='Client-initiated run control actions, ordered oldest to newest. If these could not be loaded for this bad run, this will be null.',
        title='Actions',
    )
    errors: list[ErrorOccurrence] = Field(
        ...,
        description="The run's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element.",
        title='Errors',
    )
    hasEverEnteredErrorRecovery: bool = Field(
        ...,
        description='Whether the run has entered error recovery.',
        title='Haseverenterederrorrecovery',
    )
    pipettes: list[LoadedPipette] = Field(
        ...,
        description='Pipettes that have been loaded into the run.',
        title='Pipettes',
    )
    modules: list[LoadedModule] = Field(
        ..., description='Modules that have been loaded into the run.', title='Modules'
    )
    labware: list[LoadedLabware] = Field(
        ..., description='Labware that has been loaded into the run.', title='Labware'
    )
    liquids: list[Liquid] = Field(
        ..., description='Liquids loaded to the run.', title='Liquids'
    )
    liquidClasses: list[LiquidClassRecordWithId] = Field(
        ..., description='Liquid classes loaded to the run.', title='Liquidclasses'
    )
    labwareOffsets: list[LabwareOffset] = Field(
        ...,
        description='Labware offsets to apply as labware are loaded.',
        title='Labwareoffsets',
    )
    runTimeParameters: (
        list[NumberParameter | EnumParameter | BooleanParameter | CSVParameter] | None
    ) = Field(
        None,
        description='Run time parameters used during the run. These are the parameters that are defined in the protocol, with values specified either in the run creation request or default values from the protocol if none are specified in the request.',
        title='Runtimeparameters',
    )
    outputFileIds: list[str] = Field(
        ...,
        description='File IDs of files output during a protocol run.',
        title='Outputfileids',
    )
    protocolId: str | None = Field(
        None,
        description='Protocol resource being run, if any. If not present, the run may still be used to execute protocol commands over HTTP.',
        title='Protocolid',
    )
    completedAt: datetime | None = Field(
        None, description='Run completed at timestamp.', title='Completedat'
    )
    startedAt: datetime | None = Field(
        None, description='Run started at timestamp.', title='Startedat'
    )


class BodyMaintenanceRunAllRunsLinks(BaseModel):
    data: MaintenanceRun = Field(..., description='The document’s primary data')
    links: AllRunsLinks = Field(
        ..., description='A links object related to the primary data.'
    )


class DeprecatedResponseModelUnionSessionCommandResponseLiteralStartRunStartSimulateCancelPauseResumeMoveToTipRackMoveToPointOneMoveToDeckMoveToReferencePointPickUpTipConfirmTipAttachedInvalidateTipSaveOffsetExitInvalidateLastActionMoveToPointTwoMoveToPointThreeComparePointSwitchPipetteReturnTipTransitionEmptyModelEmptyModelSessionCommandResponseLiteralLoadLabwareLoadLabwareCreateLoadLabwareResultSessionCommandResponseLiteralLoadPipetteLoadPipetteCreateLoadPipetteResultSessionCommandResponseLiteralAspirateAspirateCreateAspirateResultSessionCommandResponseLiteralDispenseDispenseCreateDispenseResultSessionCommandResponseLiteralPickUpTipPickUpTipCreatePickUpTipResultSessionCommandResponseLiteralDropTipDropTipCreateDropTipResultSessionCommandResponseLiteralJogJogPositionEmptyModelSessionCommandResponseLiteralSetHasCalibrationBlockSetHasCalibrationBlockRequestDataEmptyModelSessionCommandResponseLiteralLoadLabwareLoadLabwareByDefinitionRequestDataEmptyModel(
    BaseModel
):
    data: (
        SessionCommandResponseLiteralStartRunStartSimulateCancelPauseResumeMoveToTipRackMoveToPointOneMoveToDeckMoveToReferencePointPickUpTipConfirmTipAttachedInvalidateTipSaveOffsetExitInvalidateLastActionMoveToPointTwoMoveToPointThreeComparePointSwitchPipetteReturnTipTransitionEmptyModelEmptyModel
        | SessionCommandResponseLiteralLoadLabwareLoadLabwareCreateLoadLabwareResult
        | SessionCommandResponseLiteralLoadPipetteLoadPipetteCreateLoadPipetteResult
        | SessionCommandResponseLiteralAspirateAspirateCreateAspirateResult
        | SessionCommandResponseLiteralDispenseDispenseCreateDispenseResult
        | SessionCommandResponseLiteralPickUpTipPickUpTipCreatePickUpTipResult
        | SessionCommandResponseLiteralDropTipDropTipCreateDropTipResult
        | SessionCommandResponseLiteralJogJogPositionEmptyModel
        | SessionCommandResponseLiteralSetHasCalibrationBlockSetHasCalibrationBlockRequestDataEmptyModel
        | SessionCommandResponseLiteralLoadLabwareLoadLabwareByDefinitionRequestDataEmptyModel
    ) = Field(..., description='The document’s primary data', title='Data')
    links: dict[str, ResourceLink] | None = Field(
        None, description='A links object related to the primary data.', title='Links'
    )


class LoadLabware(BaseModel):
    """
    Load labware command resource model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadLabware'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadLabwareParams
    result: LoadLabwareResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadLid(BaseModel):
    """
    Load lid command resource model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadLid'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadLidParams
    result: LoadLidResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadLidStack(BaseModel):
    """
    Load lid stack command resource model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadLidStack'] = Field(..., const=True, title='Commandtype')
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadLidStackParams
    result: LoadLidStackResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadLiquidClass(BaseModel):
    """
    Load Liquid Class command resource model.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['loadLiquidClass'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: LoadLiquidClassParams
    result: LoadLiquidClassResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class LoadLiquidClassCreate(BaseModel):
    """
    Load Liquid Class command creation request.
    """

    commandType: Literal['loadLiquidClass'] = Field(
        ..., const=True, title='Commandtype'
    )
    params: LoadLiquidClassParams
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating.',
        title='Intent',
    )
    key: str | None = Field(
        None,
        description='A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated.',
        title='Key',
    )


class MultiBodyRunCommandSummaryCommandCollectionLinks(BaseModel):
    data: list[RunCommandSummary] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    links: CommandCollectionLinks = Field(
        ..., description='A links object related to the primary data.'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class MultiBodyUnionRunBadRunAllRunsLinks(BaseModel):
    data: list[Run | BadRun] = Field(
        ..., description='The document’s primary data', title='Data'
    )
    links: AllRunsLinks = Field(
        ..., description='A links object related to the primary data.'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


class RequestModelAnnotatedUnionAirGapInPlaceCreateAspirateCreateAspirateWhileTrackingCreateAspirateInPlaceCreateCommentCreateConfigureForVolumeCreateConfigureNozzleLayoutCreateCustomCreateDispenseCreateDispenseInPlaceCreateDispenseWhileTrackingCreateBlowOutCreateBlowOutInPlaceCreateDropTipCreateDropTipInPlaceCreateHomeCreateRetractAxisCreateLoadLabwareCreateReloadLabwareCreateLoadLiquidCreateLoadLiquidClassCreateLoadModuleCreateIdentifyModuleCreateLoadPipetteCreateLoadLidStackCreateLoadLidCreateMoveLabwareCreateMoveRelativeCreateMoveToCoordinatesCreateMoveToWellCreateMoveToAddressableAreaCreateMoveToAddressableAreaForDropTipCreatePrepareToAspirateCreateWaitForResumeCreateWaitForDurationCreatePickUpTipCreateSavePositionCreateSetRailLightsCreateTouchTipCreateSetStatusBarCreateVerifyTipPresenceCreateGetTipPresenceCreateGetNextTipCreateLiquidProbeCreateTryLiquidProbeCreateSealPipetteToTipCreatePressureDispenseCreateUnsealPipetteFromTipCreateWaitForTemperatureCreateSetTargetTemperatureCreateDeactivateHeaterCreateSetAndWaitForShakeSpeedCreateDeactivateShakerCreateOpenLabwareLatchCreateCloseLabwareLatchCreateDisengageCreateEngageCreateSetTargetTemperatureCreateWaitForTemperatureCreateDeactivateTemperatureCreateSetTargetBlockTemperatureCreateWaitForBlockTemperatureCreateSetTargetLidTemperatureCreateWaitForLidTemperatureCreateDeactivateBlockCreateDeactivateLidCreateOpenLidCreateCloseLidCreateRunProfileCreateRunExtendedProfileCreateCloseLidCreateOpenLidCreateInitializeCreateReadAbsorbanceCreateRetrieveCreateStoreCreateSetStoredLabwareCreateFillCreateEmptyCreateCalibrateGripperCreateCalibratePipetteCreateCalibrateModuleCreateMoveToMaintenancePositionCreateUnsafeBlowOutInPlaceCreateUnsafeDropTipInPlaceCreateUpdatePositionEstimatorsCreateUnsafeEngageAxesCreateUnsafeUngripLabwareCreateUnsafePlaceLabwareCreateUnsafeFlexStackerManualRetrieveCreateUnsafeFlexStackerCloseLatchCreateUnsafeFlexStackerOpenLatchCreateUnsafeFlexStackerPrepareShuttleCreateMoveAxesRelativeCreateMoveAxesToCreateMoveToCreateOpenGripperJawCreateCloseGripperJawCreateFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorCommandType(
    BaseModel
):
    data: (
        AirGapInPlaceCreate
        | AspirateCreate
        | AspirateWhileTrackingCreate
        | AspirateInPlaceCreate
        | CommentCreate
        | ConfigureForVolumeCreate
        | ConfigureNozzleLayoutCreate
        | CustomCreate
        | DispenseCreate
        | DispenseInPlaceCreate
        | DispenseWhileTrackingCreate
        | BlowOutCreate
        | BlowOutInPlaceCreate
        | DropTipCreate
        | DropTipInPlaceCreate
        | HomeCreate
        | RetractAxisCreate
        | LoadLabwareCreate
        | ReloadLabwareCreate
        | LoadLiquidCreate
        | LoadLiquidClassCreate
        | LoadModuleCreate
        | IdentifyModuleCreate
        | LoadPipetteCreate
        | LoadLidStackCreate
        | LoadLidCreate
        | MoveLabwareCreate
        | MoveRelativeCreate
        | MoveToCoordinatesCreate
        | MoveToWellCreate
        | MoveToAddressableAreaCreate
        | MoveToAddressableAreaForDropTipCreate
        | PrepareToAspirateCreate
        | WaitForResumeCreate
        | WaitForDurationCreate
        | PickUpTipCreate
        | SavePositionCreate
        | SetRailLightsCreate
        | TouchTipCreate
        | SetStatusBarCreate
        | VerifyTipPresenceCreate
        | GetTipPresenceCreate
        | GetNextTipCreate
        | LiquidProbeCreate
        | TryLiquidProbeCreate
        | SealPipetteToTipCreate
        | PressureDispenseCreate
        | UnsealPipetteFromTipCreate
        | OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperatureCreate
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperatureCreate
        | DeactivateHeaterCreate
        | SetAndWaitForShakeSpeedCreate
        | DeactivateShakerCreate
        | OpenLabwareLatchCreate
        | CloseLabwareLatchCreate
        | DisengageCreate
        | EngageCreate
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperatureCreate
        | OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperatureCreate
        | DeactivateTemperatureCreate
        | SetTargetBlockTemperatureCreate
        | WaitForBlockTemperatureCreate
        | SetTargetLidTemperatureCreate
        | WaitForLidTemperatureCreate
        | DeactivateBlockCreate
        | DeactivateLidCreate
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLidCreate
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLidCreate
        | RunProfileCreate
        | RunExtendedProfileCreate
        | OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLidCreate
        | OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLidCreate
        | InitializeCreate
        | ReadAbsorbanceCreate
        | RetrieveCreate
        | StoreCreate
        | SetStoredLabwareCreate
        | FillCreate
        | EmptyCreate
        | CalibrateGripperCreate
        | CalibratePipetteCreate
        | CalibrateModuleCreate
        | MoveToMaintenancePositionCreate
        | UnsafeBlowOutInPlaceCreate
        | UnsafeDropTipInPlaceCreate
        | UpdatePositionEstimatorsCreate
        | UnsafeEngageAxesCreate
        | UnsafeUngripLabwareCreate
        | UnsafePlaceLabwareCreate
        | UnsafeFlexStackerManualRetrieveCreate
        | UnsafeFlexStackerCloseLatchCreate
        | UnsafeFlexStackerOpenLatchCreate
        | UnsafeFlexStackerPrepareShuttleCreate
        | MoveAxesRelativeCreate
        | MoveAxesToCreate
        | MoveToCreate
        | OpenGripperJawCreate
        | CloseGripperJawCreate
    ) = Field(
        ...,
        description="the document’s 'primary data'",
        discriminator='commandType',
        title='Data',
    )


class RequestModelUnionSessionCommandRequestLiteralStartRunStartSimulateCancelPauseResumeMoveToTipRackMoveToPointOneMoveToDeckMoveToReferencePointPickUpTipConfirmTipAttachedInvalidateTipSaveOffsetExitInvalidateLastActionMoveToPointTwoMoveToPointThreeComparePointSwitchPipetteReturnTipTransitionEmptyModelEmptyModelSessionCommandRequestLiteralLoadLabwareLoadLabwareCreateLoadLabwareResultSessionCommandRequestLiteralLoadPipetteLoadPipetteCreateLoadPipetteResultSessionCommandRequestLiteralAspirateAspirateCreateAspirateResultSessionCommandRequestLiteralDispenseDispenseCreateDispenseResultSessionCommandRequestLiteralPickUpTipPickUpTipCreatePickUpTipResultSessionCommandRequestLiteralDropTipDropTipCreateDropTipResultSessionCommandRequestLiteralJogJogPositionEmptyModelSessionCommandRequestLiteralSetHasCalibrationBlockSetHasCalibrationBlockRequestDataEmptyModelSessionCommandRequestLiteralLoadLabwareLoadLabwareByDefinitionRequestDataEmptyModel(
    BaseModel
):
    data: (
        SessionCommandRequestLiteralStartRunStartSimulateCancelPauseResumeMoveToTipRackMoveToPointOneMoveToDeckMoveToReferencePointPickUpTipConfirmTipAttachedInvalidateTipSaveOffsetExitInvalidateLastActionMoveToPointTwoMoveToPointThreeComparePointSwitchPipetteReturnTipTransitionEmptyModelEmptyModel
        | SessionCommandRequestLiteralLoadLabwareLoadLabwareCreateLoadLabwareResult
        | SessionCommandRequestLiteralLoadPipetteLoadPipetteCreateLoadPipetteResult
        | SessionCommandRequestLiteralAspirateAspirateCreateAspirateResult
        | SessionCommandRequestLiteralDispenseDispenseCreateDispenseResult
        | SessionCommandRequestLiteralPickUpTipPickUpTipCreatePickUpTipResult
        | SessionCommandRequestLiteralDropTipDropTipCreateDropTipResult
        | SessionCommandRequestLiteralJogJogPositionEmptyModel
        | SessionCommandRequestLiteralSetHasCalibrationBlockSetHasCalibrationBlockRequestDataEmptyModel
        | SessionCommandRequestLiteralLoadLabwareLoadLabwareByDefinitionRequestDataEmptyModel
    ) = Field(..., description="the document’s 'primary data'", title='Data')


class SetStoredLabware(BaseModel):
    """
    A command to setstoredlabware the Flex Stacker.
    """

    id: str = Field(
        ...,
        description='Unique identifier of this particular command instance',
        title='Id',
    )
    createdAt: datetime = Field(
        ..., description='Command creation timestamp', title='Createdat'
    )
    commandType: Literal['flexStacker/setStoredLabware'] = Field(
        ..., const=True, title='Commandtype'
    )
    key: str = Field(
        ...,
        description="An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol.",
        title='Key',
    )
    status: OpentronsProtocolEngineCommandsCommandCommandStatus = Field(
        ..., description='Command execution status'
    )
    params: SetStoredLabwareParams
    result: SetStoredLabwareResult | None = None
    error: ErrorOccurrence | None = Field(
        None, description='Reference to error occurrence, if execution failed'
    )
    startedAt: datetime | None = Field(
        None,
        description='Command execution start timestamp, if started',
        title='Startedat',
    )
    completedAt: datetime | None = Field(
        None,
        description='Command execution completed timestamp, if completed',
        title='Completedat',
    )
    intent: CommandIntent | None = Field(
        None,
        description='The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure.',
    )
    notes: list[CommandNote] | None = Field(
        None,
        description="Information not critical to the execution of the command derived from either the command's execution or the command's generation.",
        title='Notes',
    )
    failedCommandId: str | None = Field(
        None,
        description='FIXIT command use only. Reference of the failed command id we are trying to fix.',
        title='Failedcommandid',
    )


class SimpleBodyAnnotatedUnionAirGapInPlaceAspirateAspirateInPlaceAspirateWhileTrackingCommentCustomDispenseDispenseInPlaceDispenseWhileTrackingBlowOutBlowOutInPlaceConfigureForVolumeConfigureNozzleLayoutDropTipDropTipInPlaceHomeRetractAxisLoadLabwareReloadLabwareLoadLiquidLoadLiquidClassLoadModuleIdentifyModuleLoadPipetteLoadLidStackLoadLidMoveLabwareMoveRelativeMoveToCoordinatesMoveToWellMoveToAddressableAreaMoveToAddressableAreaForDropTipPrepareToAspirateWaitForResumeWaitForDurationPickUpTipSavePositionSetRailLightsTouchTipSetStatusBarVerifyTipPresenceGetTipPresenceGetNextTipLiquidProbeTryLiquidProbeSealPipetteToTipPressureDispenseUnsealPipetteFromTipWaitForTemperatureSetTargetTemperatureDeactivateHeaterSetAndWaitForShakeSpeedDeactivateShakerOpenLabwareLatchCloseLabwareLatchDisengageEngageSetTargetTemperatureWaitForTemperatureDeactivateTemperatureSetTargetBlockTemperatureWaitForBlockTemperatureSetTargetLidTemperatureWaitForLidTemperatureDeactivateBlockDeactivateLidOpenLidCloseLidRunProfileRunExtendedProfileCloseLidOpenLidInitializeReadAbsorbanceRetrieveStoreSetStoredLabwareFillEmptyCalibrateGripperCalibratePipetteCalibrateModuleMoveToMaintenancePositionUnsafeBlowOutInPlaceUnsafeDropTipInPlaceUpdatePositionEstimatorsUnsafeEngageAxesUnsafeUngripLabwareUnsafePlaceLabwareUnsafeFlexStackerManualRetrieveUnsafeFlexStackerCloseLatchUnsafeFlexStackerOpenLatchUnsafeFlexStackerPrepareShuttleMoveToMoveAxesRelativeMoveAxesToOpenGripperJawCloseGripperJawFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorCommandType(
    BaseModel
):
    data: (
        AirGapInPlace
        | Aspirate
        | AspirateInPlace
        | AspirateWhileTracking
        | Comment
        | Custom
        | Dispense
        | DispenseInPlace
        | DispenseWhileTracking
        | BlowOut
        | BlowOutInPlace
        | ConfigureForVolume
        | ConfigureNozzleLayout
        | DropTip
        | DropTipInPlace
        | Home
        | RetractAxis
        | LoadLabware
        | ReloadLabware
        | LoadLiquid
        | LoadLiquidClass
        | LoadModule
        | IdentifyModule
        | LoadPipette
        | LoadLidStack
        | LoadLid
        | MoveLabware
        | MoveRelative
        | MoveToCoordinates
        | MoveToWell
        | MoveToAddressableArea
        | MoveToAddressableAreaForDropTip
        | PrepareToAspirate
        | WaitForResume
        | WaitForDuration
        | PickUpTip
        | SavePosition
        | SetRailLights
        | TouchTip
        | SetStatusBar
        | VerifyTipPresence
        | GetTipPresence
        | GetNextTip
        | LiquidProbe
        | TryLiquidProbe
        | SealPipetteToTip
        | PressureDispense
        | UnsealPipetteFromTip
        | OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperature
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperature
        | DeactivateHeater
        | SetAndWaitForShakeSpeed
        | DeactivateShaker
        | OpenLabwareLatch
        | CloseLabwareLatch
        | Disengage
        | Engage
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperature
        | OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperature
        | DeactivateTemperature
        | SetTargetBlockTemperature
        | WaitForBlockTemperature
        | SetTargetLidTemperature
        | WaitForLidTemperature
        | DeactivateBlock
        | DeactivateLid
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLid
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLid
        | RunProfile
        | RunExtendedProfile
        | OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLid
        | OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLid
        | Initialize
        | ReadAbsorbance
        | Retrieve
        | Store
        | SetStoredLabware
        | Fill
        | Empty
        | CalibrateGripper
        | CalibratePipette
        | CalibrateModule
        | MoveToMaintenancePosition
        | UnsafeBlowOutInPlace
        | UnsafeDropTipInPlace
        | UpdatePositionEstimators
        | UnsafeEngageAxes
        | UnsafeUngripLabware
        | UnsafePlaceLabware
        | UnsafeFlexStackerManualRetrieve
        | UnsafeFlexStackerCloseLatch
        | UnsafeFlexStackerOpenLatch
        | UnsafeFlexStackerPrepareShuttle
        | MoveTo
        | MoveAxesRelative
        | MoveAxesTo
        | OpenGripperJaw
        | CloseGripperJaw
    ) = Field(
        ...,
        description='The document’s primary data',
        discriminator='commandType',
        title='Data',
    )


class SimpleBodyUnionRunBadRun(BaseModel):
    data: Run | BadRun = Field(
        ..., description='The document’s primary data', title='Data'
    )


class Commands(BaseModel):
    __root__: (
        AirGapInPlace
        | Aspirate
        | AspirateInPlace
        | AspirateWhileTracking
        | Comment
        | Custom
        | Dispense
        | DispenseInPlace
        | DispenseWhileTracking
        | BlowOut
        | BlowOutInPlace
        | ConfigureForVolume
        | ConfigureNozzleLayout
        | DropTip
        | DropTipInPlace
        | Home
        | RetractAxis
        | LoadLabware
        | ReloadLabware
        | LoadLiquid
        | LoadLiquidClass
        | LoadModule
        | IdentifyModule
        | LoadPipette
        | LoadLidStack
        | LoadLid
        | MoveLabware
        | MoveRelative
        | MoveToCoordinates
        | MoveToWell
        | MoveToAddressableArea
        | MoveToAddressableAreaForDropTip
        | PrepareToAspirate
        | WaitForResume
        | WaitForDuration
        | PickUpTip
        | SavePosition
        | SetRailLights
        | TouchTip
        | SetStatusBar
        | VerifyTipPresence
        | GetTipPresence
        | GetNextTip
        | LiquidProbe
        | TryLiquidProbe
        | SealPipetteToTip
        | PressureDispense
        | UnsealPipetteFromTip
        | OpentronsProtocolEngineCommandsHeaterShakerWaitForTemperatureWaitForTemperature
        | OpentronsProtocolEngineCommandsHeaterShakerSetTargetTemperatureSetTargetTemperature
        | DeactivateHeater
        | SetAndWaitForShakeSpeed
        | DeactivateShaker
        | OpenLabwareLatch
        | CloseLabwareLatch
        | Disengage
        | Engage
        | OpentronsProtocolEngineCommandsTemperatureModuleSetTargetTemperatureSetTargetTemperature
        | OpentronsProtocolEngineCommandsTemperatureModuleWaitForTemperatureWaitForTemperature
        | DeactivateTemperature
        | SetTargetBlockTemperature
        | WaitForBlockTemperature
        | SetTargetLidTemperature
        | WaitForLidTemperature
        | DeactivateBlock
        | DeactivateLid
        | OpentronsProtocolEngineCommandsThermocyclerOpenLidOpenLid
        | OpentronsProtocolEngineCommandsThermocyclerCloseLidCloseLid
        | RunProfile
        | RunExtendedProfile
        | OpentronsProtocolEngineCommandsAbsorbanceReaderCloseLidCloseLid
        | OpentronsProtocolEngineCommandsAbsorbanceReaderOpenLidOpenLid
        | Initialize
        | ReadAbsorbance
        | Retrieve
        | Store
        | SetStoredLabware
        | Fill
        | Empty
        | CalibrateGripper
        | CalibratePipette
        | CalibrateModule
        | MoveToMaintenancePosition
        | UnsafeBlowOutInPlace
        | UnsafeDropTipInPlace
        | UpdatePositionEstimators
        | UnsafeEngageAxes
        | UnsafeUngripLabware
        | UnsafePlaceLabware
        | UnsafeFlexStackerManualRetrieve
        | UnsafeFlexStackerCloseLatch
        | UnsafeFlexStackerOpenLatch
        | UnsafeFlexStackerPrepareShuttle
        | MoveTo
        | MoveAxesRelative
        | MoveAxesTo
        | OpenGripperJaw
        | CloseGripperJaw
    ) = Field(..., discriminator='commandType')


class CompletedAnalysis(BaseModel):
    """
    A completed protocol run analysis.

    This analysis provides three pieces of information:

    - A smoke test on whether the run is expected to succeed, given available data.
    - The equipment (labware, pipettes, modules) that the protocol will use.
    - The run commands that the protocol is expected to issue.

    !!! important "Important note about non-deterministic protocols"
        Python protocols are allowed to be written in a way that makes their
        behavior non-deterministic. For example, a protocol could use ``random``
        to determine how much volume to aspirate.

        If a protocol is non-deterministic, an analysis may differ from the
        actual run (or any subsequent analysis). If you are writing or using
        non-deterministic protocols, please keep this fact in mind.

        JSON protocols are currently deterministic by design.
    """

    id: str = Field(
        ..., description='Unique identifier of this analysis resource', title='Id'
    )
    status: Status = Field(
        'completed',
        const=True,
        description='Status marking the analysis as completed',
        title='Status',
    )
    result: AnalysisResult = Field(
        ..., description='Whether the protocol is expected to run successfully'
    )
    robotType: RobotType | None = Field(
        None,
        description='The type of robot that this protocol can run on. This field was added in v7.1.0. It will be `null` or omitted in analyses that were originally created on older versions.',
        title='Robottype',
    )
    runTimeParameters: (
        list[NumberParameter | EnumParameter | BooleanParameter | CSVParameter] | None
    ) = Field(
        None,
        description='Run time parameters used during analysis. These are the parameters that are defined in the protocol, with values specified either in the protocol creation request or reanalysis request (whichever started this analysis), or default values from the protocol if none are specified in the request.',
        title='Runtimeparameters',
    )
    commands: list[Commands] = Field(
        ...,
        description='The protocol commands the run is expected to produce',
        title='Commands',
    )
    labware: list[LoadedLabware] = Field(
        ...,
        description='Labware used by the protocol.\n\nIf a piece of labware moves between locations as part of the protocol, its *final* location will be reported in this list, not its *initial* location.',
        title='Labware',
    )
    pipettes: list[LoadedPipette] = Field(
        ..., description='Pipettes used by the protocol', title='Pipettes'
    )
    modules: list[LoadedModule] | None = Field(
        None, description='Modules that have been loaded into the run.', title='Modules'
    )
    liquids: list[Liquid] | None = Field(
        None, description='Liquids used by the protocol', title='Liquids'
    )
    liquidClasses: list[LiquidClassRecordWithId] | None = Field(
        None, description='Liquid classes used by the protocol', title='Liquidclasses'
    )
    errors: list[ErrorOccurrence] = Field(
        ...,
        description="The protocol's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element.",
        title='Errors',
    )
    commandAnnotations: (
        list[SecondOrderCommandAnnotation | CustomCommandAnnotation] | None
    ) = Field(
        None,
        description='Optional annotations for commands in this run.',
        title='Commandannotations',
    )


class SimpleBodyUnionPendingAnalysisCompletedAnalysis(BaseModel):
    data: PendingAnalysis | CompletedAnalysis = Field(
        ..., description='The document’s primary data', title='Data'
    )


class SimpleMultiBodyUnionPendingAnalysisCompletedAnalysis(BaseModel):
    data: list[PendingAnalysis | CompletedAnalysis] = Field(
        ..., description='The documents primary data', title='Data'
    )
    meta: MultiBodyMeta = Field(
        ..., description='Metadata about the collection response.'
    )


ErrorOccurrence.update_forward_refs()
